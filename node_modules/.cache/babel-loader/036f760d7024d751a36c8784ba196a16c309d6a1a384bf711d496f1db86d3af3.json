{"ast":null,"code":"const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;\nconst numRegex = /^([\\-\\+])?(0*)([0-9]*(\\.[0-9]*)?)$/;\n// const octRegex = /^0x[a-z0-9]+/;\n// const binRegex = /0x[a-z0-9]+/;\n\nconst consider = {\n  hex: true,\n  // oct: false,\n  leadingZeros: true,\n  decimalPoint: \"\\.\",\n  eNotation: true\n  //skipLike: /regex/\n};\nfunction toNumber(str) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  options = Object.assign({}, consider, options);\n  if (!str || typeof str !== \"string\") return str;\n  let trimmedStr = str.trim();\n  if (options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;else if (str === \"0\") return 0;else if (options.hex && hexRegex.test(trimmedStr)) {\n    return parse_int(trimmedStr, 16);\n    // }else if (options.oct && octRegex.test(str)) {\n    //     return Number.parseInt(val, 8);\n  } else if (trimmedStr.search(/[eE]/) !== -1) {\n    //eNotation\n    const notation = trimmedStr.match(/^([-\\+])?(0*)([0-9]*(\\.[0-9]*)?[eE][-\\+]?[0-9]+)$/);\n    // +00.123 => [ , '+', '00', '.123', ..\n    if (notation) {\n      // console.log(notation)\n      if (options.leadingZeros) {\n        //accept with leading zeros\n        trimmedStr = (notation[1] || \"\") + notation[3];\n      } else {\n        if (notation[2] === \"0\" && notation[3][0] === \".\") {//valid number\n        } else {\n          return str;\n        }\n      }\n      return options.eNotation ? Number(trimmedStr) : str;\n    } else {\n      return str;\n    }\n    // }else if (options.parseBin && binRegex.test(str)) {\n    //     return Number.parseInt(val, 2);\n  } else {\n    //separate negative sign, leading zeros, and rest number\n    const match = numRegex.exec(trimmedStr);\n    // +00.123 => [ , '+', '00', '.123', ..\n    if (match) {\n      const sign = match[1];\n      const leadingZeros = match[2];\n      let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros\n      //trim ending zeros for floating number\n\n      if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== \".\") return str; //-0123\n      else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== \".\") return str; //0123\n      else if (options.leadingZeros && leadingZeros === str) return 0; //00\n      else {\n        //no leading zeros or leading zeros are allowed\n        const num = Number(trimmedStr);\n        const numStr = \"\" + num;\n        if (numStr.search(/[eE]/) !== -1) {\n          //given number is long and parsed to eNotation\n          if (options.eNotation) return num;else return str;\n        } else if (trimmedStr.indexOf(\".\") !== -1) {\n          //floating number\n          if (numStr === \"0\" && numTrimmedByZeros === \"\") return num; //0.0\n          else if (numStr === numTrimmedByZeros) return num; //0.456. 0.79000\n          else if (sign && numStr === \"-\" + numTrimmedByZeros) return num;else return str;\n        }\n        if (leadingZeros) {\n          return numTrimmedByZeros === numStr || sign + numTrimmedByZeros === numStr ? num : str;\n        } else {\n          return trimmedStr === numStr || trimmedStr === sign + numStr ? num : str;\n        }\n      }\n    } else {\n      //non-numeric string\n      return str;\n    }\n  }\n}\n\n/**\n * \n * @param {string} numStr without leading zeros\n * @returns \n */\nfunction trimZeros(numStr) {\n  if (numStr && numStr.indexOf(\".\") !== -1) {\n    //float\n    numStr = numStr.replace(/0+$/, \"\"); //remove ending zeros\n    if (numStr === \".\") numStr = \"0\";else if (numStr[0] === \".\") numStr = \"0\" + numStr;else if (numStr[numStr.length - 1] === \".\") numStr = numStr.substr(0, numStr.length - 1);\n    return numStr;\n  }\n  return numStr;\n}\nfunction parse_int(numStr, base) {\n  //polyfill\n  if (parseInt) return parseInt(numStr, base);else if (Number.parseInt) return Number.parseInt(numStr, base);else if (window && window.parseInt) return window.parseInt(numStr, base);else throw new Error(\"parseInt, Number.parseInt, window.parseInt are not supported\");\n}\nmodule.exports = toNumber;","map":{"version":3,"names":["hexRegex","numRegex","consider","hex","leadingZeros","decimalPoint","eNotation","toNumber","str","options","arguments","length","undefined","Object","assign","trimmedStr","trim","skipLike","test","parse_int","search","notation","match","Number","exec","sign","numTrimmedByZeros","trimZeros","num","numStr","indexOf","replace","substr","base","parseInt","window","Error","module","exports"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/strnum/strnum.js"],"sourcesContent":["const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;\nconst numRegex = /^([\\-\\+])?(0*)([0-9]*(\\.[0-9]*)?)$/;\n// const octRegex = /^0x[a-z0-9]+/;\n// const binRegex = /0x[a-z0-9]+/;\n\n \nconst consider = {\n    hex :  true,\n    // oct: false,\n    leadingZeros: true,\n    decimalPoint: \"\\.\",\n    eNotation: true,\n    //skipLike: /regex/\n};\n\nfunction toNumber(str, options = {}){\n    options = Object.assign({}, consider, options );\n    if(!str || typeof str !== \"string\" ) return str;\n    \n    let trimmedStr  = str.trim();\n    \n    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;\n    else if(str===\"0\") return 0;\n    else if (options.hex && hexRegex.test(trimmedStr)) {\n        return parse_int(trimmedStr, 16);\n    // }else if (options.oct && octRegex.test(str)) {\n    //     return Number.parseInt(val, 8);\n    }else if (trimmedStr.search(/[eE]/)!== -1) { //eNotation\n        const notation = trimmedStr.match(/^([-\\+])?(0*)([0-9]*(\\.[0-9]*)?[eE][-\\+]?[0-9]+)$/); \n        // +00.123 => [ , '+', '00', '.123', ..\n        if(notation){\n            // console.log(notation)\n            if(options.leadingZeros){ //accept with leading zeros\n                trimmedStr = (notation[1] || \"\") + notation[3];\n            }else{\n                if(notation[2] === \"0\" && notation[3][0]=== \".\"){ //valid number\n                }else{\n                    return str;\n                }\n            }\n            return options.eNotation ? Number(trimmedStr) : str;\n        }else{\n            return str;\n        }\n    // }else if (options.parseBin && binRegex.test(str)) {\n    //     return Number.parseInt(val, 2);\n    }else{\n        //separate negative sign, leading zeros, and rest number\n        const match = numRegex.exec(trimmedStr);\n        // +00.123 => [ , '+', '00', '.123', ..\n        if(match){\n            const sign = match[1];\n            const leadingZeros = match[2];\n            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros\n            //trim ending zeros for floating number\n            \n            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== \".\") return str; //-0123\n            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== \".\") return str; //0123\n            else if(options.leadingZeros && leadingZeros===str) return 0; //00\n            \n            else{//no leading zeros or leading zeros are allowed\n                const num = Number(trimmedStr);\n                const numStr = \"\" + num;\n\n                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation\n                    if(options.eNotation) return num;\n                    else return str;\n                }else if(trimmedStr.indexOf(\".\") !== -1){ //floating number\n                    if(numStr === \"0\" && (numTrimmedByZeros === \"\") ) return num; //0.0\n                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000\n                    else if( sign && numStr === \"-\"+numTrimmedByZeros) return num;\n                    else return str;\n                }\n                \n                if(leadingZeros){\n                    return (numTrimmedByZeros === numStr) || (sign+numTrimmedByZeros === numStr) ? num : str\n                }else  {\n                    return (trimmedStr === numStr) || (trimmedStr === sign+numStr) ? num : str\n                }\n            }\n        }else{ //non-numeric string\n            return str;\n        }\n    }\n}\n\n/**\n * \n * @param {string} numStr without leading zeros\n * @returns \n */\nfunction trimZeros(numStr){\n    if(numStr && numStr.indexOf(\".\") !== -1){//float\n        numStr = numStr.replace(/0+$/, \"\"); //remove ending zeros\n        if(numStr === \".\")  numStr = \"0\";\n        else if(numStr[0] === \".\")  numStr = \"0\"+numStr;\n        else if(numStr[numStr.length-1] === \".\")  numStr = numStr.substr(0,numStr.length-1);\n        return numStr;\n    }\n    return numStr;\n}\n\nfunction parse_int(numStr, base){\n    //polyfill\n    if(parseInt) return parseInt(numStr, base);\n    else if(Number.parseInt) return Number.parseInt(numStr, base);\n    else if(window && window.parseInt) return window.parseInt(numStr, base);\n    else throw new Error(\"parseInt, Number.parseInt, window.parseInt are not supported\")\n}\n\nmodule.exports = toNumber;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"import { HttpRequest, HttpResponse } from \"@smithy/protocol-http\";\nimport { isThrottlingError } from \"@smithy/service-error-classification\";\nimport { DEFAULT_MAX_ATTEMPTS, DEFAULT_RETRY_DELAY_BASE, INITIAL_RETRY_TOKENS, INVOCATION_ID_HEADER, REQUEST_HEADER, RETRY_MODES, THROTTLING_RETRY_DELAY_BASE } from \"@smithy/util-retry\";\nimport { v4 } from \"uuid\";\nimport { getDefaultRetryQuota } from \"./defaultRetryQuota\";\nimport { defaultDelayDecider } from \"./delayDecider\";\nimport { defaultRetryDecider } from \"./retryDecider\";\nimport { asSdkError } from \"./util\";\nexport class StandardRetryStrategy {\n  constructor(maxAttemptsProvider, options) {\n    var _options$retryDecider, _options$delayDecider, _options$retryQuota;\n    this.maxAttemptsProvider = maxAttemptsProvider;\n    this.mode = RETRY_MODES.STANDARD;\n    this.retryDecider = (_options$retryDecider = options === null || options === void 0 ? void 0 : options.retryDecider) !== null && _options$retryDecider !== void 0 ? _options$retryDecider : defaultRetryDecider;\n    this.delayDecider = (_options$delayDecider = options === null || options === void 0 ? void 0 : options.delayDecider) !== null && _options$delayDecider !== void 0 ? _options$delayDecider : defaultDelayDecider;\n    this.retryQuota = (_options$retryQuota = options === null || options === void 0 ? void 0 : options.retryQuota) !== null && _options$retryQuota !== void 0 ? _options$retryQuota : getDefaultRetryQuota(INITIAL_RETRY_TOKENS);\n  }\n  shouldRetry(error, attempts, maxAttempts) {\n    return attempts < maxAttempts && this.retryDecider(error) && this.retryQuota.hasRetryTokens(error);\n  }\n  async getMaxAttempts() {\n    let maxAttempts;\n    try {\n      maxAttempts = await this.maxAttemptsProvider();\n    } catch (error) {\n      maxAttempts = DEFAULT_MAX_ATTEMPTS;\n    }\n    return maxAttempts;\n  }\n  async retry(next, args, options) {\n    let retryTokenAmount;\n    let attempts = 0;\n    let totalDelay = 0;\n    const maxAttempts = await this.getMaxAttempts();\n    const {\n      request\n    } = args;\n    if (HttpRequest.isInstance(request)) {\n      request.headers[INVOCATION_ID_HEADER] = v4();\n    }\n    while (true) {\n      try {\n        if (HttpRequest.isInstance(request)) {\n          request.headers[REQUEST_HEADER] = \"attempt=\".concat(attempts + 1, \"; max=\").concat(maxAttempts);\n        }\n        if (options !== null && options !== void 0 && options.beforeRequest) {\n          await options.beforeRequest();\n        }\n        const {\n          response,\n          output\n        } = await next(args);\n        if (options !== null && options !== void 0 && options.afterRequest) {\n          options.afterRequest(response);\n        }\n        this.retryQuota.releaseRetryTokens(retryTokenAmount);\n        output.$metadata.attempts = attempts + 1;\n        output.$metadata.totalRetryDelay = totalDelay;\n        return {\n          response,\n          output\n        };\n      } catch (e) {\n        const err = asSdkError(e);\n        attempts++;\n        if (this.shouldRetry(err, attempts, maxAttempts)) {\n          retryTokenAmount = this.retryQuota.retrieveRetryTokens(err);\n          const delayFromDecider = this.delayDecider(isThrottlingError(err) ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE, attempts);\n          const delayFromResponse = getDelayFromRetryAfterHeader(err.$response);\n          const delay = Math.max(delayFromResponse || 0, delayFromDecider);\n          totalDelay += delay;\n          await new Promise(resolve => setTimeout(resolve, delay));\n          continue;\n        }\n        if (!err.$metadata) {\n          err.$metadata = {};\n        }\n        err.$metadata.attempts = attempts;\n        err.$metadata.totalRetryDelay = totalDelay;\n        throw err;\n      }\n    }\n  }\n}\nconst getDelayFromRetryAfterHeader = response => {\n  if (!HttpResponse.isInstance(response)) return;\n  const retryAfterHeaderName = Object.keys(response.headers).find(key => key.toLowerCase() === \"retry-after\");\n  if (!retryAfterHeaderName) return;\n  const retryAfter = response.headers[retryAfterHeaderName];\n  const retryAfterSeconds = Number(retryAfter);\n  if (!Number.isNaN(retryAfterSeconds)) return retryAfterSeconds * 1000;\n  const retryAfterDate = new Date(retryAfter);\n  return retryAfterDate.getTime() - Date.now();\n};","map":{"version":3,"names":["HttpRequest","HttpResponse","isThrottlingError","DEFAULT_MAX_ATTEMPTS","DEFAULT_RETRY_DELAY_BASE","INITIAL_RETRY_TOKENS","INVOCATION_ID_HEADER","REQUEST_HEADER","RETRY_MODES","THROTTLING_RETRY_DELAY_BASE","v4","getDefaultRetryQuota","defaultDelayDecider","defaultRetryDecider","asSdkError","StandardRetryStrategy","constructor","maxAttemptsProvider","options","_options$retryDecider","_options$delayDecider","_options$retryQuota","mode","STANDARD","retryDecider","delayDecider","retryQuota","shouldRetry","error","attempts","maxAttempts","hasRetryTokens","getMaxAttempts","retry","next","args","retryTokenAmount","totalDelay","request","isInstance","headers","concat","beforeRequest","response","output","afterRequest","releaseRetryTokens","$metadata","totalRetryDelay","e","err","retrieveRetryTokens","delayFromDecider","delayFromResponse","getDelayFromRetryAfterHeader","$response","delay","Math","max","Promise","resolve","setTimeout","retryAfterHeaderName","Object","keys","find","key","toLowerCase","retryAfter","retryAfterSeconds","Number","isNaN","retryAfterDate","Date","getTime","now"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/@smithy/middleware-retry/dist-es/StandardRetryStrategy.js"],"sourcesContent":["import { HttpRequest, HttpResponse } from \"@smithy/protocol-http\";\nimport { isThrottlingError } from \"@smithy/service-error-classification\";\nimport { DEFAULT_MAX_ATTEMPTS, DEFAULT_RETRY_DELAY_BASE, INITIAL_RETRY_TOKENS, INVOCATION_ID_HEADER, REQUEST_HEADER, RETRY_MODES, THROTTLING_RETRY_DELAY_BASE, } from \"@smithy/util-retry\";\nimport { v4 } from \"uuid\";\nimport { getDefaultRetryQuota } from \"./defaultRetryQuota\";\nimport { defaultDelayDecider } from \"./delayDecider\";\nimport { defaultRetryDecider } from \"./retryDecider\";\nimport { asSdkError } from \"./util\";\nexport class StandardRetryStrategy {\n    constructor(maxAttemptsProvider, options) {\n        this.maxAttemptsProvider = maxAttemptsProvider;\n        this.mode = RETRY_MODES.STANDARD;\n        this.retryDecider = options?.retryDecider ?? defaultRetryDecider;\n        this.delayDecider = options?.delayDecider ?? defaultDelayDecider;\n        this.retryQuota = options?.retryQuota ?? getDefaultRetryQuota(INITIAL_RETRY_TOKENS);\n    }\n    shouldRetry(error, attempts, maxAttempts) {\n        return attempts < maxAttempts && this.retryDecider(error) && this.retryQuota.hasRetryTokens(error);\n    }\n    async getMaxAttempts() {\n        let maxAttempts;\n        try {\n            maxAttempts = await this.maxAttemptsProvider();\n        }\n        catch (error) {\n            maxAttempts = DEFAULT_MAX_ATTEMPTS;\n        }\n        return maxAttempts;\n    }\n    async retry(next, args, options) {\n        let retryTokenAmount;\n        let attempts = 0;\n        let totalDelay = 0;\n        const maxAttempts = await this.getMaxAttempts();\n        const { request } = args;\n        if (HttpRequest.isInstance(request)) {\n            request.headers[INVOCATION_ID_HEADER] = v4();\n        }\n        while (true) {\n            try {\n                if (HttpRequest.isInstance(request)) {\n                    request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;\n                }\n                if (options?.beforeRequest) {\n                    await options.beforeRequest();\n                }\n                const { response, output } = await next(args);\n                if (options?.afterRequest) {\n                    options.afterRequest(response);\n                }\n                this.retryQuota.releaseRetryTokens(retryTokenAmount);\n                output.$metadata.attempts = attempts + 1;\n                output.$metadata.totalRetryDelay = totalDelay;\n                return { response, output };\n            }\n            catch (e) {\n                const err = asSdkError(e);\n                attempts++;\n                if (this.shouldRetry(err, attempts, maxAttempts)) {\n                    retryTokenAmount = this.retryQuota.retrieveRetryTokens(err);\n                    const delayFromDecider = this.delayDecider(isThrottlingError(err) ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE, attempts);\n                    const delayFromResponse = getDelayFromRetryAfterHeader(err.$response);\n                    const delay = Math.max(delayFromResponse || 0, delayFromDecider);\n                    totalDelay += delay;\n                    await new Promise((resolve) => setTimeout(resolve, delay));\n                    continue;\n                }\n                if (!err.$metadata) {\n                    err.$metadata = {};\n                }\n                err.$metadata.attempts = attempts;\n                err.$metadata.totalRetryDelay = totalDelay;\n                throw err;\n            }\n        }\n    }\n}\nconst getDelayFromRetryAfterHeader = (response) => {\n    if (!HttpResponse.isInstance(response))\n        return;\n    const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === \"retry-after\");\n    if (!retryAfterHeaderName)\n        return;\n    const retryAfter = response.headers[retryAfterHeaderName];\n    const retryAfterSeconds = Number(retryAfter);\n    if (!Number.isNaN(retryAfterSeconds))\n        return retryAfterSeconds * 1000;\n    const retryAfterDate = new Date(retryAfter);\n    return retryAfterDate.getTime() - Date.now();\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
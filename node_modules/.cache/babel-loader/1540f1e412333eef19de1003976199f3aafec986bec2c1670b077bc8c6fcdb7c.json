{"ast":null,"code":"import { getValueFromTextNode } from \"@smithy/smithy-client\";\nimport { XMLParser } from \"fast-xml-parser\";\nimport { collectBodyString } from \"../common\";\nexport const parseXmlBody = (streamBody, context) => collectBodyString(streamBody, context).then(encoded => {\n  if (encoded.length) {\n    const parser = new XMLParser({\n      attributeNamePrefix: \"\",\n      htmlEntities: true,\n      ignoreAttributes: false,\n      ignoreDeclaration: true,\n      parseTagValue: false,\n      trimValues: false,\n      tagValueProcessor: (_, val) => val.trim() === \"\" && val.includes(\"\\n\") ? \"\" : undefined\n    });\n    parser.addEntity(\"#xD\", \"\\r\");\n    parser.addEntity(\"#10\", \"\\n\");\n    let parsedObj;\n    try {\n      parsedObj = parser.parse(encoded, true);\n    } catch (e) {\n      if (e && typeof e === \"object\") {\n        Object.defineProperty(e, \"$responseBodyText\", {\n          value: encoded\n        });\n      }\n      throw e;\n    }\n    const textNodeName = \"#text\";\n    const key = Object.keys(parsedObj)[0];\n    const parsedObjToReturn = parsedObj[key];\n    if (parsedObjToReturn[textNodeName]) {\n      parsedObjToReturn[key] = parsedObjToReturn[textNodeName];\n      delete parsedObjToReturn[textNodeName];\n    }\n    return getValueFromTextNode(parsedObjToReturn);\n  }\n  return {};\n});\nexport const parseXmlErrorBody = async (errorBody, context) => {\n  const value = await parseXmlBody(errorBody, context);\n  if (value.Error) {\n    var _value$Error$message;\n    value.Error.message = (_value$Error$message = value.Error.message) !== null && _value$Error$message !== void 0 ? _value$Error$message : value.Error.Message;\n  }\n  return value;\n};\nexport const loadRestXmlErrorCode = (output, data) => {\n  var _data$Error;\n  if ((data === null || data === void 0 || (_data$Error = data.Error) === null || _data$Error === void 0 ? void 0 : _data$Error.Code) !== undefined) {\n    return data.Error.Code;\n  }\n  if ((data === null || data === void 0 ? void 0 : data.Code) !== undefined) {\n    return data.Code;\n  }\n  if (output.statusCode == 404) {\n    return \"NotFound\";\n  }\n};","map":{"version":3,"names":["getValueFromTextNode","XMLParser","collectBodyString","parseXmlBody","streamBody","context","then","encoded","length","parser","attributeNamePrefix","htmlEntities","ignoreAttributes","ignoreDeclaration","parseTagValue","trimValues","tagValueProcessor","_","val","trim","includes","undefined","addEntity","parsedObj","parse","e","Object","defineProperty","value","textNodeName","key","keys","parsedObjToReturn","parseXmlErrorBody","errorBody","Error","_value$Error$message","message","Message","loadRestXmlErrorCode","output","data","_data$Error","Code","statusCode"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/parseXmlBody.js"],"sourcesContent":["import { getValueFromTextNode } from \"@smithy/smithy-client\";\nimport { XMLParser } from \"fast-xml-parser\";\nimport { collectBodyString } from \"../common\";\nexport const parseXmlBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {\n    if (encoded.length) {\n        const parser = new XMLParser({\n            attributeNamePrefix: \"\",\n            htmlEntities: true,\n            ignoreAttributes: false,\n            ignoreDeclaration: true,\n            parseTagValue: false,\n            trimValues: false,\n            tagValueProcessor: (_, val) => (val.trim() === \"\" && val.includes(\"\\n\") ? \"\" : undefined),\n        });\n        parser.addEntity(\"#xD\", \"\\r\");\n        parser.addEntity(\"#10\", \"\\n\");\n        let parsedObj;\n        try {\n            parsedObj = parser.parse(encoded, true);\n        }\n        catch (e) {\n            if (e && typeof e === \"object\") {\n                Object.defineProperty(e, \"$responseBodyText\", {\n                    value: encoded,\n                });\n            }\n            throw e;\n        }\n        const textNodeName = \"#text\";\n        const key = Object.keys(parsedObj)[0];\n        const parsedObjToReturn = parsedObj[key];\n        if (parsedObjToReturn[textNodeName]) {\n            parsedObjToReturn[key] = parsedObjToReturn[textNodeName];\n            delete parsedObjToReturn[textNodeName];\n        }\n        return getValueFromTextNode(parsedObjToReturn);\n    }\n    return {};\n});\nexport const parseXmlErrorBody = async (errorBody, context) => {\n    const value = await parseXmlBody(errorBody, context);\n    if (value.Error) {\n        value.Error.message = value.Error.message ?? value.Error.Message;\n    }\n    return value;\n};\nexport const loadRestXmlErrorCode = (output, data) => {\n    if (data?.Error?.Code !== undefined) {\n        return data.Error.Code;\n    }\n    if (data?.Code !== undefined) {\n        return data.Code;\n    }\n    if (output.statusCode == 404) {\n        return \"NotFound\";\n    }\n};\n"],"mappings":"AAAA,SAASA,oBAAoB,QAAQ,uBAAuB;AAC5D,SAASC,SAAS,QAAQ,iBAAiB;AAC3C,SAASC,iBAAiB,QAAQ,WAAW;AAC7C,OAAO,MAAMC,YAAY,GAAGA,CAACC,UAAU,EAAEC,OAAO,KAAKH,iBAAiB,CAACE,UAAU,EAAEC,OAAO,CAAC,CAACC,IAAI,CAAEC,OAAO,IAAK;EAC1G,IAAIA,OAAO,CAACC,MAAM,EAAE;IAChB,MAAMC,MAAM,GAAG,IAAIR,SAAS,CAAC;MACzBS,mBAAmB,EAAE,EAAE;MACvBC,YAAY,EAAE,IAAI;MAClBC,gBAAgB,EAAE,KAAK;MACvBC,iBAAiB,EAAE,IAAI;MACvBC,aAAa,EAAE,KAAK;MACpBC,UAAU,EAAE,KAAK;MACjBC,iBAAiB,EAAEA,CAACC,CAAC,EAAEC,GAAG,KAAMA,GAAG,CAACC,IAAI,CAAC,CAAC,KAAK,EAAE,IAAID,GAAG,CAACE,QAAQ,CAAC,IAAI,CAAC,GAAG,EAAE,GAAGC;IACnF,CAAC,CAAC;IACFZ,MAAM,CAACa,SAAS,CAAC,KAAK,EAAE,IAAI,CAAC;IAC7Bb,MAAM,CAACa,SAAS,CAAC,KAAK,EAAE,IAAI,CAAC;IAC7B,IAAIC,SAAS;IACb,IAAI;MACAA,SAAS,GAAGd,MAAM,CAACe,KAAK,CAACjB,OAAO,EAAE,IAAI,CAAC;IAC3C,CAAC,CACD,OAAOkB,CAAC,EAAE;MACN,IAAIA,CAAC,IAAI,OAAOA,CAAC,KAAK,QAAQ,EAAE;QAC5BC,MAAM,CAACC,cAAc,CAACF,CAAC,EAAE,mBAAmB,EAAE;UAC1CG,KAAK,EAAErB;QACX,CAAC,CAAC;MACN;MACA,MAAMkB,CAAC;IACX;IACA,MAAMI,YAAY,GAAG,OAAO;IAC5B,MAAMC,GAAG,GAAGJ,MAAM,CAACK,IAAI,CAACR,SAAS,CAAC,CAAC,CAAC,CAAC;IACrC,MAAMS,iBAAiB,GAAGT,SAAS,CAACO,GAAG,CAAC;IACxC,IAAIE,iBAAiB,CAACH,YAAY,CAAC,EAAE;MACjCG,iBAAiB,CAACF,GAAG,CAAC,GAAGE,iBAAiB,CAACH,YAAY,CAAC;MACxD,OAAOG,iBAAiB,CAACH,YAAY,CAAC;IAC1C;IACA,OAAO7B,oBAAoB,CAACgC,iBAAiB,CAAC;EAClD;EACA,OAAO,CAAC,CAAC;AACb,CAAC,CAAC;AACF,OAAO,MAAMC,iBAAiB,GAAG,MAAAA,CAAOC,SAAS,EAAE7B,OAAO,KAAK;EAC3D,MAAMuB,KAAK,GAAG,MAAMzB,YAAY,CAAC+B,SAAS,EAAE7B,OAAO,CAAC;EACpD,IAAIuB,KAAK,CAACO,KAAK,EAAE;IAAA,IAAAC,oBAAA;IACbR,KAAK,CAACO,KAAK,CAACE,OAAO,IAAAD,oBAAA,GAAGR,KAAK,CAACO,KAAK,CAACE,OAAO,cAAAD,oBAAA,cAAAA,oBAAA,GAAIR,KAAK,CAACO,KAAK,CAACG,OAAO;EACpE;EACA,OAAOV,KAAK;AAChB,CAAC;AACD,OAAO,MAAMW,oBAAoB,GAAGA,CAACC,MAAM,EAAEC,IAAI,KAAK;EAAA,IAAAC,WAAA;EAClD,IAAI,CAAAD,IAAI,aAAJA,IAAI,gBAAAC,WAAA,GAAJD,IAAI,CAAEN,KAAK,cAAAO,WAAA,uBAAXA,WAAA,CAAaC,IAAI,MAAKtB,SAAS,EAAE;IACjC,OAAOoB,IAAI,CAACN,KAAK,CAACQ,IAAI;EAC1B;EACA,IAAI,CAAAF,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAEE,IAAI,MAAKtB,SAAS,EAAE;IAC1B,OAAOoB,IAAI,CAACE,IAAI;EACpB;EACA,IAAIH,MAAM,CAACI,UAAU,IAAI,GAAG,EAAE;IAC1B,OAAO,UAAU;EACrB;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
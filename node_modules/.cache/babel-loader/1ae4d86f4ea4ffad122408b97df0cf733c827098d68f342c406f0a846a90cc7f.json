{"ast":null,"code":"import { NormalizedSchema, SCHEMA } from \"@smithy/core/schema\";\nimport { dateToUtcString, LazyJsonString, quoteHeader } from \"@smithy/core/serde\";\nimport { toBase64 } from \"@smithy/util-base64\";\nimport { determineTimestampFormat } from \"./determineTimestampFormat\";\nexport class ToStringShapeSerializer {\n  constructor(settings) {\n    this.settings = settings;\n    this.stringBuffer = \"\";\n    this.serdeContext = undefined;\n  }\n  setSerdeContext(serdeContext) {\n    this.serdeContext = serdeContext;\n  }\n  write(schema, value) {\n    const ns = NormalizedSchema.of(schema);\n    switch (typeof value) {\n      case \"object\":\n        if (value === null) {\n          this.stringBuffer = \"null\";\n          return;\n        }\n        if (ns.isTimestampSchema()) {\n          if (!(value instanceof Date)) {\n            throw new Error(\"@smithy/core/protocols - received non-Date value \".concat(value, \" when schema expected Date in \").concat(ns.getName(true)));\n          }\n          const format = determineTimestampFormat(ns, this.settings);\n          switch (format) {\n            case SCHEMA.TIMESTAMP_DATE_TIME:\n              this.stringBuffer = value.toISOString().replace(\".000Z\", \"Z\");\n              break;\n            case SCHEMA.TIMESTAMP_HTTP_DATE:\n              this.stringBuffer = dateToUtcString(value);\n              break;\n            case SCHEMA.TIMESTAMP_EPOCH_SECONDS:\n              this.stringBuffer = String(value.getTime() / 1000);\n              break;\n            default:\n              console.warn(\"Missing timestamp format, using epoch seconds\", value);\n              this.stringBuffer = String(value.getTime() / 1000);\n          }\n          return;\n        }\n        if (ns.isBlobSchema() && \"byteLength\" in value) {\n          var _this$serdeContext$ba, _this$serdeContext;\n          this.stringBuffer = ((_this$serdeContext$ba = (_this$serdeContext = this.serdeContext) === null || _this$serdeContext === void 0 ? void 0 : _this$serdeContext.base64Encoder) !== null && _this$serdeContext$ba !== void 0 ? _this$serdeContext$ba : toBase64)(value);\n          return;\n        }\n        if (ns.isListSchema() && Array.isArray(value)) {\n          let buffer = \"\";\n          for (const item of value) {\n            this.write([ns.getValueSchema(), ns.getMergedTraits()], item);\n            const headerItem = this.flush();\n            const serialized = ns.getValueSchema().isTimestampSchema() ? headerItem : quoteHeader(headerItem);\n            if (buffer !== \"\") {\n              buffer += \", \";\n            }\n            buffer += serialized;\n          }\n          this.stringBuffer = buffer;\n          return;\n        }\n        this.stringBuffer = JSON.stringify(value, null, 2);\n        break;\n      case \"string\":\n        const mediaType = ns.getMergedTraits().mediaType;\n        let intermediateValue = value;\n        if (mediaType) {\n          const isJson = mediaType === \"application/json\" || mediaType.endsWith(\"+json\");\n          if (isJson) {\n            intermediateValue = LazyJsonString.from(intermediateValue);\n          }\n          if (ns.getMergedTraits().httpHeader) {\n            var _this$serdeContext$ba2, _this$serdeContext2;\n            this.stringBuffer = ((_this$serdeContext$ba2 = (_this$serdeContext2 = this.serdeContext) === null || _this$serdeContext2 === void 0 ? void 0 : _this$serdeContext2.base64Encoder) !== null && _this$serdeContext$ba2 !== void 0 ? _this$serdeContext$ba2 : toBase64)(intermediateValue.toString());\n            return;\n          }\n        }\n        this.stringBuffer = value;\n        break;\n      default:\n        this.stringBuffer = String(value);\n    }\n  }\n  flush() {\n    const buffer = this.stringBuffer;\n    this.stringBuffer = \"\";\n    return buffer;\n  }\n}","map":{"version":3,"names":["NormalizedSchema","SCHEMA","dateToUtcString","LazyJsonString","quoteHeader","toBase64","determineTimestampFormat","ToStringShapeSerializer","constructor","settings","stringBuffer","serdeContext","undefined","setSerdeContext","write","schema","value","ns","of","isTimestampSchema","Date","Error","concat","getName","format","TIMESTAMP_DATE_TIME","toISOString","replace","TIMESTAMP_HTTP_DATE","TIMESTAMP_EPOCH_SECONDS","String","getTime","console","warn","isBlobSchema","_this$serdeContext$ba","_this$serdeContext","base64Encoder","isListSchema","Array","isArray","buffer","item","getValueSchema","getMergedTraits","headerItem","flush","serialized","JSON","stringify","mediaType","intermediateValue","isJson","endsWith","from","httpHeader","_this$serdeContext$ba2","_this$serdeContext2","toString"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/@smithy/core/dist-es/submodules/protocols/serde/ToStringShapeSerializer.js"],"sourcesContent":["import { NormalizedSchema, SCHEMA } from \"@smithy/core/schema\";\nimport { dateToUtcString, LazyJsonString, quoteHeader } from \"@smithy/core/serde\";\nimport { toBase64 } from \"@smithy/util-base64\";\nimport { determineTimestampFormat } from \"./determineTimestampFormat\";\nexport class ToStringShapeSerializer {\n    constructor(settings) {\n        this.settings = settings;\n        this.stringBuffer = \"\";\n        this.serdeContext = undefined;\n    }\n    setSerdeContext(serdeContext) {\n        this.serdeContext = serdeContext;\n    }\n    write(schema, value) {\n        const ns = NormalizedSchema.of(schema);\n        switch (typeof value) {\n            case \"object\":\n                if (value === null) {\n                    this.stringBuffer = \"null\";\n                    return;\n                }\n                if (ns.isTimestampSchema()) {\n                    if (!(value instanceof Date)) {\n                        throw new Error(`@smithy/core/protocols - received non-Date value ${value} when schema expected Date in ${ns.getName(true)}`);\n                    }\n                    const format = determineTimestampFormat(ns, this.settings);\n                    switch (format) {\n                        case SCHEMA.TIMESTAMP_DATE_TIME:\n                            this.stringBuffer = value.toISOString().replace(\".000Z\", \"Z\");\n                            break;\n                        case SCHEMA.TIMESTAMP_HTTP_DATE:\n                            this.stringBuffer = dateToUtcString(value);\n                            break;\n                        case SCHEMA.TIMESTAMP_EPOCH_SECONDS:\n                            this.stringBuffer = String(value.getTime() / 1000);\n                            break;\n                        default:\n                            console.warn(\"Missing timestamp format, using epoch seconds\", value);\n                            this.stringBuffer = String(value.getTime() / 1000);\n                    }\n                    return;\n                }\n                if (ns.isBlobSchema() && \"byteLength\" in value) {\n                    this.stringBuffer = (this.serdeContext?.base64Encoder ?? toBase64)(value);\n                    return;\n                }\n                if (ns.isListSchema() && Array.isArray(value)) {\n                    let buffer = \"\";\n                    for (const item of value) {\n                        this.write([ns.getValueSchema(), ns.getMergedTraits()], item);\n                        const headerItem = this.flush();\n                        const serialized = ns.getValueSchema().isTimestampSchema() ? headerItem : quoteHeader(headerItem);\n                        if (buffer !== \"\") {\n                            buffer += \", \";\n                        }\n                        buffer += serialized;\n                    }\n                    this.stringBuffer = buffer;\n                    return;\n                }\n                this.stringBuffer = JSON.stringify(value, null, 2);\n                break;\n            case \"string\":\n                const mediaType = ns.getMergedTraits().mediaType;\n                let intermediateValue = value;\n                if (mediaType) {\n                    const isJson = mediaType === \"application/json\" || mediaType.endsWith(\"+json\");\n                    if (isJson) {\n                        intermediateValue = LazyJsonString.from(intermediateValue);\n                    }\n                    if (ns.getMergedTraits().httpHeader) {\n                        this.stringBuffer = (this.serdeContext?.base64Encoder ?? toBase64)(intermediateValue.toString());\n                        return;\n                    }\n                }\n                this.stringBuffer = value;\n                break;\n            default:\n                this.stringBuffer = String(value);\n        }\n    }\n    flush() {\n        const buffer = this.stringBuffer;\n        this.stringBuffer = \"\";\n        return buffer;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"export class TypeRegistry {\n  constructor(namespace) {\n    let schemas = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Map();\n    this.namespace = namespace;\n    this.schemas = schemas;\n  }\n  static for(namespace) {\n    if (!TypeRegistry.registries.has(namespace)) {\n      TypeRegistry.registries.set(namespace, new TypeRegistry(namespace));\n    }\n    return TypeRegistry.registries.get(namespace);\n  }\n  register(shapeId, schema) {\n    const qualifiedName = this.normalizeShapeId(shapeId);\n    const registry = TypeRegistry.for(this.getNamespace(shapeId));\n    registry.schemas.set(qualifiedName, schema);\n  }\n  getSchema(shapeId) {\n    const id = this.normalizeShapeId(shapeId);\n    if (!this.schemas.has(id)) {\n      throw new Error(\"@smithy/core/schema - schema not found for \".concat(id));\n    }\n    return this.schemas.get(id);\n  }\n  getBaseException() {\n    for (const [id, schema] of this.schemas.entries()) {\n      if (id.startsWith(\"smithy.ts.sdk.synthetic.\") && id.endsWith(\"ServiceException\")) {\n        return schema;\n      }\n    }\n    return undefined;\n  }\n  find(predicate) {\n    return [...this.schemas.values()].find(predicate);\n  }\n  destroy() {\n    TypeRegistry.registries.delete(this.namespace);\n    this.schemas.clear();\n  }\n  normalizeShapeId(shapeId) {\n    if (shapeId.includes(\"#\")) {\n      return shapeId;\n    }\n    return this.namespace + \"#\" + shapeId;\n  }\n  getNamespace(shapeId) {\n    return this.normalizeShapeId(shapeId).split(\"#\")[0];\n  }\n}\nTypeRegistry.registries = new Map();","map":{"version":3,"names":["TypeRegistry","constructor","namespace","schemas","arguments","length","undefined","Map","for","registries","has","set","get","register","shapeId","schema","qualifiedName","normalizeShapeId","registry","getNamespace","getSchema","id","Error","concat","getBaseException","entries","startsWith","endsWith","find","predicate","values","destroy","delete","clear","includes","split"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/@smithy/core/dist-es/submodules/schema/TypeRegistry.js"],"sourcesContent":["export class TypeRegistry {\n    constructor(namespace, schemas = new Map()) {\n        this.namespace = namespace;\n        this.schemas = schemas;\n    }\n    static for(namespace) {\n        if (!TypeRegistry.registries.has(namespace)) {\n            TypeRegistry.registries.set(namespace, new TypeRegistry(namespace));\n        }\n        return TypeRegistry.registries.get(namespace);\n    }\n    register(shapeId, schema) {\n        const qualifiedName = this.normalizeShapeId(shapeId);\n        const registry = TypeRegistry.for(this.getNamespace(shapeId));\n        registry.schemas.set(qualifiedName, schema);\n    }\n    getSchema(shapeId) {\n        const id = this.normalizeShapeId(shapeId);\n        if (!this.schemas.has(id)) {\n            throw new Error(`@smithy/core/schema - schema not found for ${id}`);\n        }\n        return this.schemas.get(id);\n    }\n    getBaseException() {\n        for (const [id, schema] of this.schemas.entries()) {\n            if (id.startsWith(\"smithy.ts.sdk.synthetic.\") && id.endsWith(\"ServiceException\")) {\n                return schema;\n            }\n        }\n        return undefined;\n    }\n    find(predicate) {\n        return [...this.schemas.values()].find(predicate);\n    }\n    destroy() {\n        TypeRegistry.registries.delete(this.namespace);\n        this.schemas.clear();\n    }\n    normalizeShapeId(shapeId) {\n        if (shapeId.includes(\"#\")) {\n            return shapeId;\n        }\n        return this.namespace + \"#\" + shapeId;\n    }\n    getNamespace(shapeId) {\n        return this.normalizeShapeId(shapeId).split(\"#\")[0];\n    }\n}\nTypeRegistry.registries = new Map();\n"],"mappings":"AAAA,OAAO,MAAMA,YAAY,CAAC;EACtBC,WAAWA,CAACC,SAAS,EAAuB;IAAA,IAArBC,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAIG,GAAG,CAAC,CAAC;IACtC,IAAI,CAACL,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,OAAO,GAAGA,OAAO;EAC1B;EACA,OAAOK,GAAGA,CAACN,SAAS,EAAE;IAClB,IAAI,CAACF,YAAY,CAACS,UAAU,CAACC,GAAG,CAACR,SAAS,CAAC,EAAE;MACzCF,YAAY,CAACS,UAAU,CAACE,GAAG,CAACT,SAAS,EAAE,IAAIF,YAAY,CAACE,SAAS,CAAC,CAAC;IACvE;IACA,OAAOF,YAAY,CAACS,UAAU,CAACG,GAAG,CAACV,SAAS,CAAC;EACjD;EACAW,QAAQA,CAACC,OAAO,EAAEC,MAAM,EAAE;IACtB,MAAMC,aAAa,GAAG,IAAI,CAACC,gBAAgB,CAACH,OAAO,CAAC;IACpD,MAAMI,QAAQ,GAAGlB,YAAY,CAACQ,GAAG,CAAC,IAAI,CAACW,YAAY,CAACL,OAAO,CAAC,CAAC;IAC7DI,QAAQ,CAACf,OAAO,CAACQ,GAAG,CAACK,aAAa,EAAED,MAAM,CAAC;EAC/C;EACAK,SAASA,CAACN,OAAO,EAAE;IACf,MAAMO,EAAE,GAAG,IAAI,CAACJ,gBAAgB,CAACH,OAAO,CAAC;IACzC,IAAI,CAAC,IAAI,CAACX,OAAO,CAACO,GAAG,CAACW,EAAE,CAAC,EAAE;MACvB,MAAM,IAAIC,KAAK,+CAAAC,MAAA,CAA+CF,EAAE,CAAE,CAAC;IACvE;IACA,OAAO,IAAI,CAAClB,OAAO,CAACS,GAAG,CAACS,EAAE,CAAC;EAC/B;EACAG,gBAAgBA,CAAA,EAAG;IACf,KAAK,MAAM,CAACH,EAAE,EAAEN,MAAM,CAAC,IAAI,IAAI,CAACZ,OAAO,CAACsB,OAAO,CAAC,CAAC,EAAE;MAC/C,IAAIJ,EAAE,CAACK,UAAU,CAAC,0BAA0B,CAAC,IAAIL,EAAE,CAACM,QAAQ,CAAC,kBAAkB,CAAC,EAAE;QAC9E,OAAOZ,MAAM;MACjB;IACJ;IACA,OAAOT,SAAS;EACpB;EACAsB,IAAIA,CAACC,SAAS,EAAE;IACZ,OAAO,CAAC,GAAG,IAAI,CAAC1B,OAAO,CAAC2B,MAAM,CAAC,CAAC,CAAC,CAACF,IAAI,CAACC,SAAS,CAAC;EACrD;EACAE,OAAOA,CAAA,EAAG;IACN/B,YAAY,CAACS,UAAU,CAACuB,MAAM,CAAC,IAAI,CAAC9B,SAAS,CAAC;IAC9C,IAAI,CAACC,OAAO,CAAC8B,KAAK,CAAC,CAAC;EACxB;EACAhB,gBAAgBA,CAACH,OAAO,EAAE;IACtB,IAAIA,OAAO,CAACoB,QAAQ,CAAC,GAAG,CAAC,EAAE;MACvB,OAAOpB,OAAO;IAClB;IACA,OAAO,IAAI,CAACZ,SAAS,GAAG,GAAG,GAAGY,OAAO;EACzC;EACAK,YAAYA,CAACL,OAAO,EAAE;IAClB,OAAO,IAAI,CAACG,gBAAgB,CAACH,OAAO,CAAC,CAACqB,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EACvD;AACJ;AACAnC,YAAY,CAACS,UAAU,GAAG,IAAIF,GAAG,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
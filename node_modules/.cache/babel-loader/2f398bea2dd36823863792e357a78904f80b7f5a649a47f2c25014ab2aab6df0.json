{"ast":null,"code":"import _awaitAsyncGenerator from \"/Users/codinggents/Documents/lambdaforge/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"/Users/codinggents/Documents/lambdaforge/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nexport function getChunkedStream(source) {\n  let currentMessageTotalLength = 0;\n  let currentMessagePendingLength = 0;\n  let currentMessage = null;\n  let messageLengthBuffer = null;\n  const allocateMessage = size => {\n    if (typeof size !== \"number\") {\n      throw new Error(\"Attempted to allocate an event message where size was not a number: \" + size);\n    }\n    currentMessageTotalLength = size;\n    currentMessagePendingLength = 4;\n    currentMessage = new Uint8Array(size);\n    const currentMessageView = new DataView(currentMessage.buffer);\n    currentMessageView.setUint32(0, size, false);\n  };\n  const iterator = /*#__PURE__*/function () {\n    var _ref = _wrapAsyncGenerator(function* () {\n      const sourceIterator = source[Symbol.asyncIterator]();\n      while (true) {\n        const {\n          value,\n          done\n        } = yield _awaitAsyncGenerator(sourceIterator.next());\n        if (done) {\n          if (!currentMessageTotalLength) {\n            return;\n          } else if (currentMessageTotalLength === currentMessagePendingLength) {\n            yield currentMessage;\n          } else {\n            throw new Error(\"Truncated event message received.\");\n          }\n          return;\n        }\n        const chunkLength = value.length;\n        let currentOffset = 0;\n        while (currentOffset < chunkLength) {\n          if (!currentMessage) {\n            const bytesRemaining = chunkLength - currentOffset;\n            if (!messageLengthBuffer) {\n              messageLengthBuffer = new Uint8Array(4);\n            }\n            const numBytesForTotal = Math.min(4 - currentMessagePendingLength, bytesRemaining);\n            messageLengthBuffer.set(value.slice(currentOffset, currentOffset + numBytesForTotal), currentMessagePendingLength);\n            currentMessagePendingLength += numBytesForTotal;\n            currentOffset += numBytesForTotal;\n            if (currentMessagePendingLength < 4) {\n              break;\n            }\n            allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));\n            messageLengthBuffer = null;\n          }\n          const numBytesToWrite = Math.min(currentMessageTotalLength - currentMessagePendingLength, chunkLength - currentOffset);\n          currentMessage.set(value.slice(currentOffset, currentOffset + numBytesToWrite), currentMessagePendingLength);\n          currentMessagePendingLength += numBytesToWrite;\n          currentOffset += numBytesToWrite;\n          if (currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength) {\n            yield currentMessage;\n            currentMessage = null;\n            currentMessageTotalLength = 0;\n            currentMessagePendingLength = 0;\n          }\n        }\n      }\n    });\n    return function iterator() {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  return {\n    [Symbol.asyncIterator]: iterator\n  };\n}","map":{"version":3,"names":["getChunkedStream","source","currentMessageTotalLength","currentMessagePendingLength","currentMessage","messageLengthBuffer","allocateMessage","size","Error","Uint8Array","currentMessageView","DataView","buffer","setUint32","iterator","_ref","_wrapAsyncGenerator","sourceIterator","Symbol","asyncIterator","value","done","_awaitAsyncGenerator","next","chunkLength","length","currentOffset","bytesRemaining","numBytesForTotal","Math","min","set","slice","getUint32","numBytesToWrite","apply","arguments"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/@smithy/eventstream-serde-universal/dist-es/getChunkedStream.js"],"sourcesContent":["export function getChunkedStream(source) {\n    let currentMessageTotalLength = 0;\n    let currentMessagePendingLength = 0;\n    let currentMessage = null;\n    let messageLengthBuffer = null;\n    const allocateMessage = (size) => {\n        if (typeof size !== \"number\") {\n            throw new Error(\"Attempted to allocate an event message where size was not a number: \" + size);\n        }\n        currentMessageTotalLength = size;\n        currentMessagePendingLength = 4;\n        currentMessage = new Uint8Array(size);\n        const currentMessageView = new DataView(currentMessage.buffer);\n        currentMessageView.setUint32(0, size, false);\n    };\n    const iterator = async function* () {\n        const sourceIterator = source[Symbol.asyncIterator]();\n        while (true) {\n            const { value, done } = await sourceIterator.next();\n            if (done) {\n                if (!currentMessageTotalLength) {\n                    return;\n                }\n                else if (currentMessageTotalLength === currentMessagePendingLength) {\n                    yield currentMessage;\n                }\n                else {\n                    throw new Error(\"Truncated event message received.\");\n                }\n                return;\n            }\n            const chunkLength = value.length;\n            let currentOffset = 0;\n            while (currentOffset < chunkLength) {\n                if (!currentMessage) {\n                    const bytesRemaining = chunkLength - currentOffset;\n                    if (!messageLengthBuffer) {\n                        messageLengthBuffer = new Uint8Array(4);\n                    }\n                    const numBytesForTotal = Math.min(4 - currentMessagePendingLength, bytesRemaining);\n                    messageLengthBuffer.set(value.slice(currentOffset, currentOffset + numBytesForTotal), currentMessagePendingLength);\n                    currentMessagePendingLength += numBytesForTotal;\n                    currentOffset += numBytesForTotal;\n                    if (currentMessagePendingLength < 4) {\n                        break;\n                    }\n                    allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));\n                    messageLengthBuffer = null;\n                }\n                const numBytesToWrite = Math.min(currentMessageTotalLength - currentMessagePendingLength, chunkLength - currentOffset);\n                currentMessage.set(value.slice(currentOffset, currentOffset + numBytesToWrite), currentMessagePendingLength);\n                currentMessagePendingLength += numBytesToWrite;\n                currentOffset += numBytesToWrite;\n                if (currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength) {\n                    yield currentMessage;\n                    currentMessage = null;\n                    currentMessageTotalLength = 0;\n                    currentMessagePendingLength = 0;\n                }\n            }\n        }\n    };\n    return {\n        [Symbol.asyncIterator]: iterator,\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
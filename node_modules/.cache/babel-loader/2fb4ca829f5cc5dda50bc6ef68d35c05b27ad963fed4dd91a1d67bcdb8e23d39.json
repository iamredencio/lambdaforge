{"ast":null,"code":"export async function headStream(stream, bytes) {\n  let byteLengthCounter = 0;\n  const chunks = [];\n  const reader = stream.getReader();\n  let isDone = false;\n  while (!isDone) {\n    const {\n      done,\n      value\n    } = await reader.read();\n    if (value) {\n      var _value$byteLength;\n      chunks.push(value);\n      byteLengthCounter += (_value$byteLength = value === null || value === void 0 ? void 0 : value.byteLength) !== null && _value$byteLength !== void 0 ? _value$byteLength : 0;\n    }\n    if (byteLengthCounter >= bytes) {\n      break;\n    }\n    isDone = done;\n  }\n  reader.releaseLock();\n  const collected = new Uint8Array(Math.min(bytes, byteLengthCounter));\n  let offset = 0;\n  for (const chunk of chunks) {\n    if (chunk.byteLength > collected.byteLength - offset) {\n      collected.set(chunk.subarray(0, collected.byteLength - offset), offset);\n      break;\n    } else {\n      collected.set(chunk, offset);\n    }\n    offset += chunk.length;\n  }\n  return collected;\n}","map":{"version":3,"names":["headStream","stream","bytes","byteLengthCounter","chunks","reader","getReader","isDone","done","value","read","_value$byteLength","push","byteLength","releaseLock","collected","Uint8Array","Math","min","offset","chunk","set","subarray","length"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/@smithy/util-stream/dist-es/headStream.browser.js"],"sourcesContent":["export async function headStream(stream, bytes) {\n    let byteLengthCounter = 0;\n    const chunks = [];\n    const reader = stream.getReader();\n    let isDone = false;\n    while (!isDone) {\n        const { done, value } = await reader.read();\n        if (value) {\n            chunks.push(value);\n            byteLengthCounter += value?.byteLength ?? 0;\n        }\n        if (byteLengthCounter >= bytes) {\n            break;\n        }\n        isDone = done;\n    }\n    reader.releaseLock();\n    const collected = new Uint8Array(Math.min(bytes, byteLengthCounter));\n    let offset = 0;\n    for (const chunk of chunks) {\n        if (chunk.byteLength > collected.byteLength - offset) {\n            collected.set(chunk.subarray(0, collected.byteLength - offset), offset);\n            break;\n        }\n        else {\n            collected.set(chunk, offset);\n        }\n        offset += chunk.length;\n    }\n    return collected;\n}\n"],"mappings":"AAAA,OAAO,eAAeA,UAAUA,CAACC,MAAM,EAAEC,KAAK,EAAE;EAC5C,IAAIC,iBAAiB,GAAG,CAAC;EACzB,MAAMC,MAAM,GAAG,EAAE;EACjB,MAAMC,MAAM,GAAGJ,MAAM,CAACK,SAAS,CAAC,CAAC;EACjC,IAAIC,MAAM,GAAG,KAAK;EAClB,OAAO,CAACA,MAAM,EAAE;IACZ,MAAM;MAAEC,IAAI;MAAEC;IAAM,CAAC,GAAG,MAAMJ,MAAM,CAACK,IAAI,CAAC,CAAC;IAC3C,IAAID,KAAK,EAAE;MAAA,IAAAE,iBAAA;MACPP,MAAM,CAACQ,IAAI,CAACH,KAAK,CAAC;MAClBN,iBAAiB,KAAAQ,iBAAA,GAAIF,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEI,UAAU,cAAAF,iBAAA,cAAAA,iBAAA,GAAI,CAAC;IAC/C;IACA,IAAIR,iBAAiB,IAAID,KAAK,EAAE;MAC5B;IACJ;IACAK,MAAM,GAAGC,IAAI;EACjB;EACAH,MAAM,CAACS,WAAW,CAAC,CAAC;EACpB,MAAMC,SAAS,GAAG,IAAIC,UAAU,CAACC,IAAI,CAACC,GAAG,CAAChB,KAAK,EAAEC,iBAAiB,CAAC,CAAC;EACpE,IAAIgB,MAAM,GAAG,CAAC;EACd,KAAK,MAAMC,KAAK,IAAIhB,MAAM,EAAE;IACxB,IAAIgB,KAAK,CAACP,UAAU,GAAGE,SAAS,CAACF,UAAU,GAAGM,MAAM,EAAE;MAClDJ,SAAS,CAACM,GAAG,CAACD,KAAK,CAACE,QAAQ,CAAC,CAAC,EAAEP,SAAS,CAACF,UAAU,GAAGM,MAAM,CAAC,EAAEA,MAAM,CAAC;MACvE;IACJ,CAAC,MACI;MACDJ,SAAS,CAACM,GAAG,CAACD,KAAK,EAAED,MAAM,CAAC;IAChC;IACAA,MAAM,IAAIC,KAAK,CAACG,MAAM;EAC1B;EACA,OAAOR,SAAS;AACpB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
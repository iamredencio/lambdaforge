{"ast":null,"code":"import _objectSpread from \"/Users/codinggents/Documents/lambdaforge/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { NormalizedSchema, SCHEMA } from \"@smithy/core/schema\";\nimport { splitEvery, splitHeader } from \"@smithy/core/serde\";\nimport { HttpRequest, HttpResponse } from \"@smithy/protocol-http\";\nimport { sdkStreamMixin } from \"@smithy/util-stream\";\nimport { collectBody } from \"./collect-stream-body\";\nexport class HttpProtocol {\n  constructor(options) {\n    this.options = options;\n  }\n  getRequestType() {\n    return HttpRequest;\n  }\n  getResponseType() {\n    return HttpResponse;\n  }\n  setSerdeContext(serdeContext) {\n    this.serdeContext = serdeContext;\n    this.serializer.setSerdeContext(serdeContext);\n    this.deserializer.setSerdeContext(serdeContext);\n    if (this.getPayloadCodec()) {\n      this.getPayloadCodec().setSerdeContext(serdeContext);\n    }\n  }\n  updateServiceEndpoint(request, endpoint) {\n    if (\"url\" in endpoint) {\n      request.protocol = endpoint.url.protocol;\n      request.hostname = endpoint.url.hostname;\n      request.port = endpoint.url.port ? Number(endpoint.url.port) : undefined;\n      request.path = endpoint.url.pathname;\n      request.fragment = endpoint.url.hash || void 0;\n      request.username = endpoint.url.username || void 0;\n      request.password = endpoint.url.password || void 0;\n      for (const [k, v] of endpoint.url.searchParams.entries()) {\n        if (!request.query) {\n          request.query = {};\n        }\n        request.query[k] = v;\n      }\n      return request;\n    } else {\n      request.protocol = endpoint.protocol;\n      request.hostname = endpoint.hostname;\n      request.port = endpoint.port ? Number(endpoint.port) : undefined;\n      request.path = endpoint.path;\n      request.query = _objectSpread({}, endpoint.query);\n      return request;\n    }\n  }\n  setHostPrefix(request, operationSchema, input) {\n    const operationNs = NormalizedSchema.of(operationSchema);\n    const inputNs = NormalizedSchema.of(operationSchema.input);\n    if (operationNs.getMergedTraits().endpoint) {\n      var _operationNs$getMerge;\n      let hostPrefix = (_operationNs$getMerge = operationNs.getMergedTraits().endpoint) === null || _operationNs$getMerge === void 0 ? void 0 : _operationNs$getMerge[0];\n      if (typeof hostPrefix === \"string\") {\n        const hostLabelInputs = [...inputNs.structIterator()].filter(_ref => {\n          let [, member] = _ref;\n          return member.getMergedTraits().hostLabel;\n        });\n        for (const [name] of hostLabelInputs) {\n          const replacement = input[name];\n          if (typeof replacement !== \"string\") {\n            throw new Error(\"@smithy/core/schema - \".concat(name, \" in input must be a string as hostLabel.\"));\n          }\n          hostPrefix = hostPrefix.replace(\"{\".concat(name, \"}\"), replacement);\n        }\n        request.hostname = hostPrefix + request.hostname;\n      }\n    }\n  }\n  deserializeMetadata(output) {\n    var _ref2, _output$headers$xAmz;\n    return {\n      httpStatusCode: output.statusCode,\n      requestId: (_ref2 = (_output$headers$xAmz = output.headers[\"x-amzn-requestid\"]) !== null && _output$headers$xAmz !== void 0 ? _output$headers$xAmz : output.headers[\"x-amzn-request-id\"]) !== null && _ref2 !== void 0 ? _ref2 : output.headers[\"x-amz-request-id\"],\n      extendedRequestId: output.headers[\"x-amz-id-2\"],\n      cfId: output.headers[\"x-amz-cf-id\"]\n    };\n  }\n  async deserializeHttpMessage(schema, context, response, arg4, arg5) {\n    let dataObject;\n    if (arg4 instanceof Set) {\n      dataObject = arg5;\n    } else {\n      dataObject = arg4;\n    }\n    const deserializer = this.deserializer;\n    const ns = NormalizedSchema.of(schema);\n    const nonHttpBindingMembers = [];\n    for (const [memberName, memberSchema] of ns.structIterator()) {\n      const memberTraits = memberSchema.getMemberTraits();\n      if (memberTraits.httpPayload) {\n        const isStreaming = memberSchema.isStreaming();\n        if (isStreaming) {\n          const isEventStream = memberSchema.isStructSchema();\n          if (isEventStream) {\n            const context = this.serdeContext;\n            if (!context.eventStreamMarshaller) {\n              throw new Error(\"@smithy/core - HttpProtocol: eventStreamMarshaller missing in serdeContext.\");\n            }\n            const memberSchemas = memberSchema.getMemberSchemas();\n            dataObject[memberName] = context.eventStreamMarshaller.deserialize(response.body, async event => {\n              var _Object$keys$find;\n              const unionMember = (_Object$keys$find = Object.keys(event).find(key => {\n                return key !== \"__type\";\n              })) !== null && _Object$keys$find !== void 0 ? _Object$keys$find : \"\";\n              if (unionMember in memberSchemas) {\n                const eventStreamSchema = memberSchemas[unionMember];\n                return {\n                  [unionMember]: await deserializer.read(eventStreamSchema, event[unionMember].body)\n                };\n              } else {\n                return {\n                  $unknown: event\n                };\n              }\n            });\n          } else {\n            dataObject[memberName] = sdkStreamMixin(response.body);\n          }\n        } else if (response.body) {\n          const bytes = await collectBody(response.body, context);\n          if (bytes.byteLength > 0) {\n            dataObject[memberName] = await deserializer.read(memberSchema, bytes);\n          }\n        }\n      } else if (memberTraits.httpHeader) {\n        const key = String(memberTraits.httpHeader).toLowerCase();\n        const value = response.headers[key];\n        if (null != value) {\n          if (memberSchema.isListSchema()) {\n            const headerListValueSchema = memberSchema.getValueSchema();\n            let sections;\n            if (headerListValueSchema.isTimestampSchema() && headerListValueSchema.getSchema() === SCHEMA.TIMESTAMP_DEFAULT) {\n              sections = splitEvery(value, \",\", 2);\n            } else {\n              sections = splitHeader(value);\n            }\n            const list = [];\n            for (const section of sections) {\n              list.push(await deserializer.read([headerListValueSchema, {\n                httpHeader: key\n              }], section.trim()));\n            }\n            dataObject[memberName] = list;\n          } else {\n            dataObject[memberName] = await deserializer.read(memberSchema, value);\n          }\n        }\n      } else if (memberTraits.httpPrefixHeaders !== undefined) {\n        dataObject[memberName] = {};\n        for (const [header, value] of Object.entries(response.headers)) {\n          if (header.startsWith(memberTraits.httpPrefixHeaders)) {\n            dataObject[memberName][header.slice(memberTraits.httpPrefixHeaders.length)] = await deserializer.read([memberSchema.getValueSchema(), {\n              httpHeader: header\n            }], value);\n          }\n        }\n      } else if (memberTraits.httpResponseCode) {\n        dataObject[memberName] = response.statusCode;\n      } else {\n        nonHttpBindingMembers.push(memberName);\n      }\n    }\n    return nonHttpBindingMembers;\n  }\n}","map":{"version":3,"names":["NormalizedSchema","SCHEMA","splitEvery","splitHeader","HttpRequest","HttpResponse","sdkStreamMixin","collectBody","HttpProtocol","constructor","options","getRequestType","getResponseType","setSerdeContext","serdeContext","serializer","deserializer","getPayloadCodec","updateServiceEndpoint","request","endpoint","protocol","url","hostname","port","Number","undefined","path","pathname","fragment","hash","username","password","k","v","searchParams","entries","query","_objectSpread","setHostPrefix","operationSchema","input","operationNs","of","inputNs","getMergedTraits","_operationNs$getMerge","hostPrefix","hostLabelInputs","structIterator","filter","_ref","member","hostLabel","name","replacement","Error","concat","replace","deserializeMetadata","output","_ref2","_output$headers$xAmz","httpStatusCode","statusCode","requestId","headers","extendedRequestId","cfId","deserializeHttpMessage","schema","context","response","arg4","arg5","dataObject","Set","ns","nonHttpBindingMembers","memberName","memberSchema","memberTraits","getMemberTraits","httpPayload","isStreaming","isEventStream","isStructSchema","eventStreamMarshaller","memberSchemas","getMemberSchemas","deserialize","body","event","_Object$keys$find","unionMember","Object","keys","find","key","eventStreamSchema","read","$unknown","bytes","byteLength","httpHeader","String","toLowerCase","value","isListSchema","headerListValueSchema","getValueSchema","sections","isTimestampSchema","getSchema","TIMESTAMP_DEFAULT","list","section","push","trim","httpPrefixHeaders","header","startsWith","slice","length","httpResponseCode"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/@smithy/core/dist-es/submodules/protocols/HttpProtocol.js"],"sourcesContent":["import { NormalizedSchema, SCHEMA } from \"@smithy/core/schema\";\nimport { splitEvery, splitHeader } from \"@smithy/core/serde\";\nimport { HttpRequest, HttpResponse } from \"@smithy/protocol-http\";\nimport { sdkStreamMixin } from \"@smithy/util-stream\";\nimport { collectBody } from \"./collect-stream-body\";\nexport class HttpProtocol {\n    constructor(options) {\n        this.options = options;\n    }\n    getRequestType() {\n        return HttpRequest;\n    }\n    getResponseType() {\n        return HttpResponse;\n    }\n    setSerdeContext(serdeContext) {\n        this.serdeContext = serdeContext;\n        this.serializer.setSerdeContext(serdeContext);\n        this.deserializer.setSerdeContext(serdeContext);\n        if (this.getPayloadCodec()) {\n            this.getPayloadCodec().setSerdeContext(serdeContext);\n        }\n    }\n    updateServiceEndpoint(request, endpoint) {\n        if (\"url\" in endpoint) {\n            request.protocol = endpoint.url.protocol;\n            request.hostname = endpoint.url.hostname;\n            request.port = endpoint.url.port ? Number(endpoint.url.port) : undefined;\n            request.path = endpoint.url.pathname;\n            request.fragment = endpoint.url.hash || void 0;\n            request.username = endpoint.url.username || void 0;\n            request.password = endpoint.url.password || void 0;\n            for (const [k, v] of endpoint.url.searchParams.entries()) {\n                if (!request.query) {\n                    request.query = {};\n                }\n                request.query[k] = v;\n            }\n            return request;\n        }\n        else {\n            request.protocol = endpoint.protocol;\n            request.hostname = endpoint.hostname;\n            request.port = endpoint.port ? Number(endpoint.port) : undefined;\n            request.path = endpoint.path;\n            request.query = {\n                ...endpoint.query,\n            };\n            return request;\n        }\n    }\n    setHostPrefix(request, operationSchema, input) {\n        const operationNs = NormalizedSchema.of(operationSchema);\n        const inputNs = NormalizedSchema.of(operationSchema.input);\n        if (operationNs.getMergedTraits().endpoint) {\n            let hostPrefix = operationNs.getMergedTraits().endpoint?.[0];\n            if (typeof hostPrefix === \"string\") {\n                const hostLabelInputs = [...inputNs.structIterator()].filter(([, member]) => member.getMergedTraits().hostLabel);\n                for (const [name] of hostLabelInputs) {\n                    const replacement = input[name];\n                    if (typeof replacement !== \"string\") {\n                        throw new Error(`@smithy/core/schema - ${name} in input must be a string as hostLabel.`);\n                    }\n                    hostPrefix = hostPrefix.replace(`{${name}}`, replacement);\n                }\n                request.hostname = hostPrefix + request.hostname;\n            }\n        }\n    }\n    deserializeMetadata(output) {\n        return {\n            httpStatusCode: output.statusCode,\n            requestId: output.headers[\"x-amzn-requestid\"] ?? output.headers[\"x-amzn-request-id\"] ?? output.headers[\"x-amz-request-id\"],\n            extendedRequestId: output.headers[\"x-amz-id-2\"],\n            cfId: output.headers[\"x-amz-cf-id\"],\n        };\n    }\n    async deserializeHttpMessage(schema, context, response, arg4, arg5) {\n        let dataObject;\n        if (arg4 instanceof Set) {\n            dataObject = arg5;\n        }\n        else {\n            dataObject = arg4;\n        }\n        const deserializer = this.deserializer;\n        const ns = NormalizedSchema.of(schema);\n        const nonHttpBindingMembers = [];\n        for (const [memberName, memberSchema] of ns.structIterator()) {\n            const memberTraits = memberSchema.getMemberTraits();\n            if (memberTraits.httpPayload) {\n                const isStreaming = memberSchema.isStreaming();\n                if (isStreaming) {\n                    const isEventStream = memberSchema.isStructSchema();\n                    if (isEventStream) {\n                        const context = this.serdeContext;\n                        if (!context.eventStreamMarshaller) {\n                            throw new Error(\"@smithy/core - HttpProtocol: eventStreamMarshaller missing in serdeContext.\");\n                        }\n                        const memberSchemas = memberSchema.getMemberSchemas();\n                        dataObject[memberName] = context.eventStreamMarshaller.deserialize(response.body, async (event) => {\n                            const unionMember = Object.keys(event).find((key) => {\n                                return key !== \"__type\";\n                            }) ?? \"\";\n                            if (unionMember in memberSchemas) {\n                                const eventStreamSchema = memberSchemas[unionMember];\n                                return {\n                                    [unionMember]: await deserializer.read(eventStreamSchema, event[unionMember].body),\n                                };\n                            }\n                            else {\n                                return {\n                                    $unknown: event,\n                                };\n                            }\n                        });\n                    }\n                    else {\n                        dataObject[memberName] = sdkStreamMixin(response.body);\n                    }\n                }\n                else if (response.body) {\n                    const bytes = await collectBody(response.body, context);\n                    if (bytes.byteLength > 0) {\n                        dataObject[memberName] = await deserializer.read(memberSchema, bytes);\n                    }\n                }\n            }\n            else if (memberTraits.httpHeader) {\n                const key = String(memberTraits.httpHeader).toLowerCase();\n                const value = response.headers[key];\n                if (null != value) {\n                    if (memberSchema.isListSchema()) {\n                        const headerListValueSchema = memberSchema.getValueSchema();\n                        let sections;\n                        if (headerListValueSchema.isTimestampSchema() &&\n                            headerListValueSchema.getSchema() === SCHEMA.TIMESTAMP_DEFAULT) {\n                            sections = splitEvery(value, \",\", 2);\n                        }\n                        else {\n                            sections = splitHeader(value);\n                        }\n                        const list = [];\n                        for (const section of sections) {\n                            list.push(await deserializer.read([headerListValueSchema, { httpHeader: key }], section.trim()));\n                        }\n                        dataObject[memberName] = list;\n                    }\n                    else {\n                        dataObject[memberName] = await deserializer.read(memberSchema, value);\n                    }\n                }\n            }\n            else if (memberTraits.httpPrefixHeaders !== undefined) {\n                dataObject[memberName] = {};\n                for (const [header, value] of Object.entries(response.headers)) {\n                    if (header.startsWith(memberTraits.httpPrefixHeaders)) {\n                        dataObject[memberName][header.slice(memberTraits.httpPrefixHeaders.length)] = await deserializer.read([memberSchema.getValueSchema(), { httpHeader: header }], value);\n                    }\n                }\n            }\n            else if (memberTraits.httpResponseCode) {\n                dataObject[memberName] = response.statusCode;\n            }\n            else {\n                nonHttpBindingMembers.push(memberName);\n            }\n        }\n        return nonHttpBindingMembers;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { isThrottlingError } from \"@smithy/service-error-classification\";\nexport class DefaultRateLimiter {\n  constructor(options) {\n    var _options$beta, _options$minCapacity, _options$minFillRate, _options$scaleConstan, _options$smooth;\n    this.currentCapacity = 0;\n    this.enabled = false;\n    this.lastMaxRate = 0;\n    this.measuredTxRate = 0;\n    this.requestCount = 0;\n    this.lastTimestamp = 0;\n    this.timeWindow = 0;\n    this.beta = (_options$beta = options === null || options === void 0 ? void 0 : options.beta) !== null && _options$beta !== void 0 ? _options$beta : 0.7;\n    this.minCapacity = (_options$minCapacity = options === null || options === void 0 ? void 0 : options.minCapacity) !== null && _options$minCapacity !== void 0 ? _options$minCapacity : 1;\n    this.minFillRate = (_options$minFillRate = options === null || options === void 0 ? void 0 : options.minFillRate) !== null && _options$minFillRate !== void 0 ? _options$minFillRate : 0.5;\n    this.scaleConstant = (_options$scaleConstan = options === null || options === void 0 ? void 0 : options.scaleConstant) !== null && _options$scaleConstan !== void 0 ? _options$scaleConstan : 0.4;\n    this.smooth = (_options$smooth = options === null || options === void 0 ? void 0 : options.smooth) !== null && _options$smooth !== void 0 ? _options$smooth : 0.8;\n    const currentTimeInSeconds = this.getCurrentTimeInSeconds();\n    this.lastThrottleTime = currentTimeInSeconds;\n    this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());\n    this.fillRate = this.minFillRate;\n    this.maxCapacity = this.minCapacity;\n  }\n  getCurrentTimeInSeconds() {\n    return Date.now() / 1000;\n  }\n  async getSendToken() {\n    return this.acquireTokenBucket(1);\n  }\n  async acquireTokenBucket(amount) {\n    if (!this.enabled) {\n      return;\n    }\n    this.refillTokenBucket();\n    if (amount > this.currentCapacity) {\n      const delay = (amount - this.currentCapacity) / this.fillRate * 1000;\n      await new Promise(resolve => DefaultRateLimiter.setTimeoutFn(resolve, delay));\n    }\n    this.currentCapacity = this.currentCapacity - amount;\n  }\n  refillTokenBucket() {\n    const timestamp = this.getCurrentTimeInSeconds();\n    if (!this.lastTimestamp) {\n      this.lastTimestamp = timestamp;\n      return;\n    }\n    const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;\n    this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);\n    this.lastTimestamp = timestamp;\n  }\n  updateClientSendingRate(response) {\n    let calculatedRate;\n    this.updateMeasuredRate();\n    if (isThrottlingError(response)) {\n      const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);\n      this.lastMaxRate = rateToUse;\n      this.calculateTimeWindow();\n      this.lastThrottleTime = this.getCurrentTimeInSeconds();\n      calculatedRate = this.cubicThrottle(rateToUse);\n      this.enableTokenBucket();\n    } else {\n      this.calculateTimeWindow();\n      calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());\n    }\n    const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);\n    this.updateTokenBucketRate(newRate);\n  }\n  calculateTimeWindow() {\n    this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));\n  }\n  cubicThrottle(rateToUse) {\n    return this.getPrecise(rateToUse * this.beta);\n  }\n  cubicSuccess(timestamp) {\n    return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);\n  }\n  enableTokenBucket() {\n    this.enabled = true;\n  }\n  updateTokenBucketRate(newRate) {\n    this.refillTokenBucket();\n    this.fillRate = Math.max(newRate, this.minFillRate);\n    this.maxCapacity = Math.max(newRate, this.minCapacity);\n    this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);\n  }\n  updateMeasuredRate() {\n    const t = this.getCurrentTimeInSeconds();\n    const timeBucket = Math.floor(t * 2) / 2;\n    this.requestCount++;\n    if (timeBucket > this.lastTxRateBucket) {\n      const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);\n      this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));\n      this.requestCount = 0;\n      this.lastTxRateBucket = timeBucket;\n    }\n  }\n  getPrecise(num) {\n    return parseFloat(num.toFixed(8));\n  }\n}\nDefaultRateLimiter.setTimeoutFn = setTimeout;","map":{"version":3,"names":["isThrottlingError","DefaultRateLimiter","constructor","options","_options$beta","_options$minCapacity","_options$minFillRate","_options$scaleConstan","_options$smooth","currentCapacity","enabled","lastMaxRate","measuredTxRate","requestCount","lastTimestamp","timeWindow","beta","minCapacity","minFillRate","scaleConstant","smooth","currentTimeInSeconds","getCurrentTimeInSeconds","lastThrottleTime","lastTxRateBucket","Math","floor","fillRate","maxCapacity","Date","now","getSendToken","acquireTokenBucket","amount","refillTokenBucket","delay","Promise","resolve","setTimeoutFn","timestamp","fillAmount","min","updateClientSendingRate","response","calculatedRate","updateMeasuredRate","rateToUse","calculateTimeWindow","cubicThrottle","enableTokenBucket","cubicSuccess","newRate","updateTokenBucketRate","getPrecise","pow","max","t","timeBucket","currentRate","num","parseFloat","toFixed","setTimeout"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/@smithy/util-retry/dist-es/DefaultRateLimiter.js"],"sourcesContent":["import { isThrottlingError } from \"@smithy/service-error-classification\";\nexport class DefaultRateLimiter {\n    constructor(options) {\n        this.currentCapacity = 0;\n        this.enabled = false;\n        this.lastMaxRate = 0;\n        this.measuredTxRate = 0;\n        this.requestCount = 0;\n        this.lastTimestamp = 0;\n        this.timeWindow = 0;\n        this.beta = options?.beta ?? 0.7;\n        this.minCapacity = options?.minCapacity ?? 1;\n        this.minFillRate = options?.minFillRate ?? 0.5;\n        this.scaleConstant = options?.scaleConstant ?? 0.4;\n        this.smooth = options?.smooth ?? 0.8;\n        const currentTimeInSeconds = this.getCurrentTimeInSeconds();\n        this.lastThrottleTime = currentTimeInSeconds;\n        this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());\n        this.fillRate = this.minFillRate;\n        this.maxCapacity = this.minCapacity;\n    }\n    getCurrentTimeInSeconds() {\n        return Date.now() / 1000;\n    }\n    async getSendToken() {\n        return this.acquireTokenBucket(1);\n    }\n    async acquireTokenBucket(amount) {\n        if (!this.enabled) {\n            return;\n        }\n        this.refillTokenBucket();\n        if (amount > this.currentCapacity) {\n            const delay = ((amount - this.currentCapacity) / this.fillRate) * 1000;\n            await new Promise((resolve) => DefaultRateLimiter.setTimeoutFn(resolve, delay));\n        }\n        this.currentCapacity = this.currentCapacity - amount;\n    }\n    refillTokenBucket() {\n        const timestamp = this.getCurrentTimeInSeconds();\n        if (!this.lastTimestamp) {\n            this.lastTimestamp = timestamp;\n            return;\n        }\n        const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;\n        this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);\n        this.lastTimestamp = timestamp;\n    }\n    updateClientSendingRate(response) {\n        let calculatedRate;\n        this.updateMeasuredRate();\n        if (isThrottlingError(response)) {\n            const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);\n            this.lastMaxRate = rateToUse;\n            this.calculateTimeWindow();\n            this.lastThrottleTime = this.getCurrentTimeInSeconds();\n            calculatedRate = this.cubicThrottle(rateToUse);\n            this.enableTokenBucket();\n        }\n        else {\n            this.calculateTimeWindow();\n            calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());\n        }\n        const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);\n        this.updateTokenBucketRate(newRate);\n    }\n    calculateTimeWindow() {\n        this.timeWindow = this.getPrecise(Math.pow((this.lastMaxRate * (1 - this.beta)) / this.scaleConstant, 1 / 3));\n    }\n    cubicThrottle(rateToUse) {\n        return this.getPrecise(rateToUse * this.beta);\n    }\n    cubicSuccess(timestamp) {\n        return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);\n    }\n    enableTokenBucket() {\n        this.enabled = true;\n    }\n    updateTokenBucketRate(newRate) {\n        this.refillTokenBucket();\n        this.fillRate = Math.max(newRate, this.minFillRate);\n        this.maxCapacity = Math.max(newRate, this.minCapacity);\n        this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);\n    }\n    updateMeasuredRate() {\n        const t = this.getCurrentTimeInSeconds();\n        const timeBucket = Math.floor(t * 2) / 2;\n        this.requestCount++;\n        if (timeBucket > this.lastTxRateBucket) {\n            const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);\n            this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));\n            this.requestCount = 0;\n            this.lastTxRateBucket = timeBucket;\n        }\n    }\n    getPrecise(num) {\n        return parseFloat(num.toFixed(8));\n    }\n}\nDefaultRateLimiter.setTimeoutFn = setTimeout;\n"],"mappings":"AAAA,SAASA,iBAAiB,QAAQ,sCAAsC;AACxE,OAAO,MAAMC,kBAAkB,CAAC;EAC5BC,WAAWA,CAACC,OAAO,EAAE;IAAA,IAAAC,aAAA,EAAAC,oBAAA,EAAAC,oBAAA,EAAAC,qBAAA,EAAAC,eAAA;IACjB,IAAI,CAACC,eAAe,GAAG,CAAC;IACxB,IAAI,CAACC,OAAO,GAAG,KAAK;IACpB,IAAI,CAACC,WAAW,GAAG,CAAC;IACpB,IAAI,CAACC,cAAc,GAAG,CAAC;IACvB,IAAI,CAACC,YAAY,GAAG,CAAC;IACrB,IAAI,CAACC,aAAa,GAAG,CAAC;IACtB,IAAI,CAACC,UAAU,GAAG,CAAC;IACnB,IAAI,CAACC,IAAI,IAAAZ,aAAA,GAAGD,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEa,IAAI,cAAAZ,aAAA,cAAAA,aAAA,GAAI,GAAG;IAChC,IAAI,CAACa,WAAW,IAAAZ,oBAAA,GAAGF,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEc,WAAW,cAAAZ,oBAAA,cAAAA,oBAAA,GAAI,CAAC;IAC5C,IAAI,CAACa,WAAW,IAAAZ,oBAAA,GAAGH,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEe,WAAW,cAAAZ,oBAAA,cAAAA,oBAAA,GAAI,GAAG;IAC9C,IAAI,CAACa,aAAa,IAAAZ,qBAAA,GAAGJ,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEgB,aAAa,cAAAZ,qBAAA,cAAAA,qBAAA,GAAI,GAAG;IAClD,IAAI,CAACa,MAAM,IAAAZ,eAAA,GAAGL,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEiB,MAAM,cAAAZ,eAAA,cAAAA,eAAA,GAAI,GAAG;IACpC,MAAMa,oBAAoB,GAAG,IAAI,CAACC,uBAAuB,CAAC,CAAC;IAC3D,IAAI,CAACC,gBAAgB,GAAGF,oBAAoB;IAC5C,IAAI,CAACG,gBAAgB,GAAGC,IAAI,CAACC,KAAK,CAAC,IAAI,CAACJ,uBAAuB,CAAC,CAAC,CAAC;IAClE,IAAI,CAACK,QAAQ,GAAG,IAAI,CAACT,WAAW;IAChC,IAAI,CAACU,WAAW,GAAG,IAAI,CAACX,WAAW;EACvC;EACAK,uBAAuBA,CAAA,EAAG;IACtB,OAAOO,IAAI,CAACC,GAAG,CAAC,CAAC,GAAG,IAAI;EAC5B;EACA,MAAMC,YAAYA,CAAA,EAAG;IACjB,OAAO,IAAI,CAACC,kBAAkB,CAAC,CAAC,CAAC;EACrC;EACA,MAAMA,kBAAkBA,CAACC,MAAM,EAAE;IAC7B,IAAI,CAAC,IAAI,CAACvB,OAAO,EAAE;MACf;IACJ;IACA,IAAI,CAACwB,iBAAiB,CAAC,CAAC;IACxB,IAAID,MAAM,GAAG,IAAI,CAACxB,eAAe,EAAE;MAC/B,MAAM0B,KAAK,GAAI,CAACF,MAAM,GAAG,IAAI,CAACxB,eAAe,IAAI,IAAI,CAACkB,QAAQ,GAAI,IAAI;MACtE,MAAM,IAAIS,OAAO,CAAEC,OAAO,IAAKpC,kBAAkB,CAACqC,YAAY,CAACD,OAAO,EAAEF,KAAK,CAAC,CAAC;IACnF;IACA,IAAI,CAAC1B,eAAe,GAAG,IAAI,CAACA,eAAe,GAAGwB,MAAM;EACxD;EACAC,iBAAiBA,CAAA,EAAG;IAChB,MAAMK,SAAS,GAAG,IAAI,CAACjB,uBAAuB,CAAC,CAAC;IAChD,IAAI,CAAC,IAAI,CAACR,aAAa,EAAE;MACrB,IAAI,CAACA,aAAa,GAAGyB,SAAS;MAC9B;IACJ;IACA,MAAMC,UAAU,GAAG,CAACD,SAAS,GAAG,IAAI,CAACzB,aAAa,IAAI,IAAI,CAACa,QAAQ;IACnE,IAAI,CAAClB,eAAe,GAAGgB,IAAI,CAACgB,GAAG,CAAC,IAAI,CAACb,WAAW,EAAE,IAAI,CAACnB,eAAe,GAAG+B,UAAU,CAAC;IACpF,IAAI,CAAC1B,aAAa,GAAGyB,SAAS;EAClC;EACAG,uBAAuBA,CAACC,QAAQ,EAAE;IAC9B,IAAIC,cAAc;IAClB,IAAI,CAACC,kBAAkB,CAAC,CAAC;IACzB,IAAI7C,iBAAiB,CAAC2C,QAAQ,CAAC,EAAE;MAC7B,MAAMG,SAAS,GAAG,CAAC,IAAI,CAACpC,OAAO,GAAG,IAAI,CAACE,cAAc,GAAGa,IAAI,CAACgB,GAAG,CAAC,IAAI,CAAC7B,cAAc,EAAE,IAAI,CAACe,QAAQ,CAAC;MACpG,IAAI,CAAChB,WAAW,GAAGmC,SAAS;MAC5B,IAAI,CAACC,mBAAmB,CAAC,CAAC;MAC1B,IAAI,CAACxB,gBAAgB,GAAG,IAAI,CAACD,uBAAuB,CAAC,CAAC;MACtDsB,cAAc,GAAG,IAAI,CAACI,aAAa,CAACF,SAAS,CAAC;MAC9C,IAAI,CAACG,iBAAiB,CAAC,CAAC;IAC5B,CAAC,MACI;MACD,IAAI,CAACF,mBAAmB,CAAC,CAAC;MAC1BH,cAAc,GAAG,IAAI,CAACM,YAAY,CAAC,IAAI,CAAC5B,uBAAuB,CAAC,CAAC,CAAC;IACtE;IACA,MAAM6B,OAAO,GAAG1B,IAAI,CAACgB,GAAG,CAACG,cAAc,EAAE,CAAC,GAAG,IAAI,CAAChC,cAAc,CAAC;IACjE,IAAI,CAACwC,qBAAqB,CAACD,OAAO,CAAC;EACvC;EACAJ,mBAAmBA,CAAA,EAAG;IAClB,IAAI,CAAChC,UAAU,GAAG,IAAI,CAACsC,UAAU,CAAC5B,IAAI,CAAC6B,GAAG,CAAE,IAAI,CAAC3C,WAAW,IAAI,CAAC,GAAG,IAAI,CAACK,IAAI,CAAC,GAAI,IAAI,CAACG,aAAa,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;EACjH;EACA6B,aAAaA,CAACF,SAAS,EAAE;IACrB,OAAO,IAAI,CAACO,UAAU,CAACP,SAAS,GAAG,IAAI,CAAC9B,IAAI,CAAC;EACjD;EACAkC,YAAYA,CAACX,SAAS,EAAE;IACpB,OAAO,IAAI,CAACc,UAAU,CAAC,IAAI,CAAClC,aAAa,GAAGM,IAAI,CAAC6B,GAAG,CAACf,SAAS,GAAG,IAAI,CAAChB,gBAAgB,GAAG,IAAI,CAACR,UAAU,EAAE,CAAC,CAAC,GAAG,IAAI,CAACJ,WAAW,CAAC;EACpI;EACAsC,iBAAiBA,CAAA,EAAG;IAChB,IAAI,CAACvC,OAAO,GAAG,IAAI;EACvB;EACA0C,qBAAqBA,CAACD,OAAO,EAAE;IAC3B,IAAI,CAACjB,iBAAiB,CAAC,CAAC;IACxB,IAAI,CAACP,QAAQ,GAAGF,IAAI,CAAC8B,GAAG,CAACJ,OAAO,EAAE,IAAI,CAACjC,WAAW,CAAC;IACnD,IAAI,CAACU,WAAW,GAAGH,IAAI,CAAC8B,GAAG,CAACJ,OAAO,EAAE,IAAI,CAAClC,WAAW,CAAC;IACtD,IAAI,CAACR,eAAe,GAAGgB,IAAI,CAACgB,GAAG,CAAC,IAAI,CAAChC,eAAe,EAAE,IAAI,CAACmB,WAAW,CAAC;EAC3E;EACAiB,kBAAkBA,CAAA,EAAG;IACjB,MAAMW,CAAC,GAAG,IAAI,CAAClC,uBAAuB,CAAC,CAAC;IACxC,MAAMmC,UAAU,GAAGhC,IAAI,CAACC,KAAK,CAAC8B,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;IACxC,IAAI,CAAC3C,YAAY,EAAE;IACnB,IAAI4C,UAAU,GAAG,IAAI,CAACjC,gBAAgB,EAAE;MACpC,MAAMkC,WAAW,GAAG,IAAI,CAAC7C,YAAY,IAAI4C,UAAU,GAAG,IAAI,CAACjC,gBAAgB,CAAC;MAC5E,IAAI,CAACZ,cAAc,GAAG,IAAI,CAACyC,UAAU,CAACK,WAAW,GAAG,IAAI,CAACtC,MAAM,GAAG,IAAI,CAACR,cAAc,IAAI,CAAC,GAAG,IAAI,CAACQ,MAAM,CAAC,CAAC;MAC1G,IAAI,CAACP,YAAY,GAAG,CAAC;MACrB,IAAI,CAACW,gBAAgB,GAAGiC,UAAU;IACtC;EACJ;EACAJ,UAAUA,CAACM,GAAG,EAAE;IACZ,OAAOC,UAAU,CAACD,GAAG,CAACE,OAAO,CAAC,CAAC,CAAC,CAAC;EACrC;AACJ;AACA5D,kBAAkB,CAACqC,YAAY,GAAGwB,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
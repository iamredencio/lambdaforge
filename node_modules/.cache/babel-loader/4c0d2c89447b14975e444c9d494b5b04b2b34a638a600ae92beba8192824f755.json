{"ast":null,"code":"import { toHex } from \"@smithy/util-hex-encoding\";\nimport { toUint8Array } from \"@smithy/util-utf8\";\nimport { ALGORITHM_IDENTIFIER, ALGORITHM_QUERY_PARAM, AMZ_DATE_HEADER, AMZ_DATE_QUERY_PARAM, AUTH_HEADER, CREDENTIAL_QUERY_PARAM, EVENT_ALGORITHM_IDENTIFIER, EXPIRES_QUERY_PARAM, MAX_PRESIGNED_TTL, SHA256_HEADER, SIGNATURE_QUERY_PARAM, SIGNED_HEADERS_QUERY_PARAM, TOKEN_HEADER, TOKEN_QUERY_PARAM } from \"./constants\";\nimport { createScope, getSigningKey } from \"./credentialDerivation\";\nimport { getCanonicalHeaders } from \"./getCanonicalHeaders\";\nimport { getPayloadHash } from \"./getPayloadHash\";\nimport { HeaderFormatter } from \"./HeaderFormatter\";\nimport { hasHeader } from \"./headerUtil\";\nimport { moveHeadersToQuery } from \"./moveHeadersToQuery\";\nimport { prepareRequest } from \"./prepareRequest\";\nimport { SignatureV4Base } from \"./SignatureV4Base\";\nexport class SignatureV4 extends SignatureV4Base {\n  constructor(_ref) {\n    let {\n      applyChecksum,\n      credentials,\n      region,\n      service,\n      sha256,\n      uriEscapePath = true\n    } = _ref;\n    super({\n      applyChecksum,\n      credentials,\n      region,\n      service,\n      sha256,\n      uriEscapePath\n    });\n    this.headerFormatter = new HeaderFormatter();\n  }\n  async presign(originalRequest) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      signingDate = new Date(),\n      expiresIn = 3600,\n      unsignableHeaders,\n      unhoistableHeaders,\n      signableHeaders,\n      hoistableHeaders,\n      signingRegion,\n      signingService\n    } = options;\n    const credentials = await this.credentialProvider();\n    this.validateResolvedCredentials(credentials);\n    const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : await this.regionProvider();\n    const {\n      longDate,\n      shortDate\n    } = this.formatDate(signingDate);\n    if (expiresIn > MAX_PRESIGNED_TTL) {\n      return Promise.reject(\"Signature version 4 presigned URLs\" + \" must have an expiration date less than one week in\" + \" the future\");\n    }\n    const scope = createScope(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);\n    const request = moveHeadersToQuery(prepareRequest(originalRequest), {\n      unhoistableHeaders,\n      hoistableHeaders\n    });\n    if (credentials.sessionToken) {\n      request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;\n    }\n    request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;\n    request.query[CREDENTIAL_QUERY_PARAM] = \"\".concat(credentials.accessKeyId, \"/\").concat(scope);\n    request.query[AMZ_DATE_QUERY_PARAM] = longDate;\n    request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);\n    const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n    request.query[SIGNED_HEADERS_QUERY_PARAM] = this.getCanonicalHeaderList(canonicalHeaders);\n    request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));\n    return request;\n  }\n  async sign(toSign, options) {\n    if (typeof toSign === \"string\") {\n      return this.signString(toSign, options);\n    } else if (toSign.headers && toSign.payload) {\n      return this.signEvent(toSign, options);\n    } else if (toSign.message) {\n      return this.signMessage(toSign, options);\n    } else {\n      return this.signRequest(toSign, options);\n    }\n  }\n  async signEvent(_ref2, _ref3) {\n    let {\n      headers,\n      payload\n    } = _ref2;\n    let {\n      signingDate = new Date(),\n      priorSignature,\n      signingRegion,\n      signingService\n    } = _ref3;\n    const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : await this.regionProvider();\n    const {\n      shortDate,\n      longDate\n    } = this.formatDate(signingDate);\n    const scope = createScope(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);\n    const hashedPayload = await getPayloadHash({\n      headers: {},\n      body: payload\n    }, this.sha256);\n    const hash = new this.sha256();\n    hash.update(headers);\n    const hashedHeaders = toHex(await hash.digest());\n    const stringToSign = [EVENT_ALGORITHM_IDENTIFIER, longDate, scope, priorSignature, hashedHeaders, hashedPayload].join(\"\\n\");\n    return this.signString(stringToSign, {\n      signingDate,\n      signingRegion: region,\n      signingService\n    });\n  }\n  async signMessage(signableMessage, _ref4) {\n    let {\n      signingDate = new Date(),\n      signingRegion,\n      signingService\n    } = _ref4;\n    const promise = this.signEvent({\n      headers: this.headerFormatter.format(signableMessage.message.headers),\n      payload: signableMessage.message.body\n    }, {\n      signingDate,\n      signingRegion,\n      signingService,\n      priorSignature: signableMessage.priorSignature\n    });\n    return promise.then(signature => {\n      return {\n        message: signableMessage.message,\n        signature\n      };\n    });\n  }\n  async signString(stringToSign) {\n    let {\n      signingDate = new Date(),\n      signingRegion,\n      signingService\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const credentials = await this.credentialProvider();\n    this.validateResolvedCredentials(credentials);\n    const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : await this.regionProvider();\n    const {\n      shortDate\n    } = this.formatDate(signingDate);\n    const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));\n    hash.update(toUint8Array(stringToSign));\n    return toHex(await hash.digest());\n  }\n  async signRequest(requestToSign) {\n    let {\n      signingDate = new Date(),\n      signableHeaders,\n      unsignableHeaders,\n      signingRegion,\n      signingService\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const credentials = await this.credentialProvider();\n    this.validateResolvedCredentials(credentials);\n    const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : await this.regionProvider();\n    const request = prepareRequest(requestToSign);\n    const {\n      longDate,\n      shortDate\n    } = this.formatDate(signingDate);\n    const scope = createScope(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);\n    request.headers[AMZ_DATE_HEADER] = longDate;\n    if (credentials.sessionToken) {\n      request.headers[TOKEN_HEADER] = credentials.sessionToken;\n    }\n    const payloadHash = await getPayloadHash(request, this.sha256);\n    if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {\n      request.headers[SHA256_HEADER] = payloadHash;\n    }\n    const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n    const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));\n    request.headers[AUTH_HEADER] = \"\".concat(ALGORITHM_IDENTIFIER, \" \") + \"Credential=\".concat(credentials.accessKeyId, \"/\").concat(scope, \", \") + \"SignedHeaders=\".concat(this.getCanonicalHeaderList(canonicalHeaders), \", \") + \"Signature=\".concat(signature);\n    return request;\n  }\n  async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {\n    const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest, ALGORITHM_IDENTIFIER);\n    const hash = new this.sha256(await keyPromise);\n    hash.update(toUint8Array(stringToSign));\n    return toHex(await hash.digest());\n  }\n  getSigningKey(credentials, region, shortDate, service) {\n    return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);\n  }\n}","map":{"version":3,"names":["toHex","toUint8Array","ALGORITHM_IDENTIFIER","ALGORITHM_QUERY_PARAM","AMZ_DATE_HEADER","AMZ_DATE_QUERY_PARAM","AUTH_HEADER","CREDENTIAL_QUERY_PARAM","EVENT_ALGORITHM_IDENTIFIER","EXPIRES_QUERY_PARAM","MAX_PRESIGNED_TTL","SHA256_HEADER","SIGNATURE_QUERY_PARAM","SIGNED_HEADERS_QUERY_PARAM","TOKEN_HEADER","TOKEN_QUERY_PARAM","createScope","getSigningKey","getCanonicalHeaders","getPayloadHash","HeaderFormatter","hasHeader","moveHeadersToQuery","prepareRequest","SignatureV4Base","SignatureV4","constructor","_ref","applyChecksum","credentials","region","service","sha256","uriEscapePath","headerFormatter","presign","originalRequest","options","arguments","length","undefined","signingDate","Date","expiresIn","unsignableHeaders","unhoistableHeaders","signableHeaders","hoistableHeaders","signingRegion","signingService","credentialProvider","validateResolvedCredentials","regionProvider","longDate","shortDate","formatDate","Promise","reject","scope","request","sessionToken","query","concat","accessKeyId","toString","canonicalHeaders","getCanonicalHeaderList","getSignature","createCanonicalRequest","sign","toSign","signString","headers","payload","signEvent","message","signMessage","signRequest","_ref2","_ref3","priorSignature","hashedPayload","body","hash","update","hashedHeaders","digest","stringToSign","join","signableMessage","_ref4","promise","format","then","signature","requestToSign","payloadHash","credentialScope","keyPromise","canonicalRequest","createStringToSign"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/@smithy/signature-v4/dist-es/SignatureV4.js"],"sourcesContent":["import { toHex } from \"@smithy/util-hex-encoding\";\nimport { toUint8Array } from \"@smithy/util-utf8\";\nimport { ALGORITHM_IDENTIFIER, ALGORITHM_QUERY_PARAM, AMZ_DATE_HEADER, AMZ_DATE_QUERY_PARAM, AUTH_HEADER, CREDENTIAL_QUERY_PARAM, EVENT_ALGORITHM_IDENTIFIER, EXPIRES_QUERY_PARAM, MAX_PRESIGNED_TTL, SHA256_HEADER, SIGNATURE_QUERY_PARAM, SIGNED_HEADERS_QUERY_PARAM, TOKEN_HEADER, TOKEN_QUERY_PARAM, } from \"./constants\";\nimport { createScope, getSigningKey } from \"./credentialDerivation\";\nimport { getCanonicalHeaders } from \"./getCanonicalHeaders\";\nimport { getPayloadHash } from \"./getPayloadHash\";\nimport { HeaderFormatter } from \"./HeaderFormatter\";\nimport { hasHeader } from \"./headerUtil\";\nimport { moveHeadersToQuery } from \"./moveHeadersToQuery\";\nimport { prepareRequest } from \"./prepareRequest\";\nimport { SignatureV4Base } from \"./SignatureV4Base\";\nexport class SignatureV4 extends SignatureV4Base {\n    constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true, }) {\n        super({\n            applyChecksum,\n            credentials,\n            region,\n            service,\n            sha256,\n            uriEscapePath,\n        });\n        this.headerFormatter = new HeaderFormatter();\n    }\n    async presign(originalRequest, options = {}) {\n        const { signingDate = new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, hoistableHeaders, signingRegion, signingService, } = options;\n        const credentials = await this.credentialProvider();\n        this.validateResolvedCredentials(credentials);\n        const region = signingRegion ?? (await this.regionProvider());\n        const { longDate, shortDate } = this.formatDate(signingDate);\n        if (expiresIn > MAX_PRESIGNED_TTL) {\n            return Promise.reject(\"Signature version 4 presigned URLs\" + \" must have an expiration date less than one week in\" + \" the future\");\n        }\n        const scope = createScope(shortDate, region, signingService ?? this.service);\n        const request = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders, hoistableHeaders });\n        if (credentials.sessionToken) {\n            request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;\n        }\n        request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;\n        request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;\n        request.query[AMZ_DATE_QUERY_PARAM] = longDate;\n        request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);\n        const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n        request.query[SIGNED_HEADERS_QUERY_PARAM] = this.getCanonicalHeaderList(canonicalHeaders);\n        request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));\n        return request;\n    }\n    async sign(toSign, options) {\n        if (typeof toSign === \"string\") {\n            return this.signString(toSign, options);\n        }\n        else if (toSign.headers && toSign.payload) {\n            return this.signEvent(toSign, options);\n        }\n        else if (toSign.message) {\n            return this.signMessage(toSign, options);\n        }\n        else {\n            return this.signRequest(toSign, options);\n        }\n    }\n    async signEvent({ headers, payload }, { signingDate = new Date(), priorSignature, signingRegion, signingService }) {\n        const region = signingRegion ?? (await this.regionProvider());\n        const { shortDate, longDate } = this.formatDate(signingDate);\n        const scope = createScope(shortDate, region, signingService ?? this.service);\n        const hashedPayload = await getPayloadHash({ headers: {}, body: payload }, this.sha256);\n        const hash = new this.sha256();\n        hash.update(headers);\n        const hashedHeaders = toHex(await hash.digest());\n        const stringToSign = [\n            EVENT_ALGORITHM_IDENTIFIER,\n            longDate,\n            scope,\n            priorSignature,\n            hashedHeaders,\n            hashedPayload,\n        ].join(\"\\n\");\n        return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });\n    }\n    async signMessage(signableMessage, { signingDate = new Date(), signingRegion, signingService }) {\n        const promise = this.signEvent({\n            headers: this.headerFormatter.format(signableMessage.message.headers),\n            payload: signableMessage.message.body,\n        }, {\n            signingDate,\n            signingRegion,\n            signingService,\n            priorSignature: signableMessage.priorSignature,\n        });\n        return promise.then((signature) => {\n            return { message: signableMessage.message, signature };\n        });\n    }\n    async signString(stringToSign, { signingDate = new Date(), signingRegion, signingService } = {}) {\n        const credentials = await this.credentialProvider();\n        this.validateResolvedCredentials(credentials);\n        const region = signingRegion ?? (await this.regionProvider());\n        const { shortDate } = this.formatDate(signingDate);\n        const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));\n        hash.update(toUint8Array(stringToSign));\n        return toHex(await hash.digest());\n    }\n    async signRequest(requestToSign, { signingDate = new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService, } = {}) {\n        const credentials = await this.credentialProvider();\n        this.validateResolvedCredentials(credentials);\n        const region = signingRegion ?? (await this.regionProvider());\n        const request = prepareRequest(requestToSign);\n        const { longDate, shortDate } = this.formatDate(signingDate);\n        const scope = createScope(shortDate, region, signingService ?? this.service);\n        request.headers[AMZ_DATE_HEADER] = longDate;\n        if (credentials.sessionToken) {\n            request.headers[TOKEN_HEADER] = credentials.sessionToken;\n        }\n        const payloadHash = await getPayloadHash(request, this.sha256);\n        if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {\n            request.headers[SHA256_HEADER] = payloadHash;\n        }\n        const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n        const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));\n        request.headers[AUTH_HEADER] =\n            `${ALGORITHM_IDENTIFIER} ` +\n                `Credential=${credentials.accessKeyId}/${scope}, ` +\n                `SignedHeaders=${this.getCanonicalHeaderList(canonicalHeaders)}, ` +\n                `Signature=${signature}`;\n        return request;\n    }\n    async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {\n        const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest, ALGORITHM_IDENTIFIER);\n        const hash = new this.sha256(await keyPromise);\n        hash.update(toUint8Array(stringToSign));\n        return toHex(await hash.digest());\n    }\n    getSigningKey(credentials, region, shortDate, service) {\n        return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { escapeUri } from \"@smithy/util-uri-escape\";\nimport { SIGNATURE_HEADER } from \"./constants\";\nexport const getCanonicalQuery = _ref => {\n  let {\n    query = {}\n  } = _ref;\n  const keys = [];\n  const serialized = {};\n  for (const key of Object.keys(query)) {\n    if (key.toLowerCase() === SIGNATURE_HEADER) {\n      continue;\n    }\n    const encodedKey = escapeUri(key);\n    keys.push(encodedKey);\n    const value = query[key];\n    if (typeof value === \"string\") {\n      serialized[encodedKey] = \"\".concat(encodedKey, \"=\").concat(escapeUri(value));\n    } else if (Array.isArray(value)) {\n      serialized[encodedKey] = value.slice(0).reduce((encoded, value) => encoded.concat([\"\".concat(encodedKey, \"=\").concat(escapeUri(value))]), []).sort().join(\"&\");\n    }\n  }\n  return keys.sort().map(key => serialized[key]).filter(serialized => serialized).join(\"&\");\n};","map":{"version":3,"names":["escapeUri","SIGNATURE_HEADER","getCanonicalQuery","_ref","query","keys","serialized","key","Object","toLowerCase","encodedKey","push","value","concat","Array","isArray","slice","reduce","encoded","sort","join","map","filter"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/@smithy/signature-v4/dist-es/getCanonicalQuery.js"],"sourcesContent":["import { escapeUri } from \"@smithy/util-uri-escape\";\nimport { SIGNATURE_HEADER } from \"./constants\";\nexport const getCanonicalQuery = ({ query = {} }) => {\n    const keys = [];\n    const serialized = {};\n    for (const key of Object.keys(query)) {\n        if (key.toLowerCase() === SIGNATURE_HEADER) {\n            continue;\n        }\n        const encodedKey = escapeUri(key);\n        keys.push(encodedKey);\n        const value = query[key];\n        if (typeof value === \"string\") {\n            serialized[encodedKey] = `${encodedKey}=${escapeUri(value)}`;\n        }\n        else if (Array.isArray(value)) {\n            serialized[encodedKey] = value\n                .slice(0)\n                .reduce((encoded, value) => encoded.concat([`${encodedKey}=${escapeUri(value)}`]), [])\n                .sort()\n                .join(\"&\");\n        }\n    }\n    return keys\n        .sort()\n        .map((key) => serialized[key])\n        .filter((serialized) => serialized)\n        .join(\"&\");\n};\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,yBAAyB;AACnD,SAASC,gBAAgB,QAAQ,aAAa;AAC9C,OAAO,MAAMC,iBAAiB,GAAGC,IAAA,IAAoB;EAAA,IAAnB;IAAEC,KAAK,GAAG,CAAC;EAAE,CAAC,GAAAD,IAAA;EAC5C,MAAME,IAAI,GAAG,EAAE;EACf,MAAMC,UAAU,GAAG,CAAC,CAAC;EACrB,KAAK,MAAMC,GAAG,IAAIC,MAAM,CAACH,IAAI,CAACD,KAAK,CAAC,EAAE;IAClC,IAAIG,GAAG,CAACE,WAAW,CAAC,CAAC,KAAKR,gBAAgB,EAAE;MACxC;IACJ;IACA,MAAMS,UAAU,GAAGV,SAAS,CAACO,GAAG,CAAC;IACjCF,IAAI,CAACM,IAAI,CAACD,UAAU,CAAC;IACrB,MAAME,KAAK,GAAGR,KAAK,CAACG,GAAG,CAAC;IACxB,IAAI,OAAOK,KAAK,KAAK,QAAQ,EAAE;MAC3BN,UAAU,CAACI,UAAU,CAAC,MAAAG,MAAA,CAAMH,UAAU,OAAAG,MAAA,CAAIb,SAAS,CAACY,KAAK,CAAC,CAAE;IAChE,CAAC,MACI,IAAIE,KAAK,CAACC,OAAO,CAACH,KAAK,CAAC,EAAE;MAC3BN,UAAU,CAACI,UAAU,CAAC,GAAGE,KAAK,CACzBI,KAAK,CAAC,CAAC,CAAC,CACRC,MAAM,CAAC,CAACC,OAAO,EAAEN,KAAK,KAAKM,OAAO,CAACL,MAAM,CAAC,IAAAA,MAAA,CAAIH,UAAU,OAAAG,MAAA,CAAIb,SAAS,CAACY,KAAK,CAAC,EAAG,CAAC,EAAE,EAAE,CAAC,CACrFO,IAAI,CAAC,CAAC,CACNC,IAAI,CAAC,GAAG,CAAC;IAClB;EACJ;EACA,OAAOf,IAAI,CACNc,IAAI,CAAC,CAAC,CACNE,GAAG,CAAEd,GAAG,IAAKD,UAAU,CAACC,GAAG,CAAC,CAAC,CAC7Be,MAAM,CAAEhB,UAAU,IAAKA,UAAU,CAAC,CAClCc,IAAI,CAAC,GAAG,CAAC;AAClB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { NormalizedSchema, SCHEMA } from \"@smithy/core/schema\";\nimport { HttpRequest } from \"@smithy/protocol-http\";\nimport { collectBody } from \"./collect-stream-body\";\nimport { extendedEncodeURIComponent } from \"./extended-encode-uri-component\";\nimport { HttpProtocol } from \"./HttpProtocol\";\nexport class HttpBindingProtocol extends HttpProtocol {\n  async serializeRequest(operationSchema, input, context) {\n    const serializer = this.serializer;\n    const query = {};\n    const headers = {};\n    const endpoint = await context.endpoint();\n    const ns = NormalizedSchema.of(operationSchema?.input);\n    const schema = ns.getSchema();\n    let hasNonHttpBindingMember = false;\n    let payload;\n    const request = new HttpRequest({\n      protocol: \"\",\n      hostname: \"\",\n      port: undefined,\n      path: \"\",\n      fragment: undefined,\n      query: query,\n      headers: headers,\n      body: undefined\n    });\n    if (endpoint) {\n      this.updateServiceEndpoint(request, endpoint);\n      this.setHostPrefix(request, operationSchema, input);\n      const opTraits = NormalizedSchema.translateTraits(operationSchema.traits);\n      if (opTraits.http) {\n        request.method = opTraits.http[0];\n        const [path, search] = opTraits.http[1].split(\"?\");\n        if (request.path == \"/\") {\n          request.path = path;\n        } else {\n          request.path += path;\n        }\n        const traitSearchParams = new URLSearchParams(search ?? \"\");\n        Object.assign(query, Object.fromEntries(traitSearchParams));\n      }\n    }\n    const _input = {\n      ...input\n    };\n    for (const memberName of Object.keys(_input)) {\n      const memberNs = ns.getMemberSchema(memberName);\n      if (memberNs === undefined) {\n        continue;\n      }\n      const memberTraits = memberNs.getMergedTraits();\n      const inputMember = _input[memberName];\n      if (memberTraits.httpPayload) {\n        const isStreaming = memberNs.isStreaming();\n        if (isStreaming) {\n          const isEventStream = memberNs.isStructSchema();\n          if (isEventStream) {\n            throw new Error(\"serialization of event streams is not yet implemented\");\n          } else {\n            payload = inputMember;\n          }\n        } else {\n          serializer.write(memberNs, inputMember);\n          payload = serializer.flush();\n        }\n      } else if (memberTraits.httpLabel) {\n        serializer.write(memberNs, inputMember);\n        const replacement = serializer.flush();\n        if (request.path.includes(`{${memberName}+}`)) {\n          request.path = request.path.replace(`{${memberName}+}`, replacement.split(\"/\").map(extendedEncodeURIComponent).join(\"/\"));\n        } else if (request.path.includes(`{${memberName}}`)) {\n          request.path = request.path.replace(`{${memberName}}`, extendedEncodeURIComponent(replacement));\n        }\n        delete _input[memberName];\n      } else if (memberTraits.httpHeader) {\n        serializer.write(memberNs, inputMember);\n        headers[memberTraits.httpHeader.toLowerCase()] = String(serializer.flush());\n        delete _input[memberName];\n      } else if (typeof memberTraits.httpPrefixHeaders === \"string\") {\n        for (const [key, val] of Object.entries(inputMember)) {\n          const amalgam = memberTraits.httpPrefixHeaders + key;\n          serializer.write([memberNs.getValueSchema(), {\n            httpHeader: amalgam\n          }], val);\n          headers[amalgam.toLowerCase()] = serializer.flush();\n        }\n        delete _input[memberName];\n      } else if (memberTraits.httpQuery || memberTraits.httpQueryParams) {\n        this.serializeQuery(memberNs, inputMember, query);\n        delete _input[memberName];\n      } else {\n        hasNonHttpBindingMember = true;\n      }\n    }\n    if (hasNonHttpBindingMember && input) {\n      serializer.write(schema, _input);\n      payload = serializer.flush();\n    }\n    request.headers = headers;\n    request.query = query;\n    request.body = payload;\n    return request;\n  }\n  serializeQuery(ns, data, query) {\n    const serializer = this.serializer;\n    const traits = ns.getMergedTraits();\n    if (traits.httpQueryParams) {\n      for (const [key, val] of Object.entries(data)) {\n        if (!(key in query)) {\n          this.serializeQuery(NormalizedSchema.of([ns.getValueSchema(), {\n            ...traits,\n            httpQuery: key,\n            httpQueryParams: undefined\n          }]), val, query);\n        }\n      }\n      return;\n    }\n    if (ns.isListSchema()) {\n      const sparse = !!ns.getMergedTraits().sparse;\n      const buffer = [];\n      for (const item of data) {\n        serializer.write([ns.getValueSchema(), traits], item);\n        const serializable = serializer.flush();\n        if (sparse || serializable !== undefined) {\n          buffer.push(serializable);\n        }\n      }\n      query[traits.httpQuery] = buffer;\n    } else {\n      serializer.write([ns, traits], data);\n      query[traits.httpQuery] = serializer.flush();\n    }\n  }\n  async deserializeResponse(operationSchema, context, response) {\n    const deserializer = this.deserializer;\n    const ns = NormalizedSchema.of(operationSchema.output);\n    const dataObject = {};\n    if (response.statusCode >= 300) {\n      const bytes = await collectBody(response.body, context);\n      if (bytes.byteLength > 0) {\n        Object.assign(dataObject, await deserializer.read(SCHEMA.DOCUMENT, bytes));\n      }\n      await this.handleError(operationSchema, context, response, dataObject, this.deserializeMetadata(response));\n      throw new Error(\"@smithy/core/protocols - HTTP Protocol error handler failed to throw.\");\n    }\n    for (const header in response.headers) {\n      const value = response.headers[header];\n      delete response.headers[header];\n      response.headers[header.toLowerCase()] = value;\n    }\n    const nonHttpBindingMembers = await this.deserializeHttpMessage(ns, context, response, dataObject);\n    if (nonHttpBindingMembers.length) {\n      const bytes = await collectBody(response.body, context);\n      if (bytes.byteLength > 0) {\n        const dataFromBody = await deserializer.read(ns, bytes);\n        for (const member of nonHttpBindingMembers) {\n          dataObject[member] = dataFromBody[member];\n        }\n      }\n    }\n    const output = {\n      $metadata: this.deserializeMetadata(response),\n      ...dataObject\n    };\n    return output;\n  }\n}","map":{"version":3,"names":["NormalizedSchema","SCHEMA","HttpRequest","collectBody","extendedEncodeURIComponent","HttpProtocol","HttpBindingProtocol","serializeRequest","operationSchema","input","context","serializer","query","headers","endpoint","ns","of","schema","getSchema","hasNonHttpBindingMember","payload","request","protocol","hostname","port","undefined","path","fragment","body","updateServiceEndpoint","setHostPrefix","opTraits","translateTraits","traits","http","method","search","split","traitSearchParams","URLSearchParams","Object","assign","fromEntries","_input","memberName","keys","memberNs","getMemberSchema","memberTraits","getMergedTraits","inputMember","httpPayload","isStreaming","isEventStream","isStructSchema","Error","write","flush","httpLabel","replacement","includes","replace","map","join","httpHeader","toLowerCase","String","httpPrefixHeaders","key","val","entries","amalgam","getValueSchema","httpQuery","httpQueryParams","serializeQuery","data","isListSchema","sparse","buffer","item","serializable","push","deserializeResponse","response","deserializer","output","dataObject","statusCode","bytes","byteLength","read","DOCUMENT","handleError","deserializeMetadata","header","value","nonHttpBindingMembers","deserializeHttpMessage","length","dataFromBody","member","$metadata"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/@smithy/core/dist-es/submodules/protocols/HttpBindingProtocol.js"],"sourcesContent":["import { NormalizedSchema, SCHEMA } from \"@smithy/core/schema\";\nimport { HttpRequest } from \"@smithy/protocol-http\";\nimport { collectBody } from \"./collect-stream-body\";\nimport { extendedEncodeURIComponent } from \"./extended-encode-uri-component\";\nimport { HttpProtocol } from \"./HttpProtocol\";\nexport class HttpBindingProtocol extends HttpProtocol {\n    async serializeRequest(operationSchema, input, context) {\n        const serializer = this.serializer;\n        const query = {};\n        const headers = {};\n        const endpoint = await context.endpoint();\n        const ns = NormalizedSchema.of(operationSchema?.input);\n        const schema = ns.getSchema();\n        let hasNonHttpBindingMember = false;\n        let payload;\n        const request = new HttpRequest({\n            protocol: \"\",\n            hostname: \"\",\n            port: undefined,\n            path: \"\",\n            fragment: undefined,\n            query: query,\n            headers: headers,\n            body: undefined,\n        });\n        if (endpoint) {\n            this.updateServiceEndpoint(request, endpoint);\n            this.setHostPrefix(request, operationSchema, input);\n            const opTraits = NormalizedSchema.translateTraits(operationSchema.traits);\n            if (opTraits.http) {\n                request.method = opTraits.http[0];\n                const [path, search] = opTraits.http[1].split(\"?\");\n                if (request.path == \"/\") {\n                    request.path = path;\n                }\n                else {\n                    request.path += path;\n                }\n                const traitSearchParams = new URLSearchParams(search ?? \"\");\n                Object.assign(query, Object.fromEntries(traitSearchParams));\n            }\n        }\n        const _input = {\n            ...input,\n        };\n        for (const memberName of Object.keys(_input)) {\n            const memberNs = ns.getMemberSchema(memberName);\n            if (memberNs === undefined) {\n                continue;\n            }\n            const memberTraits = memberNs.getMergedTraits();\n            const inputMember = _input[memberName];\n            if (memberTraits.httpPayload) {\n                const isStreaming = memberNs.isStreaming();\n                if (isStreaming) {\n                    const isEventStream = memberNs.isStructSchema();\n                    if (isEventStream) {\n                        throw new Error(\"serialization of event streams is not yet implemented\");\n                    }\n                    else {\n                        payload = inputMember;\n                    }\n                }\n                else {\n                    serializer.write(memberNs, inputMember);\n                    payload = serializer.flush();\n                }\n            }\n            else if (memberTraits.httpLabel) {\n                serializer.write(memberNs, inputMember);\n                const replacement = serializer.flush();\n                if (request.path.includes(`{${memberName}+}`)) {\n                    request.path = request.path.replace(`{${memberName}+}`, replacement.split(\"/\").map(extendedEncodeURIComponent).join(\"/\"));\n                }\n                else if (request.path.includes(`{${memberName}}`)) {\n                    request.path = request.path.replace(`{${memberName}}`, extendedEncodeURIComponent(replacement));\n                }\n                delete _input[memberName];\n            }\n            else if (memberTraits.httpHeader) {\n                serializer.write(memberNs, inputMember);\n                headers[memberTraits.httpHeader.toLowerCase()] = String(serializer.flush());\n                delete _input[memberName];\n            }\n            else if (typeof memberTraits.httpPrefixHeaders === \"string\") {\n                for (const [key, val] of Object.entries(inputMember)) {\n                    const amalgam = memberTraits.httpPrefixHeaders + key;\n                    serializer.write([memberNs.getValueSchema(), { httpHeader: amalgam }], val);\n                    headers[amalgam.toLowerCase()] = serializer.flush();\n                }\n                delete _input[memberName];\n            }\n            else if (memberTraits.httpQuery || memberTraits.httpQueryParams) {\n                this.serializeQuery(memberNs, inputMember, query);\n                delete _input[memberName];\n            }\n            else {\n                hasNonHttpBindingMember = true;\n            }\n        }\n        if (hasNonHttpBindingMember && input) {\n            serializer.write(schema, _input);\n            payload = serializer.flush();\n        }\n        request.headers = headers;\n        request.query = query;\n        request.body = payload;\n        return request;\n    }\n    serializeQuery(ns, data, query) {\n        const serializer = this.serializer;\n        const traits = ns.getMergedTraits();\n        if (traits.httpQueryParams) {\n            for (const [key, val] of Object.entries(data)) {\n                if (!(key in query)) {\n                    this.serializeQuery(NormalizedSchema.of([\n                        ns.getValueSchema(),\n                        {\n                            ...traits,\n                            httpQuery: key,\n                            httpQueryParams: undefined,\n                        },\n                    ]), val, query);\n                }\n            }\n            return;\n        }\n        if (ns.isListSchema()) {\n            const sparse = !!ns.getMergedTraits().sparse;\n            const buffer = [];\n            for (const item of data) {\n                serializer.write([ns.getValueSchema(), traits], item);\n                const serializable = serializer.flush();\n                if (sparse || serializable !== undefined) {\n                    buffer.push(serializable);\n                }\n            }\n            query[traits.httpQuery] = buffer;\n        }\n        else {\n            serializer.write([ns, traits], data);\n            query[traits.httpQuery] = serializer.flush();\n        }\n    }\n    async deserializeResponse(operationSchema, context, response) {\n        const deserializer = this.deserializer;\n        const ns = NormalizedSchema.of(operationSchema.output);\n        const dataObject = {};\n        if (response.statusCode >= 300) {\n            const bytes = await collectBody(response.body, context);\n            if (bytes.byteLength > 0) {\n                Object.assign(dataObject, await deserializer.read(SCHEMA.DOCUMENT, bytes));\n            }\n            await this.handleError(operationSchema, context, response, dataObject, this.deserializeMetadata(response));\n            throw new Error(\"@smithy/core/protocols - HTTP Protocol error handler failed to throw.\");\n        }\n        for (const header in response.headers) {\n            const value = response.headers[header];\n            delete response.headers[header];\n            response.headers[header.toLowerCase()] = value;\n        }\n        const nonHttpBindingMembers = await this.deserializeHttpMessage(ns, context, response, dataObject);\n        if (nonHttpBindingMembers.length) {\n            const bytes = await collectBody(response.body, context);\n            if (bytes.byteLength > 0) {\n                const dataFromBody = await deserializer.read(ns, bytes);\n                for (const member of nonHttpBindingMembers) {\n                    dataObject[member] = dataFromBody[member];\n                }\n            }\n        }\n        const output = {\n            $metadata: this.deserializeMetadata(response),\n            ...dataObject,\n        };\n        return output;\n    }\n}\n"],"mappings":"AAAA,SAASA,gBAAgB,EAAEC,MAAM,QAAQ,qBAAqB;AAC9D,SAASC,WAAW,QAAQ,uBAAuB;AACnD,SAASC,WAAW,QAAQ,uBAAuB;AACnD,SAASC,0BAA0B,QAAQ,iCAAiC;AAC5E,SAASC,YAAY,QAAQ,gBAAgB;AAC7C,OAAO,MAAMC,mBAAmB,SAASD,YAAY,CAAC;EAClD,MAAME,gBAAgBA,CAACC,eAAe,EAAEC,KAAK,EAAEC,OAAO,EAAE;IACpD,MAAMC,UAAU,GAAG,IAAI,CAACA,UAAU;IAClC,MAAMC,KAAK,GAAG,CAAC,CAAC;IAChB,MAAMC,OAAO,GAAG,CAAC,CAAC;IAClB,MAAMC,QAAQ,GAAG,MAAMJ,OAAO,CAACI,QAAQ,CAAC,CAAC;IACzC,MAAMC,EAAE,GAAGf,gBAAgB,CAACgB,EAAE,CAACR,eAAe,EAAEC,KAAK,CAAC;IACtD,MAAMQ,MAAM,GAAGF,EAAE,CAACG,SAAS,CAAC,CAAC;IAC7B,IAAIC,uBAAuB,GAAG,KAAK;IACnC,IAAIC,OAAO;IACX,MAAMC,OAAO,GAAG,IAAInB,WAAW,CAAC;MAC5BoB,QAAQ,EAAE,EAAE;MACZC,QAAQ,EAAE,EAAE;MACZC,IAAI,EAAEC,SAAS;MACfC,IAAI,EAAE,EAAE;MACRC,QAAQ,EAAEF,SAAS;MACnBb,KAAK,EAAEA,KAAK;MACZC,OAAO,EAAEA,OAAO;MAChBe,IAAI,EAAEH;IACV,CAAC,CAAC;IACF,IAAIX,QAAQ,EAAE;MACV,IAAI,CAACe,qBAAqB,CAACR,OAAO,EAAEP,QAAQ,CAAC;MAC7C,IAAI,CAACgB,aAAa,CAACT,OAAO,EAAEb,eAAe,EAAEC,KAAK,CAAC;MACnD,MAAMsB,QAAQ,GAAG/B,gBAAgB,CAACgC,eAAe,CAACxB,eAAe,CAACyB,MAAM,CAAC;MACzE,IAAIF,QAAQ,CAACG,IAAI,EAAE;QACfb,OAAO,CAACc,MAAM,GAAGJ,QAAQ,CAACG,IAAI,CAAC,CAAC,CAAC;QACjC,MAAM,CAACR,IAAI,EAAEU,MAAM,CAAC,GAAGL,QAAQ,CAACG,IAAI,CAAC,CAAC,CAAC,CAACG,KAAK,CAAC,GAAG,CAAC;QAClD,IAAIhB,OAAO,CAACK,IAAI,IAAI,GAAG,EAAE;UACrBL,OAAO,CAACK,IAAI,GAAGA,IAAI;QACvB,CAAC,MACI;UACDL,OAAO,CAACK,IAAI,IAAIA,IAAI;QACxB;QACA,MAAMY,iBAAiB,GAAG,IAAIC,eAAe,CAACH,MAAM,IAAI,EAAE,CAAC;QAC3DI,MAAM,CAACC,MAAM,CAAC7B,KAAK,EAAE4B,MAAM,CAACE,WAAW,CAACJ,iBAAiB,CAAC,CAAC;MAC/D;IACJ;IACA,MAAMK,MAAM,GAAG;MACX,GAAGlC;IACP,CAAC;IACD,KAAK,MAAMmC,UAAU,IAAIJ,MAAM,CAACK,IAAI,CAACF,MAAM,CAAC,EAAE;MAC1C,MAAMG,QAAQ,GAAG/B,EAAE,CAACgC,eAAe,CAACH,UAAU,CAAC;MAC/C,IAAIE,QAAQ,KAAKrB,SAAS,EAAE;QACxB;MACJ;MACA,MAAMuB,YAAY,GAAGF,QAAQ,CAACG,eAAe,CAAC,CAAC;MAC/C,MAAMC,WAAW,GAAGP,MAAM,CAACC,UAAU,CAAC;MACtC,IAAII,YAAY,CAACG,WAAW,EAAE;QAC1B,MAAMC,WAAW,GAAGN,QAAQ,CAACM,WAAW,CAAC,CAAC;QAC1C,IAAIA,WAAW,EAAE;UACb,MAAMC,aAAa,GAAGP,QAAQ,CAACQ,cAAc,CAAC,CAAC;UAC/C,IAAID,aAAa,EAAE;YACf,MAAM,IAAIE,KAAK,CAAC,uDAAuD,CAAC;UAC5E,CAAC,MACI;YACDnC,OAAO,GAAG8B,WAAW;UACzB;QACJ,CAAC,MACI;UACDvC,UAAU,CAAC6C,KAAK,CAACV,QAAQ,EAAEI,WAAW,CAAC;UACvC9B,OAAO,GAAGT,UAAU,CAAC8C,KAAK,CAAC,CAAC;QAChC;MACJ,CAAC,MACI,IAAIT,YAAY,CAACU,SAAS,EAAE;QAC7B/C,UAAU,CAAC6C,KAAK,CAACV,QAAQ,EAAEI,WAAW,CAAC;QACvC,MAAMS,WAAW,GAAGhD,UAAU,CAAC8C,KAAK,CAAC,CAAC;QACtC,IAAIpC,OAAO,CAACK,IAAI,CAACkC,QAAQ,CAAC,IAAIhB,UAAU,IAAI,CAAC,EAAE;UAC3CvB,OAAO,CAACK,IAAI,GAAGL,OAAO,CAACK,IAAI,CAACmC,OAAO,CAAC,IAAIjB,UAAU,IAAI,EAAEe,WAAW,CAACtB,KAAK,CAAC,GAAG,CAAC,CAACyB,GAAG,CAAC1D,0BAA0B,CAAC,CAAC2D,IAAI,CAAC,GAAG,CAAC,CAAC;QAC7H,CAAC,MACI,IAAI1C,OAAO,CAACK,IAAI,CAACkC,QAAQ,CAAC,IAAIhB,UAAU,GAAG,CAAC,EAAE;UAC/CvB,OAAO,CAACK,IAAI,GAAGL,OAAO,CAACK,IAAI,CAACmC,OAAO,CAAC,IAAIjB,UAAU,GAAG,EAAExC,0BAA0B,CAACuD,WAAW,CAAC,CAAC;QACnG;QACA,OAAOhB,MAAM,CAACC,UAAU,CAAC;MAC7B,CAAC,MACI,IAAII,YAAY,CAACgB,UAAU,EAAE;QAC9BrD,UAAU,CAAC6C,KAAK,CAACV,QAAQ,EAAEI,WAAW,CAAC;QACvCrC,OAAO,CAACmC,YAAY,CAACgB,UAAU,CAACC,WAAW,CAAC,CAAC,CAAC,GAAGC,MAAM,CAACvD,UAAU,CAAC8C,KAAK,CAAC,CAAC,CAAC;QAC3E,OAAOd,MAAM,CAACC,UAAU,CAAC;MAC7B,CAAC,MACI,IAAI,OAAOI,YAAY,CAACmB,iBAAiB,KAAK,QAAQ,EAAE;QACzD,KAAK,MAAM,CAACC,GAAG,EAAEC,GAAG,CAAC,IAAI7B,MAAM,CAAC8B,OAAO,CAACpB,WAAW,CAAC,EAAE;UAClD,MAAMqB,OAAO,GAAGvB,YAAY,CAACmB,iBAAiB,GAAGC,GAAG;UACpDzD,UAAU,CAAC6C,KAAK,CAAC,CAACV,QAAQ,CAAC0B,cAAc,CAAC,CAAC,EAAE;YAAER,UAAU,EAAEO;UAAQ,CAAC,CAAC,EAAEF,GAAG,CAAC;UAC3ExD,OAAO,CAAC0D,OAAO,CAACN,WAAW,CAAC,CAAC,CAAC,GAAGtD,UAAU,CAAC8C,KAAK,CAAC,CAAC;QACvD;QACA,OAAOd,MAAM,CAACC,UAAU,CAAC;MAC7B,CAAC,MACI,IAAII,YAAY,CAACyB,SAAS,IAAIzB,YAAY,CAAC0B,eAAe,EAAE;QAC7D,IAAI,CAACC,cAAc,CAAC7B,QAAQ,EAAEI,WAAW,EAAEtC,KAAK,CAAC;QACjD,OAAO+B,MAAM,CAACC,UAAU,CAAC;MAC7B,CAAC,MACI;QACDzB,uBAAuB,GAAG,IAAI;MAClC;IACJ;IACA,IAAIA,uBAAuB,IAAIV,KAAK,EAAE;MAClCE,UAAU,CAAC6C,KAAK,CAACvC,MAAM,EAAE0B,MAAM,CAAC;MAChCvB,OAAO,GAAGT,UAAU,CAAC8C,KAAK,CAAC,CAAC;IAChC;IACApC,OAAO,CAACR,OAAO,GAAGA,OAAO;IACzBQ,OAAO,CAACT,KAAK,GAAGA,KAAK;IACrBS,OAAO,CAACO,IAAI,GAAGR,OAAO;IACtB,OAAOC,OAAO;EAClB;EACAsD,cAAcA,CAAC5D,EAAE,EAAE6D,IAAI,EAAEhE,KAAK,EAAE;IAC5B,MAAMD,UAAU,GAAG,IAAI,CAACA,UAAU;IAClC,MAAMsB,MAAM,GAAGlB,EAAE,CAACkC,eAAe,CAAC,CAAC;IACnC,IAAIhB,MAAM,CAACyC,eAAe,EAAE;MACxB,KAAK,MAAM,CAACN,GAAG,EAAEC,GAAG,CAAC,IAAI7B,MAAM,CAAC8B,OAAO,CAACM,IAAI,CAAC,EAAE;QAC3C,IAAI,EAAER,GAAG,IAAIxD,KAAK,CAAC,EAAE;UACjB,IAAI,CAAC+D,cAAc,CAAC3E,gBAAgB,CAACgB,EAAE,CAAC,CACpCD,EAAE,CAACyD,cAAc,CAAC,CAAC,EACnB;YACI,GAAGvC,MAAM;YACTwC,SAAS,EAAEL,GAAG;YACdM,eAAe,EAAEjD;UACrB,CAAC,CACJ,CAAC,EAAE4C,GAAG,EAAEzD,KAAK,CAAC;QACnB;MACJ;MACA;IACJ;IACA,IAAIG,EAAE,CAAC8D,YAAY,CAAC,CAAC,EAAE;MACnB,MAAMC,MAAM,GAAG,CAAC,CAAC/D,EAAE,CAACkC,eAAe,CAAC,CAAC,CAAC6B,MAAM;MAC5C,MAAMC,MAAM,GAAG,EAAE;MACjB,KAAK,MAAMC,IAAI,IAAIJ,IAAI,EAAE;QACrBjE,UAAU,CAAC6C,KAAK,CAAC,CAACzC,EAAE,CAACyD,cAAc,CAAC,CAAC,EAAEvC,MAAM,CAAC,EAAE+C,IAAI,CAAC;QACrD,MAAMC,YAAY,GAAGtE,UAAU,CAAC8C,KAAK,CAAC,CAAC;QACvC,IAAIqB,MAAM,IAAIG,YAAY,KAAKxD,SAAS,EAAE;UACtCsD,MAAM,CAACG,IAAI,CAACD,YAAY,CAAC;QAC7B;MACJ;MACArE,KAAK,CAACqB,MAAM,CAACwC,SAAS,CAAC,GAAGM,MAAM;IACpC,CAAC,MACI;MACDpE,UAAU,CAAC6C,KAAK,CAAC,CAACzC,EAAE,EAAEkB,MAAM,CAAC,EAAE2C,IAAI,CAAC;MACpChE,KAAK,CAACqB,MAAM,CAACwC,SAAS,CAAC,GAAG9D,UAAU,CAAC8C,KAAK,CAAC,CAAC;IAChD;EACJ;EACA,MAAM0B,mBAAmBA,CAAC3E,eAAe,EAAEE,OAAO,EAAE0E,QAAQ,EAAE;IAC1D,MAAMC,YAAY,GAAG,IAAI,CAACA,YAAY;IACtC,MAAMtE,EAAE,GAAGf,gBAAgB,CAACgB,EAAE,CAACR,eAAe,CAAC8E,MAAM,CAAC;IACtD,MAAMC,UAAU,GAAG,CAAC,CAAC;IACrB,IAAIH,QAAQ,CAACI,UAAU,IAAI,GAAG,EAAE;MAC5B,MAAMC,KAAK,GAAG,MAAMtF,WAAW,CAACiF,QAAQ,CAACxD,IAAI,EAAElB,OAAO,CAAC;MACvD,IAAI+E,KAAK,CAACC,UAAU,GAAG,CAAC,EAAE;QACtBlD,MAAM,CAACC,MAAM,CAAC8C,UAAU,EAAE,MAAMF,YAAY,CAACM,IAAI,CAAC1F,MAAM,CAAC2F,QAAQ,EAAEH,KAAK,CAAC,CAAC;MAC9E;MACA,MAAM,IAAI,CAACI,WAAW,CAACrF,eAAe,EAAEE,OAAO,EAAE0E,QAAQ,EAAEG,UAAU,EAAE,IAAI,CAACO,mBAAmB,CAACV,QAAQ,CAAC,CAAC;MAC1G,MAAM,IAAI7B,KAAK,CAAC,uEAAuE,CAAC;IAC5F;IACA,KAAK,MAAMwC,MAAM,IAAIX,QAAQ,CAACvE,OAAO,EAAE;MACnC,MAAMmF,KAAK,GAAGZ,QAAQ,CAACvE,OAAO,CAACkF,MAAM,CAAC;MACtC,OAAOX,QAAQ,CAACvE,OAAO,CAACkF,MAAM,CAAC;MAC/BX,QAAQ,CAACvE,OAAO,CAACkF,MAAM,CAAC9B,WAAW,CAAC,CAAC,CAAC,GAAG+B,KAAK;IAClD;IACA,MAAMC,qBAAqB,GAAG,MAAM,IAAI,CAACC,sBAAsB,CAACnF,EAAE,EAAEL,OAAO,EAAE0E,QAAQ,EAAEG,UAAU,CAAC;IAClG,IAAIU,qBAAqB,CAACE,MAAM,EAAE;MAC9B,MAAMV,KAAK,GAAG,MAAMtF,WAAW,CAACiF,QAAQ,CAACxD,IAAI,EAAElB,OAAO,CAAC;MACvD,IAAI+E,KAAK,CAACC,UAAU,GAAG,CAAC,EAAE;QACtB,MAAMU,YAAY,GAAG,MAAMf,YAAY,CAACM,IAAI,CAAC5E,EAAE,EAAE0E,KAAK,CAAC;QACvD,KAAK,MAAMY,MAAM,IAAIJ,qBAAqB,EAAE;UACxCV,UAAU,CAACc,MAAM,CAAC,GAAGD,YAAY,CAACC,MAAM,CAAC;QAC7C;MACJ;IACJ;IACA,MAAMf,MAAM,GAAG;MACXgB,SAAS,EAAE,IAAI,CAACR,mBAAmB,CAACV,QAAQ,CAAC;MAC7C,GAAGG;IACP,CAAC;IACD,OAAOD,MAAM;EACjB;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
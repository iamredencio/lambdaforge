{"ast":null,"code":"import { ByteArrayCollector } from \"./ByteArrayCollector\";\nexport function createBufferedReadableStream(upstream, size, logger) {\n  const reader = upstream.getReader();\n  let streamBufferingLoggedWarning = false;\n  let bytesSeen = 0;\n  const buffers = [\"\", new ByteArrayCollector(size => new Uint8Array(size))];\n  let mode = -1;\n  const pull = async controller => {\n    const {\n      value,\n      done\n    } = await reader.read();\n    const chunk = value;\n    if (done) {\n      if (mode !== -1) {\n        const remainder = flush(buffers, mode);\n        if (sizeOf(remainder) > 0) {\n          controller.enqueue(remainder);\n        }\n      }\n      controller.close();\n    } else {\n      const chunkMode = modeOf(chunk, false);\n      if (mode !== chunkMode) {\n        if (mode >= 0) {\n          controller.enqueue(flush(buffers, mode));\n        }\n        mode = chunkMode;\n      }\n      if (mode === -1) {\n        controller.enqueue(chunk);\n        return;\n      }\n      const chunkSize = sizeOf(chunk);\n      bytesSeen += chunkSize;\n      const bufferSize = sizeOf(buffers[mode]);\n      if (chunkSize >= size && bufferSize === 0) {\n        controller.enqueue(chunk);\n      } else {\n        const newSize = merge(buffers, mode, chunk);\n        if (!streamBufferingLoggedWarning && bytesSeen > size * 2) {\n          streamBufferingLoggedWarning = true;\n          logger === null || logger === void 0 || logger.warn(\"@smithy/util-stream - stream chunk size \".concat(chunkSize, \" is below threshold of \").concat(size, \", automatically buffering.\"));\n        }\n        if (newSize >= size) {\n          controller.enqueue(flush(buffers, mode));\n        } else {\n          await pull(controller);\n        }\n      }\n    }\n  };\n  return new ReadableStream({\n    pull\n  });\n}\nexport const createBufferedReadable = createBufferedReadableStream;\nexport function merge(buffers, mode, chunk) {\n  switch (mode) {\n    case 0:\n      buffers[0] += chunk;\n      return sizeOf(buffers[0]);\n    case 1:\n    case 2:\n      buffers[mode].push(chunk);\n      return sizeOf(buffers[mode]);\n  }\n}\nexport function flush(buffers, mode) {\n  switch (mode) {\n    case 0:\n      const s = buffers[0];\n      buffers[0] = \"\";\n      return s;\n    case 1:\n    case 2:\n      return buffers[mode].flush();\n  }\n  throw new Error(\"@smithy/util-stream - invalid index \".concat(mode, \" given to flush()\"));\n}\nexport function sizeOf(chunk) {\n  var _ref, _chunk$byteLength;\n  return (_ref = (_chunk$byteLength = chunk === null || chunk === void 0 ? void 0 : chunk.byteLength) !== null && _chunk$byteLength !== void 0 ? _chunk$byteLength : chunk === null || chunk === void 0 ? void 0 : chunk.length) !== null && _ref !== void 0 ? _ref : 0;\n}\nexport function modeOf(chunk) {\n  let allowBuffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (allowBuffer && typeof Buffer !== \"undefined\" && chunk instanceof Buffer) {\n    return 2;\n  }\n  if (chunk instanceof Uint8Array) {\n    return 1;\n  }\n  if (typeof chunk === \"string\") {\n    return 0;\n  }\n  return -1;\n}","map":{"version":3,"names":["ByteArrayCollector","createBufferedReadableStream","upstream","size","logger","reader","getReader","streamBufferingLoggedWarning","bytesSeen","buffers","Uint8Array","mode","pull","controller","value","done","read","chunk","remainder","flush","sizeOf","enqueue","close","chunkMode","modeOf","chunkSize","bufferSize","newSize","merge","warn","concat","ReadableStream","createBufferedReadable","push","s","Error","_ref","_chunk$byteLength","byteLength","length","allowBuffer","arguments","undefined","Buffer"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/@smithy/util-stream/dist-es/createBufferedReadableStream.js"],"sourcesContent":["import { ByteArrayCollector } from \"./ByteArrayCollector\";\nexport function createBufferedReadableStream(upstream, size, logger) {\n    const reader = upstream.getReader();\n    let streamBufferingLoggedWarning = false;\n    let bytesSeen = 0;\n    const buffers = [\"\", new ByteArrayCollector((size) => new Uint8Array(size))];\n    let mode = -1;\n    const pull = async (controller) => {\n        const { value, done } = await reader.read();\n        const chunk = value;\n        if (done) {\n            if (mode !== -1) {\n                const remainder = flush(buffers, mode);\n                if (sizeOf(remainder) > 0) {\n                    controller.enqueue(remainder);\n                }\n            }\n            controller.close();\n        }\n        else {\n            const chunkMode = modeOf(chunk, false);\n            if (mode !== chunkMode) {\n                if (mode >= 0) {\n                    controller.enqueue(flush(buffers, mode));\n                }\n                mode = chunkMode;\n            }\n            if (mode === -1) {\n                controller.enqueue(chunk);\n                return;\n            }\n            const chunkSize = sizeOf(chunk);\n            bytesSeen += chunkSize;\n            const bufferSize = sizeOf(buffers[mode]);\n            if (chunkSize >= size && bufferSize === 0) {\n                controller.enqueue(chunk);\n            }\n            else {\n                const newSize = merge(buffers, mode, chunk);\n                if (!streamBufferingLoggedWarning && bytesSeen > size * 2) {\n                    streamBufferingLoggedWarning = true;\n                    logger?.warn(`@smithy/util-stream - stream chunk size ${chunkSize} is below threshold of ${size}, automatically buffering.`);\n                }\n                if (newSize >= size) {\n                    controller.enqueue(flush(buffers, mode));\n                }\n                else {\n                    await pull(controller);\n                }\n            }\n        }\n    };\n    return new ReadableStream({\n        pull,\n    });\n}\nexport const createBufferedReadable = createBufferedReadableStream;\nexport function merge(buffers, mode, chunk) {\n    switch (mode) {\n        case 0:\n            buffers[0] += chunk;\n            return sizeOf(buffers[0]);\n        case 1:\n        case 2:\n            buffers[mode].push(chunk);\n            return sizeOf(buffers[mode]);\n    }\n}\nexport function flush(buffers, mode) {\n    switch (mode) {\n        case 0:\n            const s = buffers[0];\n            buffers[0] = \"\";\n            return s;\n        case 1:\n        case 2:\n            return buffers[mode].flush();\n    }\n    throw new Error(`@smithy/util-stream - invalid index ${mode} given to flush()`);\n}\nexport function sizeOf(chunk) {\n    return chunk?.byteLength ?? chunk?.length ?? 0;\n}\nexport function modeOf(chunk, allowBuffer = true) {\n    if (allowBuffer && typeof Buffer !== \"undefined\" && chunk instanceof Buffer) {\n        return 2;\n    }\n    if (chunk instanceof Uint8Array) {\n        return 1;\n    }\n    if (typeof chunk === \"string\") {\n        return 0;\n    }\n    return -1;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
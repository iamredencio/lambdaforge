{"ast":null,"code":"import { XmlNode, XmlText } from \"@aws-sdk/xml-builder\";\nimport { NormalizedSchema, SCHEMA } from \"@smithy/core/schema\";\nimport { NumericValue } from \"@smithy/core/serde\";\nimport { dateToUtcString } from \"@smithy/smithy-client\";\nimport { fromBase64, toBase64 } from \"@smithy/util-base64\";\nimport { SerdeContextConfig } from \"../ConfigurableSerdeContext\";\nexport class XmlShapeSerializer extends SerdeContextConfig {\n  settings;\n  stringBuffer;\n  byteBuffer;\n  buffer;\n  constructor(settings) {\n    super();\n    this.settings = settings;\n  }\n  write(schema, value) {\n    const ns = NormalizedSchema.of(schema);\n    if (ns.isStringSchema() && typeof value === \"string\") {\n      this.stringBuffer = value;\n    } else if (ns.isBlobSchema()) {\n      this.byteBuffer = \"byteLength\" in value ? value : (this.serdeContext?.base64Decoder ?? fromBase64)(value);\n    } else {\n      this.buffer = this.writeStruct(ns, value, undefined);\n      const traits = ns.getMergedTraits();\n      if (traits.httpPayload && !traits.xmlName) {\n        this.buffer.withName(ns.getName());\n      }\n    }\n  }\n  flush() {\n    if (this.byteBuffer !== undefined) {\n      const bytes = this.byteBuffer;\n      delete this.byteBuffer;\n      return bytes;\n    }\n    if (this.stringBuffer !== undefined) {\n      const str = this.stringBuffer;\n      delete this.stringBuffer;\n      return str;\n    }\n    const buffer = this.buffer;\n    if (this.settings.xmlNamespace) {\n      if (!buffer?.attributes?.[\"xmlns\"]) {\n        buffer.addAttribute(\"xmlns\", this.settings.xmlNamespace);\n      }\n    }\n    delete this.buffer;\n    return buffer.toString();\n  }\n  writeStruct(ns, value, parentXmlns) {\n    const traits = ns.getMergedTraits();\n    const name = ns.isMemberSchema() && !traits.httpPayload ? ns.getMemberTraits().xmlName ?? ns.getMemberName() : traits.xmlName ?? ns.getName();\n    if (!name || !ns.isStructSchema()) {\n      throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write struct with empty name or non-struct, schema=${ns.getName(true)}.`);\n    }\n    const structXmlNode = XmlNode.of(name);\n    const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);\n    if (xmlns) {\n      structXmlNode.addAttribute(xmlnsAttr, xmlns);\n    }\n    for (const [memberName, memberSchema] of ns.structIterator()) {\n      const val = value[memberName];\n      if (val != null) {\n        if (memberSchema.getMergedTraits().xmlAttribute) {\n          structXmlNode.addAttribute(memberSchema.getMergedTraits().xmlName ?? memberName, this.writeSimple(memberSchema, val));\n          continue;\n        }\n        if (memberSchema.isListSchema()) {\n          this.writeList(memberSchema, val, structXmlNode, xmlns);\n        } else if (memberSchema.isMapSchema()) {\n          this.writeMap(memberSchema, val, structXmlNode, xmlns);\n        } else if (memberSchema.isStructSchema()) {\n          structXmlNode.addChildNode(this.writeStruct(memberSchema, val, xmlns));\n        } else {\n          const memberNode = XmlNode.of(memberSchema.getMergedTraits().xmlName ?? memberSchema.getMemberName());\n          this.writeSimpleInto(memberSchema, val, memberNode, xmlns);\n          structXmlNode.addChildNode(memberNode);\n        }\n      }\n    }\n    return structXmlNode;\n  }\n  writeList(listMember, array, container, parentXmlns) {\n    if (!listMember.isMemberSchema()) {\n      throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member list: ${listMember.getName(true)}`);\n    }\n    const listTraits = listMember.getMergedTraits();\n    const listValueSchema = listMember.getValueSchema();\n    const listValueTraits = listValueSchema.getMergedTraits();\n    const sparse = !!listValueTraits.sparse;\n    const flat = !!listTraits.xmlFlattened;\n    const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(listMember, parentXmlns);\n    const writeItem = (container, value) => {\n      if (listValueSchema.isListSchema()) {\n        this.writeList(listValueSchema, Array.isArray(value) ? value : [value], container, xmlns);\n      } else if (listValueSchema.isMapSchema()) {\n        this.writeMap(listValueSchema, value, container, xmlns);\n      } else if (listValueSchema.isStructSchema()) {\n        const struct = this.writeStruct(listValueSchema, value, xmlns);\n        container.addChildNode(struct.withName(flat ? listTraits.xmlName ?? listMember.getMemberName() : listValueTraits.xmlName ?? \"member\"));\n      } else {\n        const listItemNode = XmlNode.of(flat ? listTraits.xmlName ?? listMember.getMemberName() : listValueTraits.xmlName ?? \"member\");\n        this.writeSimpleInto(listValueSchema, value, listItemNode, xmlns);\n        container.addChildNode(listItemNode);\n      }\n    };\n    if (flat) {\n      for (const value of array) {\n        if (sparse || value != null) {\n          writeItem(container, value);\n        }\n      }\n    } else {\n      const listNode = XmlNode.of(listTraits.xmlName ?? listMember.getMemberName());\n      if (xmlns) {\n        listNode.addAttribute(xmlnsAttr, xmlns);\n      }\n      for (const value of array) {\n        if (sparse || value != null) {\n          writeItem(listNode, value);\n        }\n      }\n      container.addChildNode(listNode);\n    }\n  }\n  writeMap(mapMember, map, container, parentXmlns, containerIsMap = false) {\n    if (!mapMember.isMemberSchema()) {\n      throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member map: ${mapMember.getName(true)}`);\n    }\n    const mapTraits = mapMember.getMergedTraits();\n    const mapKeySchema = mapMember.getKeySchema();\n    const mapKeyTraits = mapKeySchema.getMergedTraits();\n    const keyTag = mapKeyTraits.xmlName ?? \"key\";\n    const mapValueSchema = mapMember.getValueSchema();\n    const mapValueTraits = mapValueSchema.getMergedTraits();\n    const valueTag = mapValueTraits.xmlName ?? \"value\";\n    const sparse = !!mapValueTraits.sparse;\n    const flat = !!mapTraits.xmlFlattened;\n    const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(mapMember, parentXmlns);\n    const addKeyValue = (entry, key, val) => {\n      const keyNode = XmlNode.of(keyTag, key);\n      const [keyXmlnsAttr, keyXmlns] = this.getXmlnsAttribute(mapKeySchema, xmlns);\n      if (keyXmlns) {\n        keyNode.addAttribute(keyXmlnsAttr, keyXmlns);\n      }\n      entry.addChildNode(keyNode);\n      let valueNode = XmlNode.of(valueTag);\n      if (mapValueSchema.isListSchema()) {\n        this.writeList(mapValueSchema, val, valueNode, xmlns);\n      } else if (mapValueSchema.isMapSchema()) {\n        this.writeMap(mapValueSchema, val, valueNode, xmlns, true);\n      } else if (mapValueSchema.isStructSchema()) {\n        valueNode = this.writeStruct(mapValueSchema, val, xmlns);\n      } else {\n        this.writeSimpleInto(mapValueSchema, val, valueNode, xmlns);\n      }\n      entry.addChildNode(valueNode);\n    };\n    if (flat) {\n      for (const [key, val] of Object.entries(map)) {\n        if (sparse || val != null) {\n          const entry = XmlNode.of(mapTraits.xmlName ?? mapMember.getMemberName());\n          addKeyValue(entry, key, val);\n          container.addChildNode(entry);\n        }\n      }\n    } else {\n      let mapNode;\n      if (!containerIsMap) {\n        mapNode = XmlNode.of(mapTraits.xmlName ?? mapMember.getMemberName());\n        if (xmlns) {\n          mapNode.addAttribute(xmlnsAttr, xmlns);\n        }\n        container.addChildNode(mapNode);\n      }\n      for (const [key, val] of Object.entries(map)) {\n        if (sparse || val != null) {\n          const entry = XmlNode.of(\"entry\");\n          addKeyValue(entry, key, val);\n          (containerIsMap ? container : mapNode).addChildNode(entry);\n        }\n      }\n    }\n  }\n  writeSimple(_schema, value) {\n    if (null === value) {\n      throw new Error(\"@aws-sdk/core/protocols - (XML serializer) cannot write null value.\");\n    }\n    const ns = NormalizedSchema.of(_schema);\n    let nodeContents = null;\n    if (value && typeof value === \"object\") {\n      if (ns.isBlobSchema()) {\n        nodeContents = (this.serdeContext?.base64Encoder ?? toBase64)(value);\n      } else if (ns.isTimestampSchema() && value instanceof Date) {\n        const options = this.settings.timestampFormat;\n        const format = options.useTrait ? ns.getSchema() === SCHEMA.TIMESTAMP_DEFAULT ? options.default : ns.getSchema() ?? options.default : options.default;\n        switch (format) {\n          case SCHEMA.TIMESTAMP_DATE_TIME:\n            nodeContents = value.toISOString().replace(\".000Z\", \"Z\");\n            break;\n          case SCHEMA.TIMESTAMP_HTTP_DATE:\n            nodeContents = dateToUtcString(value);\n            break;\n          case SCHEMA.TIMESTAMP_EPOCH_SECONDS:\n            nodeContents = String(value.getTime() / 1000);\n            break;\n          default:\n            console.warn(\"Missing timestamp format, using http date\", value);\n            nodeContents = dateToUtcString(value);\n            break;\n        }\n      } else if (ns.isBigDecimalSchema() && value) {\n        if (value instanceof NumericValue) {\n          return value.string;\n        }\n        return String(value);\n      } else if (ns.isMapSchema() || ns.isListSchema()) {\n        throw new Error(\"@aws-sdk/core/protocols - xml serializer, cannot call _write() on List/Map schema, call writeList or writeMap() instead.\");\n      } else {\n        throw new Error(`@aws-sdk/core/protocols - xml serializer, unhandled schema type for object value and schema: ${ns.getName(true)}`);\n      }\n    }\n    if (ns.isStringSchema() || ns.isBooleanSchema() || ns.isNumericSchema() || ns.isBigIntegerSchema() || ns.isBigDecimalSchema()) {\n      nodeContents = String(value);\n    }\n    if (nodeContents === null) {\n      throw new Error(`Unhandled schema-value pair ${ns.getName(true)}=${value}`);\n    }\n    return nodeContents;\n  }\n  writeSimpleInto(_schema, value, into, parentXmlns) {\n    const nodeContents = this.writeSimple(_schema, value);\n    const ns = NormalizedSchema.of(_schema);\n    const content = new XmlText(nodeContents);\n    const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);\n    if (xmlns) {\n      into.addAttribute(xmlnsAttr, xmlns);\n    }\n    into.addChildNode(content);\n  }\n  getXmlnsAttribute(ns, parentXmlns) {\n    const traits = ns.getMergedTraits();\n    const [prefix, xmlns] = traits.xmlNamespace ?? [];\n    if (xmlns && xmlns !== parentXmlns) {\n      return [prefix ? `xmlns:${prefix}` : \"xmlns\", xmlns];\n    }\n    return [void 0, void 0];\n  }\n}","map":{"version":3,"names":["XmlNode","XmlText","NormalizedSchema","SCHEMA","NumericValue","dateToUtcString","fromBase64","toBase64","SerdeContextConfig","XmlShapeSerializer","settings","stringBuffer","byteBuffer","buffer","constructor","write","schema","value","ns","of","isStringSchema","isBlobSchema","serdeContext","base64Decoder","writeStruct","undefined","traits","getMergedTraits","httpPayload","xmlName","withName","getName","flush","bytes","str","xmlNamespace","attributes","addAttribute","toString","parentXmlns","name","isMemberSchema","getMemberTraits","getMemberName","isStructSchema","Error","structXmlNode","xmlnsAttr","xmlns","getXmlnsAttribute","memberName","memberSchema","structIterator","val","xmlAttribute","writeSimple","isListSchema","writeList","isMapSchema","writeMap","addChildNode","memberNode","writeSimpleInto","listMember","array","container","listTraits","listValueSchema","getValueSchema","listValueTraits","sparse","flat","xmlFlattened","writeItem","Array","isArray","struct","listItemNode","listNode","mapMember","map","containerIsMap","mapTraits","mapKeySchema","getKeySchema","mapKeyTraits","keyTag","mapValueSchema","mapValueTraits","valueTag","addKeyValue","entry","key","keyNode","keyXmlnsAttr","keyXmlns","valueNode","Object","entries","mapNode","_schema","nodeContents","base64Encoder","isTimestampSchema","Date","options","timestampFormat","format","useTrait","getSchema","TIMESTAMP_DEFAULT","default","TIMESTAMP_DATE_TIME","toISOString","replace","TIMESTAMP_HTTP_DATE","TIMESTAMP_EPOCH_SECONDS","String","getTime","console","warn","isBigDecimalSchema","string","isBooleanSchema","isNumericSchema","isBigIntegerSchema","into","content","prefix"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/XmlShapeSerializer.js"],"sourcesContent":["import { XmlNode, XmlText } from \"@aws-sdk/xml-builder\";\nimport { NormalizedSchema, SCHEMA } from \"@smithy/core/schema\";\nimport { NumericValue } from \"@smithy/core/serde\";\nimport { dateToUtcString } from \"@smithy/smithy-client\";\nimport { fromBase64, toBase64 } from \"@smithy/util-base64\";\nimport { SerdeContextConfig } from \"../ConfigurableSerdeContext\";\nexport class XmlShapeSerializer extends SerdeContextConfig {\n    settings;\n    stringBuffer;\n    byteBuffer;\n    buffer;\n    constructor(settings) {\n        super();\n        this.settings = settings;\n    }\n    write(schema, value) {\n        const ns = NormalizedSchema.of(schema);\n        if (ns.isStringSchema() && typeof value === \"string\") {\n            this.stringBuffer = value;\n        }\n        else if (ns.isBlobSchema()) {\n            this.byteBuffer =\n                \"byteLength\" in value\n                    ? value\n                    : (this.serdeContext?.base64Decoder ?? fromBase64)(value);\n        }\n        else {\n            this.buffer = this.writeStruct(ns, value, undefined);\n            const traits = ns.getMergedTraits();\n            if (traits.httpPayload && !traits.xmlName) {\n                this.buffer.withName(ns.getName());\n            }\n        }\n    }\n    flush() {\n        if (this.byteBuffer !== undefined) {\n            const bytes = this.byteBuffer;\n            delete this.byteBuffer;\n            return bytes;\n        }\n        if (this.stringBuffer !== undefined) {\n            const str = this.stringBuffer;\n            delete this.stringBuffer;\n            return str;\n        }\n        const buffer = this.buffer;\n        if (this.settings.xmlNamespace) {\n            if (!buffer?.attributes?.[\"xmlns\"]) {\n                buffer.addAttribute(\"xmlns\", this.settings.xmlNamespace);\n            }\n        }\n        delete this.buffer;\n        return buffer.toString();\n    }\n    writeStruct(ns, value, parentXmlns) {\n        const traits = ns.getMergedTraits();\n        const name = ns.isMemberSchema() && !traits.httpPayload\n            ? ns.getMemberTraits().xmlName ?? ns.getMemberName()\n            : traits.xmlName ?? ns.getName();\n        if (!name || !ns.isStructSchema()) {\n            throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write struct with empty name or non-struct, schema=${ns.getName(true)}.`);\n        }\n        const structXmlNode = XmlNode.of(name);\n        const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);\n        if (xmlns) {\n            structXmlNode.addAttribute(xmlnsAttr, xmlns);\n        }\n        for (const [memberName, memberSchema] of ns.structIterator()) {\n            const val = value[memberName];\n            if (val != null) {\n                if (memberSchema.getMergedTraits().xmlAttribute) {\n                    structXmlNode.addAttribute(memberSchema.getMergedTraits().xmlName ?? memberName, this.writeSimple(memberSchema, val));\n                    continue;\n                }\n                if (memberSchema.isListSchema()) {\n                    this.writeList(memberSchema, val, structXmlNode, xmlns);\n                }\n                else if (memberSchema.isMapSchema()) {\n                    this.writeMap(memberSchema, val, structXmlNode, xmlns);\n                }\n                else if (memberSchema.isStructSchema()) {\n                    structXmlNode.addChildNode(this.writeStruct(memberSchema, val, xmlns));\n                }\n                else {\n                    const memberNode = XmlNode.of(memberSchema.getMergedTraits().xmlName ?? memberSchema.getMemberName());\n                    this.writeSimpleInto(memberSchema, val, memberNode, xmlns);\n                    structXmlNode.addChildNode(memberNode);\n                }\n            }\n        }\n        return structXmlNode;\n    }\n    writeList(listMember, array, container, parentXmlns) {\n        if (!listMember.isMemberSchema()) {\n            throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member list: ${listMember.getName(true)}`);\n        }\n        const listTraits = listMember.getMergedTraits();\n        const listValueSchema = listMember.getValueSchema();\n        const listValueTraits = listValueSchema.getMergedTraits();\n        const sparse = !!listValueTraits.sparse;\n        const flat = !!listTraits.xmlFlattened;\n        const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(listMember, parentXmlns);\n        const writeItem = (container, value) => {\n            if (listValueSchema.isListSchema()) {\n                this.writeList(listValueSchema, Array.isArray(value) ? value : [value], container, xmlns);\n            }\n            else if (listValueSchema.isMapSchema()) {\n                this.writeMap(listValueSchema, value, container, xmlns);\n            }\n            else if (listValueSchema.isStructSchema()) {\n                const struct = this.writeStruct(listValueSchema, value, xmlns);\n                container.addChildNode(struct.withName(flat ? listTraits.xmlName ?? listMember.getMemberName() : listValueTraits.xmlName ?? \"member\"));\n            }\n            else {\n                const listItemNode = XmlNode.of(flat ? listTraits.xmlName ?? listMember.getMemberName() : listValueTraits.xmlName ?? \"member\");\n                this.writeSimpleInto(listValueSchema, value, listItemNode, xmlns);\n                container.addChildNode(listItemNode);\n            }\n        };\n        if (flat) {\n            for (const value of array) {\n                if (sparse || value != null) {\n                    writeItem(container, value);\n                }\n            }\n        }\n        else {\n            const listNode = XmlNode.of(listTraits.xmlName ?? listMember.getMemberName());\n            if (xmlns) {\n                listNode.addAttribute(xmlnsAttr, xmlns);\n            }\n            for (const value of array) {\n                if (sparse || value != null) {\n                    writeItem(listNode, value);\n                }\n            }\n            container.addChildNode(listNode);\n        }\n    }\n    writeMap(mapMember, map, container, parentXmlns, containerIsMap = false) {\n        if (!mapMember.isMemberSchema()) {\n            throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member map: ${mapMember.getName(true)}`);\n        }\n        const mapTraits = mapMember.getMergedTraits();\n        const mapKeySchema = mapMember.getKeySchema();\n        const mapKeyTraits = mapKeySchema.getMergedTraits();\n        const keyTag = mapKeyTraits.xmlName ?? \"key\";\n        const mapValueSchema = mapMember.getValueSchema();\n        const mapValueTraits = mapValueSchema.getMergedTraits();\n        const valueTag = mapValueTraits.xmlName ?? \"value\";\n        const sparse = !!mapValueTraits.sparse;\n        const flat = !!mapTraits.xmlFlattened;\n        const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(mapMember, parentXmlns);\n        const addKeyValue = (entry, key, val) => {\n            const keyNode = XmlNode.of(keyTag, key);\n            const [keyXmlnsAttr, keyXmlns] = this.getXmlnsAttribute(mapKeySchema, xmlns);\n            if (keyXmlns) {\n                keyNode.addAttribute(keyXmlnsAttr, keyXmlns);\n            }\n            entry.addChildNode(keyNode);\n            let valueNode = XmlNode.of(valueTag);\n            if (mapValueSchema.isListSchema()) {\n                this.writeList(mapValueSchema, val, valueNode, xmlns);\n            }\n            else if (mapValueSchema.isMapSchema()) {\n                this.writeMap(mapValueSchema, val, valueNode, xmlns, true);\n            }\n            else if (mapValueSchema.isStructSchema()) {\n                valueNode = this.writeStruct(mapValueSchema, val, xmlns);\n            }\n            else {\n                this.writeSimpleInto(mapValueSchema, val, valueNode, xmlns);\n            }\n            entry.addChildNode(valueNode);\n        };\n        if (flat) {\n            for (const [key, val] of Object.entries(map)) {\n                if (sparse || val != null) {\n                    const entry = XmlNode.of(mapTraits.xmlName ?? mapMember.getMemberName());\n                    addKeyValue(entry, key, val);\n                    container.addChildNode(entry);\n                }\n            }\n        }\n        else {\n            let mapNode;\n            if (!containerIsMap) {\n                mapNode = XmlNode.of(mapTraits.xmlName ?? mapMember.getMemberName());\n                if (xmlns) {\n                    mapNode.addAttribute(xmlnsAttr, xmlns);\n                }\n                container.addChildNode(mapNode);\n            }\n            for (const [key, val] of Object.entries(map)) {\n                if (sparse || val != null) {\n                    const entry = XmlNode.of(\"entry\");\n                    addKeyValue(entry, key, val);\n                    (containerIsMap ? container : mapNode).addChildNode(entry);\n                }\n            }\n        }\n    }\n    writeSimple(_schema, value) {\n        if (null === value) {\n            throw new Error(\"@aws-sdk/core/protocols - (XML serializer) cannot write null value.\");\n        }\n        const ns = NormalizedSchema.of(_schema);\n        let nodeContents = null;\n        if (value && typeof value === \"object\") {\n            if (ns.isBlobSchema()) {\n                nodeContents = (this.serdeContext?.base64Encoder ?? toBase64)(value);\n            }\n            else if (ns.isTimestampSchema() && value instanceof Date) {\n                const options = this.settings.timestampFormat;\n                const format = options.useTrait\n                    ? ns.getSchema() === SCHEMA.TIMESTAMP_DEFAULT\n                        ? options.default\n                        : ns.getSchema() ?? options.default\n                    : options.default;\n                switch (format) {\n                    case SCHEMA.TIMESTAMP_DATE_TIME:\n                        nodeContents = value.toISOString().replace(\".000Z\", \"Z\");\n                        break;\n                    case SCHEMA.TIMESTAMP_HTTP_DATE:\n                        nodeContents = dateToUtcString(value);\n                        break;\n                    case SCHEMA.TIMESTAMP_EPOCH_SECONDS:\n                        nodeContents = String(value.getTime() / 1000);\n                        break;\n                    default:\n                        console.warn(\"Missing timestamp format, using http date\", value);\n                        nodeContents = dateToUtcString(value);\n                        break;\n                }\n            }\n            else if (ns.isBigDecimalSchema() && value) {\n                if (value instanceof NumericValue) {\n                    return value.string;\n                }\n                return String(value);\n            }\n            else if (ns.isMapSchema() || ns.isListSchema()) {\n                throw new Error(\"@aws-sdk/core/protocols - xml serializer, cannot call _write() on List/Map schema, call writeList or writeMap() instead.\");\n            }\n            else {\n                throw new Error(`@aws-sdk/core/protocols - xml serializer, unhandled schema type for object value and schema: ${ns.getName(true)}`);\n            }\n        }\n        if (ns.isStringSchema() ||\n            ns.isBooleanSchema() ||\n            ns.isNumericSchema() ||\n            ns.isBigIntegerSchema() ||\n            ns.isBigDecimalSchema()) {\n            nodeContents = String(value);\n        }\n        if (nodeContents === null) {\n            throw new Error(`Unhandled schema-value pair ${ns.getName(true)}=${value}`);\n        }\n        return nodeContents;\n    }\n    writeSimpleInto(_schema, value, into, parentXmlns) {\n        const nodeContents = this.writeSimple(_schema, value);\n        const ns = NormalizedSchema.of(_schema);\n        const content = new XmlText(nodeContents);\n        const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);\n        if (xmlns) {\n            into.addAttribute(xmlnsAttr, xmlns);\n        }\n        into.addChildNode(content);\n    }\n    getXmlnsAttribute(ns, parentXmlns) {\n        const traits = ns.getMergedTraits();\n        const [prefix, xmlns] = traits.xmlNamespace ?? [];\n        if (xmlns && xmlns !== parentXmlns) {\n            return [prefix ? `xmlns:${prefix}` : \"xmlns\", xmlns];\n        }\n        return [void 0, void 0];\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
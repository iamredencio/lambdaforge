{"ast":null,"code":"import _objectSpread from \"/Users/codinggents/Documents/lambdaforge/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { debugId, toDebugString } from \"../debug\";\nimport { evaluateCondition } from \"./evaluateCondition\";\nexport const evaluateConditions = function () {\n  let conditions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let options = arguments.length > 1 ? arguments[1] : undefined;\n  const conditionsReferenceRecord = {};\n  for (const condition of conditions) {\n    const {\n      result,\n      toAssign\n    } = evaluateCondition(condition, _objectSpread(_objectSpread({}, options), {}, {\n      referenceRecord: _objectSpread(_objectSpread({}, options.referenceRecord), conditionsReferenceRecord)\n    }));\n    if (!result) {\n      return {\n        result\n      };\n    }\n    if (toAssign) {\n      var _options$logger, _options$logger$debug;\n      conditionsReferenceRecord[toAssign.name] = toAssign.value;\n      (_options$logger = options.logger) === null || _options$logger === void 0 || (_options$logger$debug = _options$logger.debug) === null || _options$logger$debug === void 0 || _options$logger$debug.call(_options$logger, \"\".concat(debugId, \" assign: \").concat(toAssign.name, \" := \").concat(toDebugString(toAssign.value)));\n    }\n  }\n  return {\n    result: true,\n    referenceRecord: conditionsReferenceRecord\n  };\n};","map":{"version":3,"names":["debugId","toDebugString","evaluateCondition","evaluateConditions","conditions","arguments","length","undefined","options","conditionsReferenceRecord","condition","result","toAssign","_objectSpread","referenceRecord","_options$logger","_options$logger$debug","name","value","logger","debug","call","concat"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/@smithy/util-endpoints/dist-es/utils/evaluateConditions.js"],"sourcesContent":["import { debugId, toDebugString } from \"../debug\";\nimport { evaluateCondition } from \"./evaluateCondition\";\nexport const evaluateConditions = (conditions = [], options) => {\n    const conditionsReferenceRecord = {};\n    for (const condition of conditions) {\n        const { result, toAssign } = evaluateCondition(condition, {\n            ...options,\n            referenceRecord: {\n                ...options.referenceRecord,\n                ...conditionsReferenceRecord,\n            },\n        });\n        if (!result) {\n            return { result };\n        }\n        if (toAssign) {\n            conditionsReferenceRecord[toAssign.name] = toAssign.value;\n            options.logger?.debug?.(`${debugId} assign: ${toAssign.name} := ${toDebugString(toAssign.value)}`);\n        }\n    }\n    return { result: true, referenceRecord: conditionsReferenceRecord };\n};\n"],"mappings":";AAAA,SAASA,OAAO,EAAEC,aAAa,QAAQ,UAAU;AACjD,SAASC,iBAAiB,QAAQ,qBAAqB;AACvD,OAAO,MAAMC,kBAAkB,GAAG,SAAAA,CAAA,EAA8B;EAAA,IAA7BC,UAAU,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,EAAE;EAAA,IAAEG,OAAO,GAAAH,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EACvD,MAAME,yBAAyB,GAAG,CAAC,CAAC;EACpC,KAAK,MAAMC,SAAS,IAAIN,UAAU,EAAE;IAChC,MAAM;MAAEO,MAAM;MAAEC;IAAS,CAAC,GAAGV,iBAAiB,CAACQ,SAAS,EAAAG,aAAA,CAAAA,aAAA,KACjDL,OAAO;MACVM,eAAe,EAAAD,aAAA,CAAAA,aAAA,KACRL,OAAO,CAACM,eAAe,GACvBL,yBAAyB;IAC/B,EACJ,CAAC;IACF,IAAI,CAACE,MAAM,EAAE;MACT,OAAO;QAAEA;MAAO,CAAC;IACrB;IACA,IAAIC,QAAQ,EAAE;MAAA,IAAAG,eAAA,EAAAC,qBAAA;MACVP,yBAAyB,CAACG,QAAQ,CAACK,IAAI,CAAC,GAAGL,QAAQ,CAACM,KAAK;MACzD,CAAAH,eAAA,GAAAP,OAAO,CAACW,MAAM,cAAAJ,eAAA,gBAAAC,qBAAA,GAAdD,eAAA,CAAgBK,KAAK,cAAAJ,qBAAA,eAArBA,qBAAA,CAAAK,IAAA,CAAAN,eAAA,KAAAO,MAAA,CAA2BtB,OAAO,eAAAsB,MAAA,CAAYV,QAAQ,CAACK,IAAI,UAAAK,MAAA,CAAOrB,aAAa,CAACW,QAAQ,CAACM,KAAK,CAAC,CAAE,CAAC;IACtG;EACJ;EACA,OAAO;IAAEP,MAAM,EAAE,IAAI;IAAEG,eAAe,EAAEL;EAA0B,CAAC;AACvE,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
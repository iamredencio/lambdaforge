{"ast":null,"code":"import _objectSpread from \"/Users/codinggents/Documents/lambdaforge/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { NormalizedSchema, SCHEMA } from \"@smithy/core/schema\";\nimport { HttpRequest } from \"@smithy/protocol-http\";\nimport { collectBody } from \"./collect-stream-body\";\nimport { extendedEncodeURIComponent } from \"./extended-encode-uri-component\";\nimport { HttpProtocol } from \"./HttpProtocol\";\nexport class HttpBindingProtocol extends HttpProtocol {\n  async serializeRequest(operationSchema, input, context) {\n    const serializer = this.serializer;\n    const query = {};\n    const headers = {};\n    const endpoint = await context.endpoint();\n    const ns = NormalizedSchema.of(operationSchema === null || operationSchema === void 0 ? void 0 : operationSchema.input);\n    const schema = ns.getSchema();\n    let hasNonHttpBindingMember = false;\n    let payload;\n    const request = new HttpRequest({\n      protocol: \"\",\n      hostname: \"\",\n      port: undefined,\n      path: \"\",\n      fragment: undefined,\n      query: query,\n      headers: headers,\n      body: undefined\n    });\n    if (endpoint) {\n      this.updateServiceEndpoint(request, endpoint);\n      this.setHostPrefix(request, operationSchema, input);\n      const opTraits = NormalizedSchema.translateTraits(operationSchema.traits);\n      if (opTraits.http) {\n        request.method = opTraits.http[0];\n        const [path, search] = opTraits.http[1].split(\"?\");\n        if (request.path == \"/\") {\n          request.path = path;\n        } else {\n          request.path += path;\n        }\n        const traitSearchParams = new URLSearchParams(search !== null && search !== void 0 ? search : \"\");\n        Object.assign(query, Object.fromEntries(traitSearchParams));\n      }\n    }\n    const _input = _objectSpread({}, input);\n    for (const memberName of Object.keys(_input)) {\n      const memberNs = ns.getMemberSchema(memberName);\n      if (memberNs === undefined) {\n        continue;\n      }\n      const memberTraits = memberNs.getMergedTraits();\n      const inputMember = _input[memberName];\n      if (memberTraits.httpPayload) {\n        const isStreaming = memberNs.isStreaming();\n        if (isStreaming) {\n          const isEventStream = memberNs.isStructSchema();\n          if (isEventStream) {\n            throw new Error(\"serialization of event streams is not yet implemented\");\n          } else {\n            payload = inputMember;\n          }\n        } else {\n          serializer.write(memberNs, inputMember);\n          payload = serializer.flush();\n        }\n      } else if (memberTraits.httpLabel) {\n        serializer.write(memberNs, inputMember);\n        const replacement = serializer.flush();\n        if (request.path.includes(\"{\".concat(memberName, \"+}\"))) {\n          request.path = request.path.replace(\"{\".concat(memberName, \"+}\"), replacement.split(\"/\").map(extendedEncodeURIComponent).join(\"/\"));\n        } else if (request.path.includes(\"{\".concat(memberName, \"}\"))) {\n          request.path = request.path.replace(\"{\".concat(memberName, \"}\"), extendedEncodeURIComponent(replacement));\n        }\n        delete _input[memberName];\n      } else if (memberTraits.httpHeader) {\n        serializer.write(memberNs, inputMember);\n        headers[memberTraits.httpHeader.toLowerCase()] = String(serializer.flush());\n        delete _input[memberName];\n      } else if (typeof memberTraits.httpPrefixHeaders === \"string\") {\n        for (const [key, val] of Object.entries(inputMember)) {\n          const amalgam = memberTraits.httpPrefixHeaders + key;\n          serializer.write([memberNs.getValueSchema(), {\n            httpHeader: amalgam\n          }], val);\n          headers[amalgam.toLowerCase()] = serializer.flush();\n        }\n        delete _input[memberName];\n      } else if (memberTraits.httpQuery || memberTraits.httpQueryParams) {\n        this.serializeQuery(memberNs, inputMember, query);\n        delete _input[memberName];\n      } else {\n        hasNonHttpBindingMember = true;\n      }\n    }\n    if (hasNonHttpBindingMember && input) {\n      serializer.write(schema, _input);\n      payload = serializer.flush();\n    }\n    request.headers = headers;\n    request.query = query;\n    request.body = payload;\n    return request;\n  }\n  serializeQuery(ns, data, query) {\n    const serializer = this.serializer;\n    const traits = ns.getMergedTraits();\n    if (traits.httpQueryParams) {\n      for (const [key, val] of Object.entries(data)) {\n        if (!(key in query)) {\n          this.serializeQuery(NormalizedSchema.of([ns.getValueSchema(), _objectSpread(_objectSpread({}, traits), {}, {\n            httpQuery: key,\n            httpQueryParams: undefined\n          })]), val, query);\n        }\n      }\n      return;\n    }\n    if (ns.isListSchema()) {\n      const sparse = !!ns.getMergedTraits().sparse;\n      const buffer = [];\n      for (const item of data) {\n        serializer.write([ns.getValueSchema(), traits], item);\n        const serializable = serializer.flush();\n        if (sparse || serializable !== undefined) {\n          buffer.push(serializable);\n        }\n      }\n      query[traits.httpQuery] = buffer;\n    } else {\n      serializer.write([ns, traits], data);\n      query[traits.httpQuery] = serializer.flush();\n    }\n  }\n  async deserializeResponse(operationSchema, context, response) {\n    const deserializer = this.deserializer;\n    const ns = NormalizedSchema.of(operationSchema.output);\n    const dataObject = {};\n    if (response.statusCode >= 300) {\n      const bytes = await collectBody(response.body, context);\n      if (bytes.byteLength > 0) {\n        Object.assign(dataObject, await deserializer.read(SCHEMA.DOCUMENT, bytes));\n      }\n      await this.handleError(operationSchema, context, response, dataObject, this.deserializeMetadata(response));\n      throw new Error(\"@smithy/core/protocols - HTTP Protocol error handler failed to throw.\");\n    }\n    for (const header in response.headers) {\n      const value = response.headers[header];\n      delete response.headers[header];\n      response.headers[header.toLowerCase()] = value;\n    }\n    const nonHttpBindingMembers = await this.deserializeHttpMessage(ns, context, response, dataObject);\n    if (nonHttpBindingMembers.length) {\n      const bytes = await collectBody(response.body, context);\n      if (bytes.byteLength > 0) {\n        const dataFromBody = await deserializer.read(ns, bytes);\n        for (const member of nonHttpBindingMembers) {\n          dataObject[member] = dataFromBody[member];\n        }\n      }\n    }\n    const output = _objectSpread({\n      $metadata: this.deserializeMetadata(response)\n    }, dataObject);\n    return output;\n  }\n}","map":{"version":3,"names":["NormalizedSchema","SCHEMA","HttpRequest","collectBody","extendedEncodeURIComponent","HttpProtocol","HttpBindingProtocol","serializeRequest","operationSchema","input","context","serializer","query","headers","endpoint","ns","of","schema","getSchema","hasNonHttpBindingMember","payload","request","protocol","hostname","port","undefined","path","fragment","body","updateServiceEndpoint","setHostPrefix","opTraits","translateTraits","traits","http","method","search","split","traitSearchParams","URLSearchParams","Object","assign","fromEntries","_input","_objectSpread","memberName","keys","memberNs","getMemberSchema","memberTraits","getMergedTraits","inputMember","httpPayload","isStreaming","isEventStream","isStructSchema","Error","write","flush","httpLabel","replacement","includes","concat","replace","map","join","httpHeader","toLowerCase","String","httpPrefixHeaders","key","val","entries","amalgam","getValueSchema","httpQuery","httpQueryParams","serializeQuery","data","isListSchema","sparse","buffer","item","serializable","push","deserializeResponse","response","deserializer","output","dataObject","statusCode","bytes","byteLength","read","DOCUMENT","handleError","deserializeMetadata","header","value","nonHttpBindingMembers","deserializeHttpMessage","length","dataFromBody","member","$metadata"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/@smithy/core/dist-es/submodules/protocols/HttpBindingProtocol.js"],"sourcesContent":["import { NormalizedSchema, SCHEMA } from \"@smithy/core/schema\";\nimport { HttpRequest } from \"@smithy/protocol-http\";\nimport { collectBody } from \"./collect-stream-body\";\nimport { extendedEncodeURIComponent } from \"./extended-encode-uri-component\";\nimport { HttpProtocol } from \"./HttpProtocol\";\nexport class HttpBindingProtocol extends HttpProtocol {\n    async serializeRequest(operationSchema, input, context) {\n        const serializer = this.serializer;\n        const query = {};\n        const headers = {};\n        const endpoint = await context.endpoint();\n        const ns = NormalizedSchema.of(operationSchema?.input);\n        const schema = ns.getSchema();\n        let hasNonHttpBindingMember = false;\n        let payload;\n        const request = new HttpRequest({\n            protocol: \"\",\n            hostname: \"\",\n            port: undefined,\n            path: \"\",\n            fragment: undefined,\n            query: query,\n            headers: headers,\n            body: undefined,\n        });\n        if (endpoint) {\n            this.updateServiceEndpoint(request, endpoint);\n            this.setHostPrefix(request, operationSchema, input);\n            const opTraits = NormalizedSchema.translateTraits(operationSchema.traits);\n            if (opTraits.http) {\n                request.method = opTraits.http[0];\n                const [path, search] = opTraits.http[1].split(\"?\");\n                if (request.path == \"/\") {\n                    request.path = path;\n                }\n                else {\n                    request.path += path;\n                }\n                const traitSearchParams = new URLSearchParams(search ?? \"\");\n                Object.assign(query, Object.fromEntries(traitSearchParams));\n            }\n        }\n        const _input = {\n            ...input,\n        };\n        for (const memberName of Object.keys(_input)) {\n            const memberNs = ns.getMemberSchema(memberName);\n            if (memberNs === undefined) {\n                continue;\n            }\n            const memberTraits = memberNs.getMergedTraits();\n            const inputMember = _input[memberName];\n            if (memberTraits.httpPayload) {\n                const isStreaming = memberNs.isStreaming();\n                if (isStreaming) {\n                    const isEventStream = memberNs.isStructSchema();\n                    if (isEventStream) {\n                        throw new Error(\"serialization of event streams is not yet implemented\");\n                    }\n                    else {\n                        payload = inputMember;\n                    }\n                }\n                else {\n                    serializer.write(memberNs, inputMember);\n                    payload = serializer.flush();\n                }\n            }\n            else if (memberTraits.httpLabel) {\n                serializer.write(memberNs, inputMember);\n                const replacement = serializer.flush();\n                if (request.path.includes(`{${memberName}+}`)) {\n                    request.path = request.path.replace(`{${memberName}+}`, replacement.split(\"/\").map(extendedEncodeURIComponent).join(\"/\"));\n                }\n                else if (request.path.includes(`{${memberName}}`)) {\n                    request.path = request.path.replace(`{${memberName}}`, extendedEncodeURIComponent(replacement));\n                }\n                delete _input[memberName];\n            }\n            else if (memberTraits.httpHeader) {\n                serializer.write(memberNs, inputMember);\n                headers[memberTraits.httpHeader.toLowerCase()] = String(serializer.flush());\n                delete _input[memberName];\n            }\n            else if (typeof memberTraits.httpPrefixHeaders === \"string\") {\n                for (const [key, val] of Object.entries(inputMember)) {\n                    const amalgam = memberTraits.httpPrefixHeaders + key;\n                    serializer.write([memberNs.getValueSchema(), { httpHeader: amalgam }], val);\n                    headers[amalgam.toLowerCase()] = serializer.flush();\n                }\n                delete _input[memberName];\n            }\n            else if (memberTraits.httpQuery || memberTraits.httpQueryParams) {\n                this.serializeQuery(memberNs, inputMember, query);\n                delete _input[memberName];\n            }\n            else {\n                hasNonHttpBindingMember = true;\n            }\n        }\n        if (hasNonHttpBindingMember && input) {\n            serializer.write(schema, _input);\n            payload = serializer.flush();\n        }\n        request.headers = headers;\n        request.query = query;\n        request.body = payload;\n        return request;\n    }\n    serializeQuery(ns, data, query) {\n        const serializer = this.serializer;\n        const traits = ns.getMergedTraits();\n        if (traits.httpQueryParams) {\n            for (const [key, val] of Object.entries(data)) {\n                if (!(key in query)) {\n                    this.serializeQuery(NormalizedSchema.of([\n                        ns.getValueSchema(),\n                        {\n                            ...traits,\n                            httpQuery: key,\n                            httpQueryParams: undefined,\n                        },\n                    ]), val, query);\n                }\n            }\n            return;\n        }\n        if (ns.isListSchema()) {\n            const sparse = !!ns.getMergedTraits().sparse;\n            const buffer = [];\n            for (const item of data) {\n                serializer.write([ns.getValueSchema(), traits], item);\n                const serializable = serializer.flush();\n                if (sparse || serializable !== undefined) {\n                    buffer.push(serializable);\n                }\n            }\n            query[traits.httpQuery] = buffer;\n        }\n        else {\n            serializer.write([ns, traits], data);\n            query[traits.httpQuery] = serializer.flush();\n        }\n    }\n    async deserializeResponse(operationSchema, context, response) {\n        const deserializer = this.deserializer;\n        const ns = NormalizedSchema.of(operationSchema.output);\n        const dataObject = {};\n        if (response.statusCode >= 300) {\n            const bytes = await collectBody(response.body, context);\n            if (bytes.byteLength > 0) {\n                Object.assign(dataObject, await deserializer.read(SCHEMA.DOCUMENT, bytes));\n            }\n            await this.handleError(operationSchema, context, response, dataObject, this.deserializeMetadata(response));\n            throw new Error(\"@smithy/core/protocols - HTTP Protocol error handler failed to throw.\");\n        }\n        for (const header in response.headers) {\n            const value = response.headers[header];\n            delete response.headers[header];\n            response.headers[header.toLowerCase()] = value;\n        }\n        const nonHttpBindingMembers = await this.deserializeHttpMessage(ns, context, response, dataObject);\n        if (nonHttpBindingMembers.length) {\n            const bytes = await collectBody(response.body, context);\n            if (bytes.byteLength > 0) {\n                const dataFromBody = await deserializer.read(ns, bytes);\n                for (const member of nonHttpBindingMembers) {\n                    dataObject[member] = dataFromBody[member];\n                }\n            }\n        }\n        const output = {\n            $metadata: this.deserializeMetadata(response),\n            ...dataObject,\n        };\n        return output;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
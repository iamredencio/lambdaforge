{"ast":null,"code":"import _defineProperty from \"/Users/codinggents/Documents/lambdaforge/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { determineTimestampFormat, extendedEncodeURIComponent } from \"@smithy/core/protocols\";\nimport { NormalizedSchema, SCHEMA } from \"@smithy/core/schema\";\nimport { NumericValue } from \"@smithy/core/serde\";\nimport { dateToUtcString } from \"@smithy/smithy-client\";\nimport { toBase64 } from \"@smithy/util-base64\";\nimport { SerdeContextConfig } from \"../ConfigurableSerdeContext\";\nexport class QueryShapeSerializer extends SerdeContextConfig {\n  constructor(settings) {\n    super();\n    _defineProperty(this, \"settings\", void 0);\n    _defineProperty(this, \"buffer\", void 0);\n    this.settings = settings;\n  }\n  write(schema, value) {\n    let prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    if (this.buffer === undefined) {\n      this.buffer = \"\";\n    }\n    const ns = NormalizedSchema.of(schema);\n    if (prefix && !prefix.endsWith(\".\")) {\n      prefix += \".\";\n    }\n    if (ns.isBlobSchema()) {\n      if (typeof value === \"string\" || value instanceof Uint8Array) {\n        var _this$serdeContext$ba, _this$serdeContext;\n        this.writeKey(prefix);\n        this.writeValue(((_this$serdeContext$ba = (_this$serdeContext = this.serdeContext) === null || _this$serdeContext === void 0 ? void 0 : _this$serdeContext.base64Encoder) !== null && _this$serdeContext$ba !== void 0 ? _this$serdeContext$ba : toBase64)(value));\n      }\n    } else if (ns.isBooleanSchema() || ns.isNumericSchema() || ns.isStringSchema()) {\n      if (value != null) {\n        this.writeKey(prefix);\n        this.writeValue(String(value));\n      }\n    } else if (ns.isBigIntegerSchema()) {\n      if (value != null) {\n        this.writeKey(prefix);\n        this.writeValue(String(value));\n      }\n    } else if (ns.isBigDecimalSchema()) {\n      if (value != null) {\n        this.writeKey(prefix);\n        this.writeValue(value instanceof NumericValue ? value.string : String(value));\n      }\n    } else if (ns.isTimestampSchema()) {\n      if (value instanceof Date) {\n        this.writeKey(prefix);\n        const format = determineTimestampFormat(ns, this.settings);\n        switch (format) {\n          case SCHEMA.TIMESTAMP_DATE_TIME:\n            this.writeValue(value.toISOString().replace(\".000Z\", \"Z\"));\n            break;\n          case SCHEMA.TIMESTAMP_HTTP_DATE:\n            this.writeValue(dateToUtcString(value));\n            break;\n          case SCHEMA.TIMESTAMP_EPOCH_SECONDS:\n            this.writeValue(String(value.getTime() / 1000));\n            break;\n        }\n      }\n    } else if (ns.isDocumentSchema()) {\n      throw new Error(\"@aws-sdk/core/protocols - QuerySerializer unsupported document type \".concat(ns.getName(true)));\n    } else if (ns.isListSchema()) {\n      if (Array.isArray(value)) {\n        if (value.length === 0) {\n          if (this.settings.serializeEmptyLists) {\n            this.writeKey(prefix);\n            this.writeValue(\"\");\n          }\n        } else {\n          const member = ns.getValueSchema();\n          const flat = this.settings.flattenLists || ns.getMergedTraits().xmlFlattened;\n          let i = 1;\n          for (const item of value) {\n            if (item == null) {\n              continue;\n            }\n            const suffix = this.getKey(\"member\", member.getMergedTraits().xmlName);\n            const key = flat ? \"\".concat(prefix).concat(i) : \"\".concat(prefix).concat(suffix, \".\").concat(i);\n            this.write(member, item, key);\n            ++i;\n          }\n        }\n      }\n    } else if (ns.isMapSchema()) {\n      if (value && typeof value === \"object\") {\n        const keySchema = ns.getKeySchema();\n        const memberSchema = ns.getValueSchema();\n        const flat = ns.getMergedTraits().xmlFlattened;\n        let i = 1;\n        for (const [k, v] of Object.entries(value)) {\n          if (v == null) {\n            continue;\n          }\n          const keySuffix = this.getKey(\"key\", keySchema.getMergedTraits().xmlName);\n          const key = flat ? \"\".concat(prefix).concat(i, \".\").concat(keySuffix) : \"\".concat(prefix, \"entry.\").concat(i, \".\").concat(keySuffix);\n          const valueSuffix = this.getKey(\"value\", memberSchema.getMergedTraits().xmlName);\n          const valueKey = flat ? \"\".concat(prefix).concat(i, \".\").concat(valueSuffix) : \"\".concat(prefix, \"entry.\").concat(i, \".\").concat(valueSuffix);\n          this.write(keySchema, k, key);\n          this.write(memberSchema, v, valueKey);\n          ++i;\n        }\n      }\n    } else if (ns.isStructSchema()) {\n      if (value && typeof value === \"object\") {\n        for (const [memberName, member] of ns.structIterator()) {\n          if (value[memberName] == null) {\n            continue;\n          }\n          const suffix = this.getKey(memberName, member.getMergedTraits().xmlName);\n          const key = \"\".concat(prefix).concat(suffix);\n          this.write(member, value[memberName], key);\n        }\n      }\n    } else if (ns.isUnitSchema()) {} else {\n      throw new Error(\"@aws-sdk/core/protocols - QuerySerializer unrecognized schema type \".concat(ns.getName(true)));\n    }\n  }\n  flush() {\n    if (this.buffer === undefined) {\n      throw new Error(\"@aws-sdk/core/protocols - QuerySerializer cannot flush with nothing written to buffer.\");\n    }\n    const str = this.buffer;\n    delete this.buffer;\n    return str;\n  }\n  getKey(memberName, xmlName) {\n    const key = xmlName !== null && xmlName !== void 0 ? xmlName : memberName;\n    if (this.settings.capitalizeKeys) {\n      return key[0].toUpperCase() + key.slice(1);\n    }\n    return key;\n  }\n  writeKey(key) {\n    if (key.endsWith(\".\")) {\n      key = key.slice(0, key.length - 1);\n    }\n    this.buffer += \"&\".concat(extendedEncodeURIComponent(key), \"=\");\n  }\n  writeValue(value) {\n    this.buffer += extendedEncodeURIComponent(value);\n  }\n}","map":{"version":3,"names":["determineTimestampFormat","extendedEncodeURIComponent","NormalizedSchema","SCHEMA","NumericValue","dateToUtcString","toBase64","SerdeContextConfig","QueryShapeSerializer","constructor","settings","_defineProperty","write","schema","value","prefix","arguments","length","undefined","buffer","ns","of","endsWith","isBlobSchema","Uint8Array","_this$serdeContext$ba","_this$serdeContext","writeKey","writeValue","serdeContext","base64Encoder","isBooleanSchema","isNumericSchema","isStringSchema","String","isBigIntegerSchema","isBigDecimalSchema","string","isTimestampSchema","Date","format","TIMESTAMP_DATE_TIME","toISOString","replace","TIMESTAMP_HTTP_DATE","TIMESTAMP_EPOCH_SECONDS","getTime","isDocumentSchema","Error","concat","getName","isListSchema","Array","isArray","serializeEmptyLists","member","getValueSchema","flat","flattenLists","getMergedTraits","xmlFlattened","i","item","suffix","getKey","xmlName","key","isMapSchema","keySchema","getKeySchema","memberSchema","k","v","Object","entries","keySuffix","valueSuffix","valueKey","isStructSchema","memberName","structIterator","isUnitSchema","flush","str","capitalizeKeys","toUpperCase","slice"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/@aws-sdk/core/dist-es/submodules/protocols/query/QueryShapeSerializer.js"],"sourcesContent":["import { determineTimestampFormat, extendedEncodeURIComponent } from \"@smithy/core/protocols\";\nimport { NormalizedSchema, SCHEMA } from \"@smithy/core/schema\";\nimport { NumericValue } from \"@smithy/core/serde\";\nimport { dateToUtcString } from \"@smithy/smithy-client\";\nimport { toBase64 } from \"@smithy/util-base64\";\nimport { SerdeContextConfig } from \"../ConfigurableSerdeContext\";\nexport class QueryShapeSerializer extends SerdeContextConfig {\n    settings;\n    buffer;\n    constructor(settings) {\n        super();\n        this.settings = settings;\n    }\n    write(schema, value, prefix = \"\") {\n        if (this.buffer === undefined) {\n            this.buffer = \"\";\n        }\n        const ns = NormalizedSchema.of(schema);\n        if (prefix && !prefix.endsWith(\".\")) {\n            prefix += \".\";\n        }\n        if (ns.isBlobSchema()) {\n            if (typeof value === \"string\" || value instanceof Uint8Array) {\n                this.writeKey(prefix);\n                this.writeValue((this.serdeContext?.base64Encoder ?? toBase64)(value));\n            }\n        }\n        else if (ns.isBooleanSchema() || ns.isNumericSchema() || ns.isStringSchema()) {\n            if (value != null) {\n                this.writeKey(prefix);\n                this.writeValue(String(value));\n            }\n        }\n        else if (ns.isBigIntegerSchema()) {\n            if (value != null) {\n                this.writeKey(prefix);\n                this.writeValue(String(value));\n            }\n        }\n        else if (ns.isBigDecimalSchema()) {\n            if (value != null) {\n                this.writeKey(prefix);\n                this.writeValue(value instanceof NumericValue ? value.string : String(value));\n            }\n        }\n        else if (ns.isTimestampSchema()) {\n            if (value instanceof Date) {\n                this.writeKey(prefix);\n                const format = determineTimestampFormat(ns, this.settings);\n                switch (format) {\n                    case SCHEMA.TIMESTAMP_DATE_TIME:\n                        this.writeValue(value.toISOString().replace(\".000Z\", \"Z\"));\n                        break;\n                    case SCHEMA.TIMESTAMP_HTTP_DATE:\n                        this.writeValue(dateToUtcString(value));\n                        break;\n                    case SCHEMA.TIMESTAMP_EPOCH_SECONDS:\n                        this.writeValue(String(value.getTime() / 1000));\n                        break;\n                }\n            }\n        }\n        else if (ns.isDocumentSchema()) {\n            throw new Error(`@aws-sdk/core/protocols - QuerySerializer unsupported document type ${ns.getName(true)}`);\n        }\n        else if (ns.isListSchema()) {\n            if (Array.isArray(value)) {\n                if (value.length === 0) {\n                    if (this.settings.serializeEmptyLists) {\n                        this.writeKey(prefix);\n                        this.writeValue(\"\");\n                    }\n                }\n                else {\n                    const member = ns.getValueSchema();\n                    const flat = this.settings.flattenLists || ns.getMergedTraits().xmlFlattened;\n                    let i = 1;\n                    for (const item of value) {\n                        if (item == null) {\n                            continue;\n                        }\n                        const suffix = this.getKey(\"member\", member.getMergedTraits().xmlName);\n                        const key = flat ? `${prefix}${i}` : `${prefix}${suffix}.${i}`;\n                        this.write(member, item, key);\n                        ++i;\n                    }\n                }\n            }\n        }\n        else if (ns.isMapSchema()) {\n            if (value && typeof value === \"object\") {\n                const keySchema = ns.getKeySchema();\n                const memberSchema = ns.getValueSchema();\n                const flat = ns.getMergedTraits().xmlFlattened;\n                let i = 1;\n                for (const [k, v] of Object.entries(value)) {\n                    if (v == null) {\n                        continue;\n                    }\n                    const keySuffix = this.getKey(\"key\", keySchema.getMergedTraits().xmlName);\n                    const key = flat ? `${prefix}${i}.${keySuffix}` : `${prefix}entry.${i}.${keySuffix}`;\n                    const valueSuffix = this.getKey(\"value\", memberSchema.getMergedTraits().xmlName);\n                    const valueKey = flat ? `${prefix}${i}.${valueSuffix}` : `${prefix}entry.${i}.${valueSuffix}`;\n                    this.write(keySchema, k, key);\n                    this.write(memberSchema, v, valueKey);\n                    ++i;\n                }\n            }\n        }\n        else if (ns.isStructSchema()) {\n            if (value && typeof value === \"object\") {\n                for (const [memberName, member] of ns.structIterator()) {\n                    if (value[memberName] == null) {\n                        continue;\n                    }\n                    const suffix = this.getKey(memberName, member.getMergedTraits().xmlName);\n                    const key = `${prefix}${suffix}`;\n                    this.write(member, value[memberName], key);\n                }\n            }\n        }\n        else if (ns.isUnitSchema()) {\n        }\n        else {\n            throw new Error(`@aws-sdk/core/protocols - QuerySerializer unrecognized schema type ${ns.getName(true)}`);\n        }\n    }\n    flush() {\n        if (this.buffer === undefined) {\n            throw new Error(\"@aws-sdk/core/protocols - QuerySerializer cannot flush with nothing written to buffer.\");\n        }\n        const str = this.buffer;\n        delete this.buffer;\n        return str;\n    }\n    getKey(memberName, xmlName) {\n        const key = xmlName ?? memberName;\n        if (this.settings.capitalizeKeys) {\n            return key[0].toUpperCase() + key.slice(1);\n        }\n        return key;\n    }\n    writeKey(key) {\n        if (key.endsWith(\".\")) {\n            key = key.slice(0, key.length - 1);\n        }\n        this.buffer += `&${extendedEncodeURIComponent(key)}=`;\n    }\n    writeValue(value) {\n        this.buffer += extendedEncodeURIComponent(value);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
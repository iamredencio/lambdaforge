{"ast":null,"code":"import { HttpResponse } from \"@smithy/protocol-http\";\nimport { buildQueryString } from \"@smithy/querystring-builder\";\nimport { createRequest } from \"./create-request\";\nimport { requestTimeout } from \"./request-timeout\";\nexport const keepAliveSupport = {\n  supported: undefined\n};\nexport class FetchHttpHandler {\n  static create(instanceOrOptions) {\n    if (typeof (instanceOrOptions === null || instanceOrOptions === void 0 ? void 0 : instanceOrOptions.handle) === \"function\") {\n      return instanceOrOptions;\n    }\n    return new FetchHttpHandler(instanceOrOptions);\n  }\n  constructor(options) {\n    if (typeof options === \"function\") {\n      this.configProvider = options().then(opts => opts || {});\n    } else {\n      this.config = options !== null && options !== void 0 ? options : {};\n      this.configProvider = Promise.resolve(this.config);\n    }\n    if (keepAliveSupport.supported === undefined) {\n      keepAliveSupport.supported = Boolean(typeof Request !== \"undefined\" && \"keepalive\" in createRequest(\"https://[::1]\"));\n    }\n  }\n  destroy() {}\n  async handle(request) {\n    var _this$config;\n    let {\n      abortSignal\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!this.config) {\n      this.config = await this.configProvider;\n    }\n    const requestTimeoutInMs = this.config.requestTimeout;\n    const keepAlive = this.config.keepAlive === true;\n    const credentials = this.config.credentials;\n    if (abortSignal !== null && abortSignal !== void 0 && abortSignal.aborted) {\n      const abortError = new Error(\"Request aborted\");\n      abortError.name = \"AbortError\";\n      return Promise.reject(abortError);\n    }\n    let path = request.path;\n    const queryString = buildQueryString(request.query || {});\n    if (queryString) {\n      path += \"?\".concat(queryString);\n    }\n    if (request.fragment) {\n      path += \"#\".concat(request.fragment);\n    }\n    let auth = \"\";\n    if (request.username != null || request.password != null) {\n      var _request$username, _request$password;\n      const username = (_request$username = request.username) !== null && _request$username !== void 0 ? _request$username : \"\";\n      const password = (_request$password = request.password) !== null && _request$password !== void 0 ? _request$password : \"\";\n      auth = \"\".concat(username, \":\").concat(password, \"@\");\n    }\n    const {\n      port,\n      method\n    } = request;\n    const url = \"\".concat(request.protocol, \"//\").concat(auth).concat(request.hostname).concat(port ? \":\".concat(port) : \"\").concat(path);\n    const body = method === \"GET\" || method === \"HEAD\" ? undefined : request.body;\n    const requestOptions = {\n      body,\n      headers: new Headers(request.headers),\n      method: method,\n      credentials\n    };\n    if ((_this$config = this.config) !== null && _this$config !== void 0 && _this$config.cache) {\n      requestOptions.cache = this.config.cache;\n    }\n    if (body) {\n      requestOptions.duplex = \"half\";\n    }\n    if (typeof AbortController !== \"undefined\") {\n      requestOptions.signal = abortSignal;\n    }\n    if (keepAliveSupport.supported) {\n      requestOptions.keepalive = keepAlive;\n    }\n    if (typeof this.config.requestInit === \"function\") {\n      Object.assign(requestOptions, this.config.requestInit(request));\n    }\n    let removeSignalEventListener = () => {};\n    const fetchRequest = createRequest(url, requestOptions);\n    const raceOfPromises = [fetch(fetchRequest).then(response => {\n      const fetchHeaders = response.headers;\n      const transformedHeaders = {};\n      for (const pair of fetchHeaders.entries()) {\n        transformedHeaders[pair[0]] = pair[1];\n      }\n      const hasReadableStream = response.body != undefined;\n      if (!hasReadableStream) {\n        return response.blob().then(body => ({\n          response: new HttpResponse({\n            headers: transformedHeaders,\n            reason: response.statusText,\n            statusCode: response.status,\n            body\n          })\n        }));\n      }\n      return {\n        response: new HttpResponse({\n          headers: transformedHeaders,\n          reason: response.statusText,\n          statusCode: response.status,\n          body: response.body\n        })\n      };\n    }), requestTimeout(requestTimeoutInMs)];\n    if (abortSignal) {\n      raceOfPromises.push(new Promise((resolve, reject) => {\n        const onAbort = () => {\n          const abortError = new Error(\"Request aborted\");\n          abortError.name = \"AbortError\";\n          reject(abortError);\n        };\n        if (typeof abortSignal.addEventListener === \"function\") {\n          const signal = abortSignal;\n          signal.addEventListener(\"abort\", onAbort, {\n            once: true\n          });\n          removeSignalEventListener = () => signal.removeEventListener(\"abort\", onAbort);\n        } else {\n          abortSignal.onabort = onAbort;\n        }\n      }));\n    }\n    return Promise.race(raceOfPromises).finally(removeSignalEventListener);\n  }\n  updateHttpClientConfig(key, value) {\n    this.config = undefined;\n    this.configProvider = this.configProvider.then(config => {\n      config[key] = value;\n      return config;\n    });\n  }\n  httpHandlerConfigs() {\n    var _this$config2;\n    return (_this$config2 = this.config) !== null && _this$config2 !== void 0 ? _this$config2 : {};\n  }\n}","map":{"version":3,"names":["HttpResponse","buildQueryString","createRequest","requestTimeout","keepAliveSupport","supported","undefined","FetchHttpHandler","create","instanceOrOptions","handle","constructor","options","configProvider","then","opts","config","Promise","resolve","Boolean","Request","destroy","request","_this$config","abortSignal","arguments","length","requestTimeoutInMs","keepAlive","credentials","aborted","abortError","Error","name","reject","path","queryString","query","concat","fragment","auth","username","password","_request$username","_request$password","port","method","url","protocol","hostname","body","requestOptions","headers","Headers","cache","duplex","AbortController","signal","keepalive","requestInit","Object","assign","removeSignalEventListener","fetchRequest","raceOfPromises","fetch","response","fetchHeaders","transformedHeaders","pair","entries","hasReadableStream","blob","reason","statusText","statusCode","status","push","onAbort","addEventListener","once","removeEventListener","onabort","race","finally","updateHttpClientConfig","key","value","httpHandlerConfigs","_this$config2"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/@smithy/fetch-http-handler/dist-es/fetch-http-handler.js"],"sourcesContent":["import { HttpResponse } from \"@smithy/protocol-http\";\nimport { buildQueryString } from \"@smithy/querystring-builder\";\nimport { createRequest } from \"./create-request\";\nimport { requestTimeout } from \"./request-timeout\";\nexport const keepAliveSupport = {\n    supported: undefined,\n};\nexport class FetchHttpHandler {\n    static create(instanceOrOptions) {\n        if (typeof instanceOrOptions?.handle === \"function\") {\n            return instanceOrOptions;\n        }\n        return new FetchHttpHandler(instanceOrOptions);\n    }\n    constructor(options) {\n        if (typeof options === \"function\") {\n            this.configProvider = options().then((opts) => opts || {});\n        }\n        else {\n            this.config = options ?? {};\n            this.configProvider = Promise.resolve(this.config);\n        }\n        if (keepAliveSupport.supported === undefined) {\n            keepAliveSupport.supported = Boolean(typeof Request !== \"undefined\" && \"keepalive\" in createRequest(\"https://[::1]\"));\n        }\n    }\n    destroy() {\n    }\n    async handle(request, { abortSignal } = {}) {\n        if (!this.config) {\n            this.config = await this.configProvider;\n        }\n        const requestTimeoutInMs = this.config.requestTimeout;\n        const keepAlive = this.config.keepAlive === true;\n        const credentials = this.config.credentials;\n        if (abortSignal?.aborted) {\n            const abortError = new Error(\"Request aborted\");\n            abortError.name = \"AbortError\";\n            return Promise.reject(abortError);\n        }\n        let path = request.path;\n        const queryString = buildQueryString(request.query || {});\n        if (queryString) {\n            path += `?${queryString}`;\n        }\n        if (request.fragment) {\n            path += `#${request.fragment}`;\n        }\n        let auth = \"\";\n        if (request.username != null || request.password != null) {\n            const username = request.username ?? \"\";\n            const password = request.password ?? \"\";\n            auth = `${username}:${password}@`;\n        }\n        const { port, method } = request;\n        const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : \"\"}${path}`;\n        const body = method === \"GET\" || method === \"HEAD\" ? undefined : request.body;\n        const requestOptions = {\n            body,\n            headers: new Headers(request.headers),\n            method: method,\n            credentials,\n        };\n        if (this.config?.cache) {\n            requestOptions.cache = this.config.cache;\n        }\n        if (body) {\n            requestOptions.duplex = \"half\";\n        }\n        if (typeof AbortController !== \"undefined\") {\n            requestOptions.signal = abortSignal;\n        }\n        if (keepAliveSupport.supported) {\n            requestOptions.keepalive = keepAlive;\n        }\n        if (typeof this.config.requestInit === \"function\") {\n            Object.assign(requestOptions, this.config.requestInit(request));\n        }\n        let removeSignalEventListener = () => { };\n        const fetchRequest = createRequest(url, requestOptions);\n        const raceOfPromises = [\n            fetch(fetchRequest).then((response) => {\n                const fetchHeaders = response.headers;\n                const transformedHeaders = {};\n                for (const pair of fetchHeaders.entries()) {\n                    transformedHeaders[pair[0]] = pair[1];\n                }\n                const hasReadableStream = response.body != undefined;\n                if (!hasReadableStream) {\n                    return response.blob().then((body) => ({\n                        response: new HttpResponse({\n                            headers: transformedHeaders,\n                            reason: response.statusText,\n                            statusCode: response.status,\n                            body,\n                        }),\n                    }));\n                }\n                return {\n                    response: new HttpResponse({\n                        headers: transformedHeaders,\n                        reason: response.statusText,\n                        statusCode: response.status,\n                        body: response.body,\n                    }),\n                };\n            }),\n            requestTimeout(requestTimeoutInMs),\n        ];\n        if (abortSignal) {\n            raceOfPromises.push(new Promise((resolve, reject) => {\n                const onAbort = () => {\n                    const abortError = new Error(\"Request aborted\");\n                    abortError.name = \"AbortError\";\n                    reject(abortError);\n                };\n                if (typeof abortSignal.addEventListener === \"function\") {\n                    const signal = abortSignal;\n                    signal.addEventListener(\"abort\", onAbort, { once: true });\n                    removeSignalEventListener = () => signal.removeEventListener(\"abort\", onAbort);\n                }\n                else {\n                    abortSignal.onabort = onAbort;\n                }\n            }));\n        }\n        return Promise.race(raceOfPromises).finally(removeSignalEventListener);\n    }\n    updateHttpClientConfig(key, value) {\n        this.config = undefined;\n        this.configProvider = this.configProvider.then((config) => {\n            config[key] = value;\n            return config;\n        });\n    }\n    httpHandlerConfigs() {\n        return this.config ?? {};\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
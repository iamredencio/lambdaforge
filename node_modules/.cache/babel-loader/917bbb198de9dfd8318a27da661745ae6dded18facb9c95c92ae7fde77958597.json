{"ast":null,"code":"import _defineProperty from \"/Users/codinggents/Documents/lambdaforge/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { XmlNode, XmlText } from \"@aws-sdk/xml-builder\";\nimport { NormalizedSchema, SCHEMA } from \"@smithy/core/schema\";\nimport { NumericValue } from \"@smithy/core/serde\";\nimport { dateToUtcString } from \"@smithy/smithy-client\";\nimport { fromBase64, toBase64 } from \"@smithy/util-base64\";\nimport { SerdeContextConfig } from \"../ConfigurableSerdeContext\";\nexport class XmlShapeSerializer extends SerdeContextConfig {\n  constructor(settings) {\n    super();\n    _defineProperty(this, \"settings\", void 0);\n    _defineProperty(this, \"stringBuffer\", void 0);\n    _defineProperty(this, \"byteBuffer\", void 0);\n    _defineProperty(this, \"buffer\", void 0);\n    this.settings = settings;\n  }\n  write(schema, value) {\n    const ns = NormalizedSchema.of(schema);\n    if (ns.isStringSchema() && typeof value === \"string\") {\n      this.stringBuffer = value;\n    } else if (ns.isBlobSchema()) {\n      var _this$serdeContext$ba, _this$serdeContext;\n      this.byteBuffer = \"byteLength\" in value ? value : ((_this$serdeContext$ba = (_this$serdeContext = this.serdeContext) === null || _this$serdeContext === void 0 ? void 0 : _this$serdeContext.base64Decoder) !== null && _this$serdeContext$ba !== void 0 ? _this$serdeContext$ba : fromBase64)(value);\n    } else {\n      this.buffer = this.writeStruct(ns, value, undefined);\n      const traits = ns.getMergedTraits();\n      if (traits.httpPayload && !traits.xmlName) {\n        this.buffer.withName(ns.getName());\n      }\n    }\n  }\n  flush() {\n    if (this.byteBuffer !== undefined) {\n      const bytes = this.byteBuffer;\n      delete this.byteBuffer;\n      return bytes;\n    }\n    if (this.stringBuffer !== undefined) {\n      const str = this.stringBuffer;\n      delete this.stringBuffer;\n      return str;\n    }\n    const buffer = this.buffer;\n    if (this.settings.xmlNamespace) {\n      var _buffer$attributes;\n      if (!(buffer !== null && buffer !== void 0 && (_buffer$attributes = buffer.attributes) !== null && _buffer$attributes !== void 0 && _buffer$attributes[\"xmlns\"])) {\n        buffer.addAttribute(\"xmlns\", this.settings.xmlNamespace);\n      }\n    }\n    delete this.buffer;\n    return buffer.toString();\n  }\n  writeStruct(ns, value, parentXmlns) {\n    var _ns$getMemberTraits$x, _traits$xmlName;\n    const traits = ns.getMergedTraits();\n    const name = ns.isMemberSchema() && !traits.httpPayload ? (_ns$getMemberTraits$x = ns.getMemberTraits().xmlName) !== null && _ns$getMemberTraits$x !== void 0 ? _ns$getMemberTraits$x : ns.getMemberName() : (_traits$xmlName = traits.xmlName) !== null && _traits$xmlName !== void 0 ? _traits$xmlName : ns.getName();\n    if (!name || !ns.isStructSchema()) {\n      throw new Error(\"@aws-sdk/core/protocols - xml serializer, cannot write struct with empty name or non-struct, schema=\".concat(ns.getName(true), \".\"));\n    }\n    const structXmlNode = XmlNode.of(name);\n    const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);\n    if (xmlns) {\n      structXmlNode.addAttribute(xmlnsAttr, xmlns);\n    }\n    for (const [memberName, memberSchema] of ns.structIterator()) {\n      const val = value[memberName];\n      if (val != null) {\n        if (memberSchema.getMergedTraits().xmlAttribute) {\n          var _memberSchema$getMerg;\n          structXmlNode.addAttribute((_memberSchema$getMerg = memberSchema.getMergedTraits().xmlName) !== null && _memberSchema$getMerg !== void 0 ? _memberSchema$getMerg : memberName, this.writeSimple(memberSchema, val));\n          continue;\n        }\n        if (memberSchema.isListSchema()) {\n          this.writeList(memberSchema, val, structXmlNode, xmlns);\n        } else if (memberSchema.isMapSchema()) {\n          this.writeMap(memberSchema, val, structXmlNode, xmlns);\n        } else if (memberSchema.isStructSchema()) {\n          structXmlNode.addChildNode(this.writeStruct(memberSchema, val, xmlns));\n        } else {\n          var _memberSchema$getMerg2;\n          const memberNode = XmlNode.of((_memberSchema$getMerg2 = memberSchema.getMergedTraits().xmlName) !== null && _memberSchema$getMerg2 !== void 0 ? _memberSchema$getMerg2 : memberSchema.getMemberName());\n          this.writeSimpleInto(memberSchema, val, memberNode, xmlns);\n          structXmlNode.addChildNode(memberNode);\n        }\n      }\n    }\n    return structXmlNode;\n  }\n  writeList(listMember, array, container, parentXmlns) {\n    if (!listMember.isMemberSchema()) {\n      throw new Error(\"@aws-sdk/core/protocols - xml serializer, cannot write non-member list: \".concat(listMember.getName(true)));\n    }\n    const listTraits = listMember.getMergedTraits();\n    const listValueSchema = listMember.getValueSchema();\n    const listValueTraits = listValueSchema.getMergedTraits();\n    const sparse = !!listValueTraits.sparse;\n    const flat = !!listTraits.xmlFlattened;\n    const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(listMember, parentXmlns);\n    const writeItem = (container, value) => {\n      if (listValueSchema.isListSchema()) {\n        this.writeList(listValueSchema, Array.isArray(value) ? value : [value], container, xmlns);\n      } else if (listValueSchema.isMapSchema()) {\n        this.writeMap(listValueSchema, value, container, xmlns);\n      } else if (listValueSchema.isStructSchema()) {\n        var _listTraits$xmlName, _listValueTraits$xmlN;\n        const struct = this.writeStruct(listValueSchema, value, xmlns);\n        container.addChildNode(struct.withName(flat ? (_listTraits$xmlName = listTraits.xmlName) !== null && _listTraits$xmlName !== void 0 ? _listTraits$xmlName : listMember.getMemberName() : (_listValueTraits$xmlN = listValueTraits.xmlName) !== null && _listValueTraits$xmlN !== void 0 ? _listValueTraits$xmlN : \"member\"));\n      } else {\n        var _listTraits$xmlName2, _listValueTraits$xmlN2;\n        const listItemNode = XmlNode.of(flat ? (_listTraits$xmlName2 = listTraits.xmlName) !== null && _listTraits$xmlName2 !== void 0 ? _listTraits$xmlName2 : listMember.getMemberName() : (_listValueTraits$xmlN2 = listValueTraits.xmlName) !== null && _listValueTraits$xmlN2 !== void 0 ? _listValueTraits$xmlN2 : \"member\");\n        this.writeSimpleInto(listValueSchema, value, listItemNode, xmlns);\n        container.addChildNode(listItemNode);\n      }\n    };\n    if (flat) {\n      for (const value of array) {\n        if (sparse || value != null) {\n          writeItem(container, value);\n        }\n      }\n    } else {\n      var _listTraits$xmlName3;\n      const listNode = XmlNode.of((_listTraits$xmlName3 = listTraits.xmlName) !== null && _listTraits$xmlName3 !== void 0 ? _listTraits$xmlName3 : listMember.getMemberName());\n      if (xmlns) {\n        listNode.addAttribute(xmlnsAttr, xmlns);\n      }\n      for (const value of array) {\n        if (sparse || value != null) {\n          writeItem(listNode, value);\n        }\n      }\n      container.addChildNode(listNode);\n    }\n  }\n  writeMap(mapMember, map, container, parentXmlns) {\n    var _mapKeyTraits$xmlName, _mapValueTraits$xmlNa;\n    let containerIsMap = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    if (!mapMember.isMemberSchema()) {\n      throw new Error(\"@aws-sdk/core/protocols - xml serializer, cannot write non-member map: \".concat(mapMember.getName(true)));\n    }\n    const mapTraits = mapMember.getMergedTraits();\n    const mapKeySchema = mapMember.getKeySchema();\n    const mapKeyTraits = mapKeySchema.getMergedTraits();\n    const keyTag = (_mapKeyTraits$xmlName = mapKeyTraits.xmlName) !== null && _mapKeyTraits$xmlName !== void 0 ? _mapKeyTraits$xmlName : \"key\";\n    const mapValueSchema = mapMember.getValueSchema();\n    const mapValueTraits = mapValueSchema.getMergedTraits();\n    const valueTag = (_mapValueTraits$xmlNa = mapValueTraits.xmlName) !== null && _mapValueTraits$xmlNa !== void 0 ? _mapValueTraits$xmlNa : \"value\";\n    const sparse = !!mapValueTraits.sparse;\n    const flat = !!mapTraits.xmlFlattened;\n    const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(mapMember, parentXmlns);\n    const addKeyValue = (entry, key, val) => {\n      const keyNode = XmlNode.of(keyTag, key);\n      const [keyXmlnsAttr, keyXmlns] = this.getXmlnsAttribute(mapKeySchema, xmlns);\n      if (keyXmlns) {\n        keyNode.addAttribute(keyXmlnsAttr, keyXmlns);\n      }\n      entry.addChildNode(keyNode);\n      let valueNode = XmlNode.of(valueTag);\n      if (mapValueSchema.isListSchema()) {\n        this.writeList(mapValueSchema, val, valueNode, xmlns);\n      } else if (mapValueSchema.isMapSchema()) {\n        this.writeMap(mapValueSchema, val, valueNode, xmlns, true);\n      } else if (mapValueSchema.isStructSchema()) {\n        valueNode = this.writeStruct(mapValueSchema, val, xmlns);\n      } else {\n        this.writeSimpleInto(mapValueSchema, val, valueNode, xmlns);\n      }\n      entry.addChildNode(valueNode);\n    };\n    if (flat) {\n      for (const [key, val] of Object.entries(map)) {\n        if (sparse || val != null) {\n          var _mapTraits$xmlName;\n          const entry = XmlNode.of((_mapTraits$xmlName = mapTraits.xmlName) !== null && _mapTraits$xmlName !== void 0 ? _mapTraits$xmlName : mapMember.getMemberName());\n          addKeyValue(entry, key, val);\n          container.addChildNode(entry);\n        }\n      }\n    } else {\n      let mapNode;\n      if (!containerIsMap) {\n        var _mapTraits$xmlName2;\n        mapNode = XmlNode.of((_mapTraits$xmlName2 = mapTraits.xmlName) !== null && _mapTraits$xmlName2 !== void 0 ? _mapTraits$xmlName2 : mapMember.getMemberName());\n        if (xmlns) {\n          mapNode.addAttribute(xmlnsAttr, xmlns);\n        }\n        container.addChildNode(mapNode);\n      }\n      for (const [key, val] of Object.entries(map)) {\n        if (sparse || val != null) {\n          const entry = XmlNode.of(\"entry\");\n          addKeyValue(entry, key, val);\n          (containerIsMap ? container : mapNode).addChildNode(entry);\n        }\n      }\n    }\n  }\n  writeSimple(_schema, value) {\n    if (null === value) {\n      throw new Error(\"@aws-sdk/core/protocols - (XML serializer) cannot write null value.\");\n    }\n    const ns = NormalizedSchema.of(_schema);\n    let nodeContents = null;\n    if (value && typeof value === \"object\") {\n      if (ns.isBlobSchema()) {\n        var _this$serdeContext$ba2, _this$serdeContext2;\n        nodeContents = ((_this$serdeContext$ba2 = (_this$serdeContext2 = this.serdeContext) === null || _this$serdeContext2 === void 0 ? void 0 : _this$serdeContext2.base64Encoder) !== null && _this$serdeContext$ba2 !== void 0 ? _this$serdeContext$ba2 : toBase64)(value);\n      } else if (ns.isTimestampSchema() && value instanceof Date) {\n        var _ns$getSchema;\n        const options = this.settings.timestampFormat;\n        const format = options.useTrait ? ns.getSchema() === SCHEMA.TIMESTAMP_DEFAULT ? options.default : (_ns$getSchema = ns.getSchema()) !== null && _ns$getSchema !== void 0 ? _ns$getSchema : options.default : options.default;\n        switch (format) {\n          case SCHEMA.TIMESTAMP_DATE_TIME:\n            nodeContents = value.toISOString().replace(\".000Z\", \"Z\");\n            break;\n          case SCHEMA.TIMESTAMP_HTTP_DATE:\n            nodeContents = dateToUtcString(value);\n            break;\n          case SCHEMA.TIMESTAMP_EPOCH_SECONDS:\n            nodeContents = String(value.getTime() / 1000);\n            break;\n          default:\n            console.warn(\"Missing timestamp format, using http date\", value);\n            nodeContents = dateToUtcString(value);\n            break;\n        }\n      } else if (ns.isBigDecimalSchema() && value) {\n        if (value instanceof NumericValue) {\n          return value.string;\n        }\n        return String(value);\n      } else if (ns.isMapSchema() || ns.isListSchema()) {\n        throw new Error(\"@aws-sdk/core/protocols - xml serializer, cannot call _write() on List/Map schema, call writeList or writeMap() instead.\");\n      } else {\n        throw new Error(\"@aws-sdk/core/protocols - xml serializer, unhandled schema type for object value and schema: \".concat(ns.getName(true)));\n      }\n    }\n    if (ns.isStringSchema() || ns.isBooleanSchema() || ns.isNumericSchema() || ns.isBigIntegerSchema() || ns.isBigDecimalSchema()) {\n      nodeContents = String(value);\n    }\n    if (nodeContents === null) {\n      throw new Error(\"Unhandled schema-value pair \".concat(ns.getName(true), \"=\").concat(value));\n    }\n    return nodeContents;\n  }\n  writeSimpleInto(_schema, value, into, parentXmlns) {\n    const nodeContents = this.writeSimple(_schema, value);\n    const ns = NormalizedSchema.of(_schema);\n    const content = new XmlText(nodeContents);\n    const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);\n    if (xmlns) {\n      into.addAttribute(xmlnsAttr, xmlns);\n    }\n    into.addChildNode(content);\n  }\n  getXmlnsAttribute(ns, parentXmlns) {\n    var _traits$xmlNamespace;\n    const traits = ns.getMergedTraits();\n    const [prefix, xmlns] = (_traits$xmlNamespace = traits.xmlNamespace) !== null && _traits$xmlNamespace !== void 0 ? _traits$xmlNamespace : [];\n    if (xmlns && xmlns !== parentXmlns) {\n      return [prefix ? \"xmlns:\".concat(prefix) : \"xmlns\", xmlns];\n    }\n    return [void 0, void 0];\n  }\n}","map":{"version":3,"names":["XmlNode","XmlText","NormalizedSchema","SCHEMA","NumericValue","dateToUtcString","fromBase64","toBase64","SerdeContextConfig","XmlShapeSerializer","constructor","settings","_defineProperty","write","schema","value","ns","of","isStringSchema","stringBuffer","isBlobSchema","_this$serdeContext$ba","_this$serdeContext","byteBuffer","serdeContext","base64Decoder","buffer","writeStruct","undefined","traits","getMergedTraits","httpPayload","xmlName","withName","getName","flush","bytes","str","xmlNamespace","_buffer$attributes","attributes","addAttribute","toString","parentXmlns","_ns$getMemberTraits$x","_traits$xmlName","name","isMemberSchema","getMemberTraits","getMemberName","isStructSchema","Error","concat","structXmlNode","xmlnsAttr","xmlns","getXmlnsAttribute","memberName","memberSchema","structIterator","val","xmlAttribute","_memberSchema$getMerg","writeSimple","isListSchema","writeList","isMapSchema","writeMap","addChildNode","_memberSchema$getMerg2","memberNode","writeSimpleInto","listMember","array","container","listTraits","listValueSchema","getValueSchema","listValueTraits","sparse","flat","xmlFlattened","writeItem","Array","isArray","_listTraits$xmlName","_listValueTraits$xmlN","struct","_listTraits$xmlName2","_listValueTraits$xmlN2","listItemNode","_listTraits$xmlName3","listNode","mapMember","map","_mapKeyTraits$xmlName","_mapValueTraits$xmlNa","containerIsMap","arguments","length","mapTraits","mapKeySchema","getKeySchema","mapKeyTraits","keyTag","mapValueSchema","mapValueTraits","valueTag","addKeyValue","entry","key","keyNode","keyXmlnsAttr","keyXmlns","valueNode","Object","entries","_mapTraits$xmlName","mapNode","_mapTraits$xmlName2","_schema","nodeContents","_this$serdeContext$ba2","_this$serdeContext2","base64Encoder","isTimestampSchema","Date","_ns$getSchema","options","timestampFormat","format","useTrait","getSchema","TIMESTAMP_DEFAULT","default","TIMESTAMP_DATE_TIME","toISOString","replace","TIMESTAMP_HTTP_DATE","TIMESTAMP_EPOCH_SECONDS","String","getTime","console","warn","isBigDecimalSchema","string","isBooleanSchema","isNumericSchema","isBigIntegerSchema","into","content","_traits$xmlNamespace","prefix"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/XmlShapeSerializer.js"],"sourcesContent":["import { XmlNode, XmlText } from \"@aws-sdk/xml-builder\";\nimport { NormalizedSchema, SCHEMA } from \"@smithy/core/schema\";\nimport { NumericValue } from \"@smithy/core/serde\";\nimport { dateToUtcString } from \"@smithy/smithy-client\";\nimport { fromBase64, toBase64 } from \"@smithy/util-base64\";\nimport { SerdeContextConfig } from \"../ConfigurableSerdeContext\";\nexport class XmlShapeSerializer extends SerdeContextConfig {\n    settings;\n    stringBuffer;\n    byteBuffer;\n    buffer;\n    constructor(settings) {\n        super();\n        this.settings = settings;\n    }\n    write(schema, value) {\n        const ns = NormalizedSchema.of(schema);\n        if (ns.isStringSchema() && typeof value === \"string\") {\n            this.stringBuffer = value;\n        }\n        else if (ns.isBlobSchema()) {\n            this.byteBuffer =\n                \"byteLength\" in value\n                    ? value\n                    : (this.serdeContext?.base64Decoder ?? fromBase64)(value);\n        }\n        else {\n            this.buffer = this.writeStruct(ns, value, undefined);\n            const traits = ns.getMergedTraits();\n            if (traits.httpPayload && !traits.xmlName) {\n                this.buffer.withName(ns.getName());\n            }\n        }\n    }\n    flush() {\n        if (this.byteBuffer !== undefined) {\n            const bytes = this.byteBuffer;\n            delete this.byteBuffer;\n            return bytes;\n        }\n        if (this.stringBuffer !== undefined) {\n            const str = this.stringBuffer;\n            delete this.stringBuffer;\n            return str;\n        }\n        const buffer = this.buffer;\n        if (this.settings.xmlNamespace) {\n            if (!buffer?.attributes?.[\"xmlns\"]) {\n                buffer.addAttribute(\"xmlns\", this.settings.xmlNamespace);\n            }\n        }\n        delete this.buffer;\n        return buffer.toString();\n    }\n    writeStruct(ns, value, parentXmlns) {\n        const traits = ns.getMergedTraits();\n        const name = ns.isMemberSchema() && !traits.httpPayload\n            ? ns.getMemberTraits().xmlName ?? ns.getMemberName()\n            : traits.xmlName ?? ns.getName();\n        if (!name || !ns.isStructSchema()) {\n            throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write struct with empty name or non-struct, schema=${ns.getName(true)}.`);\n        }\n        const structXmlNode = XmlNode.of(name);\n        const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);\n        if (xmlns) {\n            structXmlNode.addAttribute(xmlnsAttr, xmlns);\n        }\n        for (const [memberName, memberSchema] of ns.structIterator()) {\n            const val = value[memberName];\n            if (val != null) {\n                if (memberSchema.getMergedTraits().xmlAttribute) {\n                    structXmlNode.addAttribute(memberSchema.getMergedTraits().xmlName ?? memberName, this.writeSimple(memberSchema, val));\n                    continue;\n                }\n                if (memberSchema.isListSchema()) {\n                    this.writeList(memberSchema, val, structXmlNode, xmlns);\n                }\n                else if (memberSchema.isMapSchema()) {\n                    this.writeMap(memberSchema, val, structXmlNode, xmlns);\n                }\n                else if (memberSchema.isStructSchema()) {\n                    structXmlNode.addChildNode(this.writeStruct(memberSchema, val, xmlns));\n                }\n                else {\n                    const memberNode = XmlNode.of(memberSchema.getMergedTraits().xmlName ?? memberSchema.getMemberName());\n                    this.writeSimpleInto(memberSchema, val, memberNode, xmlns);\n                    structXmlNode.addChildNode(memberNode);\n                }\n            }\n        }\n        return structXmlNode;\n    }\n    writeList(listMember, array, container, parentXmlns) {\n        if (!listMember.isMemberSchema()) {\n            throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member list: ${listMember.getName(true)}`);\n        }\n        const listTraits = listMember.getMergedTraits();\n        const listValueSchema = listMember.getValueSchema();\n        const listValueTraits = listValueSchema.getMergedTraits();\n        const sparse = !!listValueTraits.sparse;\n        const flat = !!listTraits.xmlFlattened;\n        const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(listMember, parentXmlns);\n        const writeItem = (container, value) => {\n            if (listValueSchema.isListSchema()) {\n                this.writeList(listValueSchema, Array.isArray(value) ? value : [value], container, xmlns);\n            }\n            else if (listValueSchema.isMapSchema()) {\n                this.writeMap(listValueSchema, value, container, xmlns);\n            }\n            else if (listValueSchema.isStructSchema()) {\n                const struct = this.writeStruct(listValueSchema, value, xmlns);\n                container.addChildNode(struct.withName(flat ? listTraits.xmlName ?? listMember.getMemberName() : listValueTraits.xmlName ?? \"member\"));\n            }\n            else {\n                const listItemNode = XmlNode.of(flat ? listTraits.xmlName ?? listMember.getMemberName() : listValueTraits.xmlName ?? \"member\");\n                this.writeSimpleInto(listValueSchema, value, listItemNode, xmlns);\n                container.addChildNode(listItemNode);\n            }\n        };\n        if (flat) {\n            for (const value of array) {\n                if (sparse || value != null) {\n                    writeItem(container, value);\n                }\n            }\n        }\n        else {\n            const listNode = XmlNode.of(listTraits.xmlName ?? listMember.getMemberName());\n            if (xmlns) {\n                listNode.addAttribute(xmlnsAttr, xmlns);\n            }\n            for (const value of array) {\n                if (sparse || value != null) {\n                    writeItem(listNode, value);\n                }\n            }\n            container.addChildNode(listNode);\n        }\n    }\n    writeMap(mapMember, map, container, parentXmlns, containerIsMap = false) {\n        if (!mapMember.isMemberSchema()) {\n            throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member map: ${mapMember.getName(true)}`);\n        }\n        const mapTraits = mapMember.getMergedTraits();\n        const mapKeySchema = mapMember.getKeySchema();\n        const mapKeyTraits = mapKeySchema.getMergedTraits();\n        const keyTag = mapKeyTraits.xmlName ?? \"key\";\n        const mapValueSchema = mapMember.getValueSchema();\n        const mapValueTraits = mapValueSchema.getMergedTraits();\n        const valueTag = mapValueTraits.xmlName ?? \"value\";\n        const sparse = !!mapValueTraits.sparse;\n        const flat = !!mapTraits.xmlFlattened;\n        const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(mapMember, parentXmlns);\n        const addKeyValue = (entry, key, val) => {\n            const keyNode = XmlNode.of(keyTag, key);\n            const [keyXmlnsAttr, keyXmlns] = this.getXmlnsAttribute(mapKeySchema, xmlns);\n            if (keyXmlns) {\n                keyNode.addAttribute(keyXmlnsAttr, keyXmlns);\n            }\n            entry.addChildNode(keyNode);\n            let valueNode = XmlNode.of(valueTag);\n            if (mapValueSchema.isListSchema()) {\n                this.writeList(mapValueSchema, val, valueNode, xmlns);\n            }\n            else if (mapValueSchema.isMapSchema()) {\n                this.writeMap(mapValueSchema, val, valueNode, xmlns, true);\n            }\n            else if (mapValueSchema.isStructSchema()) {\n                valueNode = this.writeStruct(mapValueSchema, val, xmlns);\n            }\n            else {\n                this.writeSimpleInto(mapValueSchema, val, valueNode, xmlns);\n            }\n            entry.addChildNode(valueNode);\n        };\n        if (flat) {\n            for (const [key, val] of Object.entries(map)) {\n                if (sparse || val != null) {\n                    const entry = XmlNode.of(mapTraits.xmlName ?? mapMember.getMemberName());\n                    addKeyValue(entry, key, val);\n                    container.addChildNode(entry);\n                }\n            }\n        }\n        else {\n            let mapNode;\n            if (!containerIsMap) {\n                mapNode = XmlNode.of(mapTraits.xmlName ?? mapMember.getMemberName());\n                if (xmlns) {\n                    mapNode.addAttribute(xmlnsAttr, xmlns);\n                }\n                container.addChildNode(mapNode);\n            }\n            for (const [key, val] of Object.entries(map)) {\n                if (sparse || val != null) {\n                    const entry = XmlNode.of(\"entry\");\n                    addKeyValue(entry, key, val);\n                    (containerIsMap ? container : mapNode).addChildNode(entry);\n                }\n            }\n        }\n    }\n    writeSimple(_schema, value) {\n        if (null === value) {\n            throw new Error(\"@aws-sdk/core/protocols - (XML serializer) cannot write null value.\");\n        }\n        const ns = NormalizedSchema.of(_schema);\n        let nodeContents = null;\n        if (value && typeof value === \"object\") {\n            if (ns.isBlobSchema()) {\n                nodeContents = (this.serdeContext?.base64Encoder ?? toBase64)(value);\n            }\n            else if (ns.isTimestampSchema() && value instanceof Date) {\n                const options = this.settings.timestampFormat;\n                const format = options.useTrait\n                    ? ns.getSchema() === SCHEMA.TIMESTAMP_DEFAULT\n                        ? options.default\n                        : ns.getSchema() ?? options.default\n                    : options.default;\n                switch (format) {\n                    case SCHEMA.TIMESTAMP_DATE_TIME:\n                        nodeContents = value.toISOString().replace(\".000Z\", \"Z\");\n                        break;\n                    case SCHEMA.TIMESTAMP_HTTP_DATE:\n                        nodeContents = dateToUtcString(value);\n                        break;\n                    case SCHEMA.TIMESTAMP_EPOCH_SECONDS:\n                        nodeContents = String(value.getTime() / 1000);\n                        break;\n                    default:\n                        console.warn(\"Missing timestamp format, using http date\", value);\n                        nodeContents = dateToUtcString(value);\n                        break;\n                }\n            }\n            else if (ns.isBigDecimalSchema() && value) {\n                if (value instanceof NumericValue) {\n                    return value.string;\n                }\n                return String(value);\n            }\n            else if (ns.isMapSchema() || ns.isListSchema()) {\n                throw new Error(\"@aws-sdk/core/protocols - xml serializer, cannot call _write() on List/Map schema, call writeList or writeMap() instead.\");\n            }\n            else {\n                throw new Error(`@aws-sdk/core/protocols - xml serializer, unhandled schema type for object value and schema: ${ns.getName(true)}`);\n            }\n        }\n        if (ns.isStringSchema() ||\n            ns.isBooleanSchema() ||\n            ns.isNumericSchema() ||\n            ns.isBigIntegerSchema() ||\n            ns.isBigDecimalSchema()) {\n            nodeContents = String(value);\n        }\n        if (nodeContents === null) {\n            throw new Error(`Unhandled schema-value pair ${ns.getName(true)}=${value}`);\n        }\n        return nodeContents;\n    }\n    writeSimpleInto(_schema, value, into, parentXmlns) {\n        const nodeContents = this.writeSimple(_schema, value);\n        const ns = NormalizedSchema.of(_schema);\n        const content = new XmlText(nodeContents);\n        const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);\n        if (xmlns) {\n            into.addAttribute(xmlnsAttr, xmlns);\n        }\n        into.addChildNode(content);\n    }\n    getXmlnsAttribute(ns, parentXmlns) {\n        const traits = ns.getMergedTraits();\n        const [prefix, xmlns] = traits.xmlNamespace ?? [];\n        if (xmlns && xmlns !== parentXmlns) {\n            return [prefix ? `xmlns:${prefix}` : \"xmlns\", xmlns];\n        }\n        return [void 0, void 0];\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
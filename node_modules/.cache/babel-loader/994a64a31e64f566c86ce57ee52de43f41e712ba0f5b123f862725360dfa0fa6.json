{"ast":null,"code":"import _objectSpread from \"/Users/codinggents/Documents/lambdaforge/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/Users/codinggents/Documents/lambdaforge/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"assign\"];\nimport { debugId, toDebugString } from \"../debug\";\nimport { EndpointError } from \"../types\";\nimport { callFunction } from \"./callFunction\";\nexport const evaluateCondition = (_ref, options) => {\n  var _options$logger, _options$logger$debug;\n  let {\n      assign\n    } = _ref,\n    fnArgs = _objectWithoutProperties(_ref, _excluded);\n  if (assign && assign in options.referenceRecord) {\n    throw new EndpointError(\"'\".concat(assign, \"' is already defined in Reference Record.\"));\n  }\n  const value = callFunction(fnArgs, options);\n  (_options$logger = options.logger) === null || _options$logger === void 0 || (_options$logger$debug = _options$logger.debug) === null || _options$logger$debug === void 0 || _options$logger$debug.call(_options$logger, \"\".concat(debugId, \" evaluateCondition: \").concat(toDebugString(fnArgs), \" = \").concat(toDebugString(value)));\n  return _objectSpread({\n    result: value === \"\" ? true : !!value\n  }, assign != null && {\n    toAssign: {\n      name: assign,\n      value\n    }\n  });\n};","map":{"version":3,"names":["debugId","toDebugString","EndpointError","callFunction","evaluateCondition","_ref","options","_options$logger","_options$logger$debug","assign","fnArgs","_objectWithoutProperties","_excluded","referenceRecord","concat","value","logger","debug","call","_objectSpread","result","toAssign","name"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/@smithy/util-endpoints/dist-es/utils/evaluateCondition.js"],"sourcesContent":["import { debugId, toDebugString } from \"../debug\";\nimport { EndpointError } from \"../types\";\nimport { callFunction } from \"./callFunction\";\nexport const evaluateCondition = ({ assign, ...fnArgs }, options) => {\n    if (assign && assign in options.referenceRecord) {\n        throw new EndpointError(`'${assign}' is already defined in Reference Record.`);\n    }\n    const value = callFunction(fnArgs, options);\n    options.logger?.debug?.(`${debugId} evaluateCondition: ${toDebugString(fnArgs)} = ${toDebugString(value)}`);\n    return {\n        result: value === \"\" ? true : !!value,\n        ...(assign != null && { toAssign: { name: assign, value } }),\n    };\n};\n"],"mappings":";;;AAAA,SAASA,OAAO,EAAEC,aAAa,QAAQ,UAAU;AACjD,SAASC,aAAa,QAAQ,UAAU;AACxC,SAASC,YAAY,QAAQ,gBAAgB;AAC7C,OAAO,MAAMC,iBAAiB,GAAGA,CAAAC,IAAA,EAAwBC,OAAO,KAAK;EAAA,IAAAC,eAAA,EAAAC,qBAAA;EAAA,IAAnC;MAAEC;IAAkB,CAAC,GAAAJ,IAAA;IAARK,MAAM,GAAAC,wBAAA,CAAAN,IAAA,EAAAO,SAAA;EACjD,IAAIH,MAAM,IAAIA,MAAM,IAAIH,OAAO,CAACO,eAAe,EAAE;IAC7C,MAAM,IAAIX,aAAa,KAAAY,MAAA,CAAKL,MAAM,8CAA2C,CAAC;EAClF;EACA,MAAMM,KAAK,GAAGZ,YAAY,CAACO,MAAM,EAAEJ,OAAO,CAAC;EAC3C,CAAAC,eAAA,GAAAD,OAAO,CAACU,MAAM,cAAAT,eAAA,gBAAAC,qBAAA,GAAdD,eAAA,CAAgBU,KAAK,cAAAT,qBAAA,eAArBA,qBAAA,CAAAU,IAAA,CAAAX,eAAA,KAAAO,MAAA,CAA2Bd,OAAO,0BAAAc,MAAA,CAAuBb,aAAa,CAACS,MAAM,CAAC,SAAAI,MAAA,CAAMb,aAAa,CAACc,KAAK,CAAC,CAAE,CAAC;EAC3G,OAAAI,aAAA;IACIC,MAAM,EAAEL,KAAK,KAAK,EAAE,GAAG,IAAI,GAAG,CAAC,CAACA;EAAK,GACjCN,MAAM,IAAI,IAAI,IAAI;IAAEY,QAAQ,EAAE;MAAEC,IAAI,EAAEb,MAAM;MAAEM;IAAM;EAAE,CAAC;AAEnE,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { debugId, toDebugString } from \"./debug\";\nimport { EndpointError } from \"./types\";\nimport { evaluateRules } from \"./utils\";\nexport const resolveEndpoint = (ruleSetObject, options) => {\n  var _options$logger, _options$logger$debug, _options$logger2, _options$logger2$debu;\n  const {\n    endpointParams,\n    logger\n  } = options;\n  const {\n    parameters,\n    rules\n  } = ruleSetObject;\n  (_options$logger = options.logger) === null || _options$logger === void 0 || (_options$logger$debug = _options$logger.debug) === null || _options$logger$debug === void 0 || _options$logger$debug.call(_options$logger, \"\".concat(debugId, \" Initial EndpointParams: \").concat(toDebugString(endpointParams)));\n  const paramsWithDefault = Object.entries(parameters).filter(_ref => {\n    let [, v] = _ref;\n    return v.default != null;\n  }).map(_ref2 => {\n    let [k, v] = _ref2;\n    return [k, v.default];\n  });\n  if (paramsWithDefault.length > 0) {\n    for (const [paramKey, paramDefaultValue] of paramsWithDefault) {\n      var _endpointParams$param;\n      endpointParams[paramKey] = (_endpointParams$param = endpointParams[paramKey]) !== null && _endpointParams$param !== void 0 ? _endpointParams$param : paramDefaultValue;\n    }\n  }\n  const requiredParams = Object.entries(parameters).filter(_ref3 => {\n    let [, v] = _ref3;\n    return v.required;\n  }).map(_ref4 => {\n    let [k] = _ref4;\n    return k;\n  });\n  for (const requiredParam of requiredParams) {\n    if (endpointParams[requiredParam] == null) {\n      throw new EndpointError(\"Missing required parameter: '\".concat(requiredParam, \"'\"));\n    }\n  }\n  const endpoint = evaluateRules(rules, {\n    endpointParams,\n    logger,\n    referenceRecord: {}\n  });\n  (_options$logger2 = options.logger) === null || _options$logger2 === void 0 || (_options$logger2$debu = _options$logger2.debug) === null || _options$logger2$debu === void 0 || _options$logger2$debu.call(_options$logger2, \"\".concat(debugId, \" Resolved endpoint: \").concat(toDebugString(endpoint)));\n  return endpoint;\n};","map":{"version":3,"names":["debugId","toDebugString","EndpointError","evaluateRules","resolveEndpoint","ruleSetObject","options","_options$logger","_options$logger$debug","_options$logger2","_options$logger2$debu","endpointParams","logger","parameters","rules","debug","call","concat","paramsWithDefault","Object","entries","filter","_ref","v","default","map","_ref2","k","length","paramKey","paramDefaultValue","_endpointParams$param","requiredParams","_ref3","required","_ref4","requiredParam","endpoint","referenceRecord"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/@smithy/util-endpoints/dist-es/resolveEndpoint.js"],"sourcesContent":["import { debugId, toDebugString } from \"./debug\";\nimport { EndpointError } from \"./types\";\nimport { evaluateRules } from \"./utils\";\nexport const resolveEndpoint = (ruleSetObject, options) => {\n    const { endpointParams, logger } = options;\n    const { parameters, rules } = ruleSetObject;\n    options.logger?.debug?.(`${debugId} Initial EndpointParams: ${toDebugString(endpointParams)}`);\n    const paramsWithDefault = Object.entries(parameters)\n        .filter(([, v]) => v.default != null)\n        .map(([k, v]) => [k, v.default]);\n    if (paramsWithDefault.length > 0) {\n        for (const [paramKey, paramDefaultValue] of paramsWithDefault) {\n            endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;\n        }\n    }\n    const requiredParams = Object.entries(parameters)\n        .filter(([, v]) => v.required)\n        .map(([k]) => k);\n    for (const requiredParam of requiredParams) {\n        if (endpointParams[requiredParam] == null) {\n            throw new EndpointError(`Missing required parameter: '${requiredParam}'`);\n        }\n    }\n    const endpoint = evaluateRules(rules, { endpointParams, logger, referenceRecord: {} });\n    options.logger?.debug?.(`${debugId} Resolved endpoint: ${toDebugString(endpoint)}`);\n    return endpoint;\n};\n"],"mappings":"AAAA,SAASA,OAAO,EAAEC,aAAa,QAAQ,SAAS;AAChD,SAASC,aAAa,QAAQ,SAAS;AACvC,SAASC,aAAa,QAAQ,SAAS;AACvC,OAAO,MAAMC,eAAe,GAAGA,CAACC,aAAa,EAAEC,OAAO,KAAK;EAAA,IAAAC,eAAA,EAAAC,qBAAA,EAAAC,gBAAA,EAAAC,qBAAA;EACvD,MAAM;IAAEC,cAAc;IAAEC;EAAO,CAAC,GAAGN,OAAO;EAC1C,MAAM;IAAEO,UAAU;IAAEC;EAAM,CAAC,GAAGT,aAAa;EAC3C,CAAAE,eAAA,GAAAD,OAAO,CAACM,MAAM,cAAAL,eAAA,gBAAAC,qBAAA,GAAdD,eAAA,CAAgBQ,KAAK,cAAAP,qBAAA,eAArBA,qBAAA,CAAAQ,IAAA,CAAAT,eAAA,KAAAU,MAAA,CAA2BjB,OAAO,+BAAAiB,MAAA,CAA4BhB,aAAa,CAACU,cAAc,CAAC,CAAE,CAAC;EAC9F,MAAMO,iBAAiB,GAAGC,MAAM,CAACC,OAAO,CAACP,UAAU,CAAC,CAC/CQ,MAAM,CAACC,IAAA;IAAA,IAAC,GAAGC,CAAC,CAAC,GAAAD,IAAA;IAAA,OAAKC,CAAC,CAACC,OAAO,IAAI,IAAI;EAAA,EAAC,CACpCC,GAAG,CAACC,KAAA;IAAA,IAAC,CAACC,CAAC,EAAEJ,CAAC,CAAC,GAAAG,KAAA;IAAA,OAAK,CAACC,CAAC,EAAEJ,CAAC,CAACC,OAAO,CAAC;EAAA,EAAC;EACpC,IAAIN,iBAAiB,CAACU,MAAM,GAAG,CAAC,EAAE;IAC9B,KAAK,MAAM,CAACC,QAAQ,EAAEC,iBAAiB,CAAC,IAAIZ,iBAAiB,EAAE;MAAA,IAAAa,qBAAA;MAC3DpB,cAAc,CAACkB,QAAQ,CAAC,IAAAE,qBAAA,GAAGpB,cAAc,CAACkB,QAAQ,CAAC,cAAAE,qBAAA,cAAAA,qBAAA,GAAID,iBAAiB;IAC5E;EACJ;EACA,MAAME,cAAc,GAAGb,MAAM,CAACC,OAAO,CAACP,UAAU,CAAC,CAC5CQ,MAAM,CAACY,KAAA;IAAA,IAAC,GAAGV,CAAC,CAAC,GAAAU,KAAA;IAAA,OAAKV,CAAC,CAACW,QAAQ;EAAA,EAAC,CAC7BT,GAAG,CAACU,KAAA;IAAA,IAAC,CAACR,CAAC,CAAC,GAAAQ,KAAA;IAAA,OAAKR,CAAC;EAAA,EAAC;EACpB,KAAK,MAAMS,aAAa,IAAIJ,cAAc,EAAE;IACxC,IAAIrB,cAAc,CAACyB,aAAa,CAAC,IAAI,IAAI,EAAE;MACvC,MAAM,IAAIlC,aAAa,iCAAAe,MAAA,CAAiCmB,aAAa,MAAG,CAAC;IAC7E;EACJ;EACA,MAAMC,QAAQ,GAAGlC,aAAa,CAACW,KAAK,EAAE;IAAEH,cAAc;IAAEC,MAAM;IAAE0B,eAAe,EAAE,CAAC;EAAE,CAAC,CAAC;EACtF,CAAA7B,gBAAA,GAAAH,OAAO,CAACM,MAAM,cAAAH,gBAAA,gBAAAC,qBAAA,GAAdD,gBAAA,CAAgBM,KAAK,cAAAL,qBAAA,eAArBA,qBAAA,CAAAM,IAAA,CAAAP,gBAAA,KAAAQ,MAAA,CAA2BjB,OAAO,0BAAAiB,MAAA,CAAuBhB,aAAa,CAACoC,QAAQ,CAAC,CAAE,CAAC;EACnF,OAAOA,QAAQ;AACnB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
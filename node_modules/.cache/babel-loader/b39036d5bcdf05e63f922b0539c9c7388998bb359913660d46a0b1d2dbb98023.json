{"ast":null,"code":"import { FromStringShapeDeserializer } from \"@smithy/core/protocols\";\nimport { NormalizedSchema } from \"@smithy/core/schema\";\nimport { getValueFromTextNode } from \"@smithy/smithy-client\";\nimport { toUtf8 } from \"@smithy/util-utf8\";\nimport { XMLParser } from \"fast-xml-parser\";\nimport { SerdeContextConfig } from \"../ConfigurableSerdeContext\";\nexport class XmlShapeDeserializer extends SerdeContextConfig {\n  settings;\n  stringDeserializer;\n  constructor(settings) {\n    super();\n    this.settings = settings;\n    this.stringDeserializer = new FromStringShapeDeserializer(settings);\n  }\n  setSerdeContext(serdeContext) {\n    this.serdeContext = serdeContext;\n    this.stringDeserializer.setSerdeContext(serdeContext);\n  }\n  read(schema, bytes, key) {\n    const ns = NormalizedSchema.of(schema);\n    const memberSchemas = ns.getMemberSchemas();\n    const isEventPayload = ns.isStructSchema() && ns.isMemberSchema() && !!Object.values(memberSchemas).find(memberNs => {\n      return !!memberNs.getMemberTraits().eventPayload;\n    });\n    if (isEventPayload) {\n      const output = {};\n      const memberName = Object.keys(memberSchemas)[0];\n      const eventMemberSchema = memberSchemas[memberName];\n      if (eventMemberSchema.isBlobSchema()) {\n        output[memberName] = bytes;\n      } else {\n        output[memberName] = this.read(memberSchemas[memberName], bytes);\n      }\n      return output;\n    }\n    const xmlString = (this.serdeContext?.utf8Encoder ?? toUtf8)(bytes);\n    const parsedObject = this.parseXml(xmlString);\n    return this.readSchema(schema, key ? parsedObject[key] : parsedObject);\n  }\n  readSchema(_schema, value) {\n    const ns = NormalizedSchema.of(_schema);\n    const traits = ns.getMergedTraits();\n    const schema = ns.getSchema();\n    if (ns.isListSchema() && !Array.isArray(value)) {\n      return this.readSchema(schema, [value]);\n    }\n    if (value == null) {\n      return value;\n    }\n    if (typeof value === \"object\") {\n      const sparse = !!traits.sparse;\n      const flat = !!traits.xmlFlattened;\n      if (ns.isListSchema()) {\n        const listValue = ns.getValueSchema();\n        const buffer = [];\n        const sourceKey = listValue.getMergedTraits().xmlName ?? \"member\";\n        const source = flat ? value : (value[0] ?? value)[sourceKey];\n        const sourceArray = Array.isArray(source) ? source : [source];\n        for (const v of sourceArray) {\n          if (v != null || sparse) {\n            buffer.push(this.readSchema(listValue, v));\n          }\n        }\n        return buffer;\n      }\n      const buffer = {};\n      if (ns.isMapSchema()) {\n        const keyNs = ns.getKeySchema();\n        const memberNs = ns.getValueSchema();\n        let entries;\n        if (flat) {\n          entries = Array.isArray(value) ? value : [value];\n        } else {\n          entries = Array.isArray(value.entry) ? value.entry : [value.entry];\n        }\n        const keyProperty = keyNs.getMergedTraits().xmlName ?? \"key\";\n        const valueProperty = memberNs.getMergedTraits().xmlName ?? \"value\";\n        for (const entry of entries) {\n          const key = entry[keyProperty];\n          const value = entry[valueProperty];\n          if (value != null || sparse) {\n            buffer[key] = this.readSchema(memberNs, value);\n          }\n        }\n        return buffer;\n      }\n      if (ns.isStructSchema()) {\n        for (const [memberName, memberSchema] of ns.structIterator()) {\n          const memberTraits = memberSchema.getMergedTraits();\n          const xmlObjectKey = !memberTraits.httpPayload ? memberSchema.getMemberTraits().xmlName ?? memberName : memberTraits.xmlName ?? memberSchema.getName();\n          if (value[xmlObjectKey] != null) {\n            buffer[memberName] = this.readSchema(memberSchema, value[xmlObjectKey]);\n          }\n        }\n        return buffer;\n      }\n      if (ns.isDocumentSchema()) {\n        return value;\n      }\n      throw new Error(`@aws-sdk/core/protocols - xml deserializer unhandled schema type for ${ns.getName(true)}`);\n    } else {\n      if (ns.isListSchema()) {\n        return [];\n      } else if (ns.isMapSchema() || ns.isStructSchema()) {\n        return {};\n      }\n      return this.stringDeserializer.read(ns, value);\n    }\n  }\n  parseXml(xml) {\n    if (xml.length) {\n      const parser = new XMLParser({\n        attributeNamePrefix: \"\",\n        htmlEntities: true,\n        ignoreAttributes: false,\n        ignoreDeclaration: true,\n        parseTagValue: false,\n        trimValues: false,\n        tagValueProcessor: (_, val) => val.trim() === \"\" && val.includes(\"\\n\") ? \"\" : undefined\n      });\n      parser.addEntity(\"#xD\", \"\\r\");\n      parser.addEntity(\"#10\", \"\\n\");\n      let parsedObj;\n      try {\n        parsedObj = parser.parse(xml, true);\n      } catch (e) {\n        if (e && typeof e === \"object\") {\n          Object.defineProperty(e, \"$responseBodyText\", {\n            value: xml\n          });\n        }\n        throw e;\n      }\n      const textNodeName = \"#text\";\n      const key = Object.keys(parsedObj)[0];\n      const parsedObjToReturn = parsedObj[key];\n      if (parsedObjToReturn[textNodeName]) {\n        parsedObjToReturn[key] = parsedObjToReturn[textNodeName];\n        delete parsedObjToReturn[textNodeName];\n      }\n      return getValueFromTextNode(parsedObjToReturn);\n    }\n    return {};\n  }\n}","map":{"version":3,"names":["FromStringShapeDeserializer","NormalizedSchema","getValueFromTextNode","toUtf8","XMLParser","SerdeContextConfig","XmlShapeDeserializer","settings","stringDeserializer","constructor","setSerdeContext","serdeContext","read","schema","bytes","key","ns","of","memberSchemas","getMemberSchemas","isEventPayload","isStructSchema","isMemberSchema","Object","values","find","memberNs","getMemberTraits","eventPayload","output","memberName","keys","eventMemberSchema","isBlobSchema","xmlString","utf8Encoder","parsedObject","parseXml","readSchema","_schema","value","traits","getMergedTraits","getSchema","isListSchema","Array","isArray","sparse","flat","xmlFlattened","listValue","getValueSchema","buffer","sourceKey","xmlName","source","sourceArray","v","push","isMapSchema","keyNs","getKeySchema","entries","entry","keyProperty","valueProperty","memberSchema","structIterator","memberTraits","xmlObjectKey","httpPayload","getName","isDocumentSchema","Error","xml","length","parser","attributeNamePrefix","htmlEntities","ignoreAttributes","ignoreDeclaration","parseTagValue","trimValues","tagValueProcessor","_","val","trim","includes","undefined","addEntity","parsedObj","parse","e","defineProperty","textNodeName","parsedObjToReturn"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/XmlShapeDeserializer.js"],"sourcesContent":["import { FromStringShapeDeserializer } from \"@smithy/core/protocols\";\nimport { NormalizedSchema } from \"@smithy/core/schema\";\nimport { getValueFromTextNode } from \"@smithy/smithy-client\";\nimport { toUtf8 } from \"@smithy/util-utf8\";\nimport { XMLParser } from \"fast-xml-parser\";\nimport { SerdeContextConfig } from \"../ConfigurableSerdeContext\";\nexport class XmlShapeDeserializer extends SerdeContextConfig {\n    settings;\n    stringDeserializer;\n    constructor(settings) {\n        super();\n        this.settings = settings;\n        this.stringDeserializer = new FromStringShapeDeserializer(settings);\n    }\n    setSerdeContext(serdeContext) {\n        this.serdeContext = serdeContext;\n        this.stringDeserializer.setSerdeContext(serdeContext);\n    }\n    read(schema, bytes, key) {\n        const ns = NormalizedSchema.of(schema);\n        const memberSchemas = ns.getMemberSchemas();\n        const isEventPayload = ns.isStructSchema() &&\n            ns.isMemberSchema() &&\n            !!Object.values(memberSchemas).find((memberNs) => {\n                return !!memberNs.getMemberTraits().eventPayload;\n            });\n        if (isEventPayload) {\n            const output = {};\n            const memberName = Object.keys(memberSchemas)[0];\n            const eventMemberSchema = memberSchemas[memberName];\n            if (eventMemberSchema.isBlobSchema()) {\n                output[memberName] = bytes;\n            }\n            else {\n                output[memberName] = this.read(memberSchemas[memberName], bytes);\n            }\n            return output;\n        }\n        const xmlString = (this.serdeContext?.utf8Encoder ?? toUtf8)(bytes);\n        const parsedObject = this.parseXml(xmlString);\n        return this.readSchema(schema, key ? parsedObject[key] : parsedObject);\n    }\n    readSchema(_schema, value) {\n        const ns = NormalizedSchema.of(_schema);\n        const traits = ns.getMergedTraits();\n        const schema = ns.getSchema();\n        if (ns.isListSchema() && !Array.isArray(value)) {\n            return this.readSchema(schema, [value]);\n        }\n        if (value == null) {\n            return value;\n        }\n        if (typeof value === \"object\") {\n            const sparse = !!traits.sparse;\n            const flat = !!traits.xmlFlattened;\n            if (ns.isListSchema()) {\n                const listValue = ns.getValueSchema();\n                const buffer = [];\n                const sourceKey = listValue.getMergedTraits().xmlName ?? \"member\";\n                const source = flat ? value : (value[0] ?? value)[sourceKey];\n                const sourceArray = Array.isArray(source) ? source : [source];\n                for (const v of sourceArray) {\n                    if (v != null || sparse) {\n                        buffer.push(this.readSchema(listValue, v));\n                    }\n                }\n                return buffer;\n            }\n            const buffer = {};\n            if (ns.isMapSchema()) {\n                const keyNs = ns.getKeySchema();\n                const memberNs = ns.getValueSchema();\n                let entries;\n                if (flat) {\n                    entries = Array.isArray(value) ? value : [value];\n                }\n                else {\n                    entries = Array.isArray(value.entry) ? value.entry : [value.entry];\n                }\n                const keyProperty = keyNs.getMergedTraits().xmlName ?? \"key\";\n                const valueProperty = memberNs.getMergedTraits().xmlName ?? \"value\";\n                for (const entry of entries) {\n                    const key = entry[keyProperty];\n                    const value = entry[valueProperty];\n                    if (value != null || sparse) {\n                        buffer[key] = this.readSchema(memberNs, value);\n                    }\n                }\n                return buffer;\n            }\n            if (ns.isStructSchema()) {\n                for (const [memberName, memberSchema] of ns.structIterator()) {\n                    const memberTraits = memberSchema.getMergedTraits();\n                    const xmlObjectKey = !memberTraits.httpPayload\n                        ? memberSchema.getMemberTraits().xmlName ?? memberName\n                        : memberTraits.xmlName ?? memberSchema.getName();\n                    if (value[xmlObjectKey] != null) {\n                        buffer[memberName] = this.readSchema(memberSchema, value[xmlObjectKey]);\n                    }\n                }\n                return buffer;\n            }\n            if (ns.isDocumentSchema()) {\n                return value;\n            }\n            throw new Error(`@aws-sdk/core/protocols - xml deserializer unhandled schema type for ${ns.getName(true)}`);\n        }\n        else {\n            if (ns.isListSchema()) {\n                return [];\n            }\n            else if (ns.isMapSchema() || ns.isStructSchema()) {\n                return {};\n            }\n            return this.stringDeserializer.read(ns, value);\n        }\n    }\n    parseXml(xml) {\n        if (xml.length) {\n            const parser = new XMLParser({\n                attributeNamePrefix: \"\",\n                htmlEntities: true,\n                ignoreAttributes: false,\n                ignoreDeclaration: true,\n                parseTagValue: false,\n                trimValues: false,\n                tagValueProcessor: (_, val) => (val.trim() === \"\" && val.includes(\"\\n\") ? \"\" : undefined),\n            });\n            parser.addEntity(\"#xD\", \"\\r\");\n            parser.addEntity(\"#10\", \"\\n\");\n            let parsedObj;\n            try {\n                parsedObj = parser.parse(xml, true);\n            }\n            catch (e) {\n                if (e && typeof e === \"object\") {\n                    Object.defineProperty(e, \"$responseBodyText\", {\n                        value: xml,\n                    });\n                }\n                throw e;\n            }\n            const textNodeName = \"#text\";\n            const key = Object.keys(parsedObj)[0];\n            const parsedObjToReturn = parsedObj[key];\n            if (parsedObjToReturn[textNodeName]) {\n                parsedObjToReturn[key] = parsedObjToReturn[textNodeName];\n                delete parsedObjToReturn[textNodeName];\n            }\n            return getValueFromTextNode(parsedObjToReturn);\n        }\n        return {};\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
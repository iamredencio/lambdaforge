{"ast":null,"code":"import _awaitAsyncGenerator from \"/Users/codinggents/Documents/lambdaforge/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"/Users/codinggents/Documents/lambdaforge/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _asyncIterator from \"/Users/codinggents/Documents/lambdaforge/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nexport function getUnmarshalledStream(source, options) {\n  const messageUnmarshaller = getMessageUnmarshaller(options.deserializer, options.toUtf8);\n  return {\n    [Symbol.asyncIterator]: _wrapAsyncGenerator(function* () {\n      var _iteratorAbruptCompletion = false;\n      var _didIteratorError = false;\n      var _iteratorError;\n      try {\n        for (var _iterator = _asyncIterator(source), _step; _iteratorAbruptCompletion = !(_step = yield _awaitAsyncGenerator(_iterator.next())).done; _iteratorAbruptCompletion = false) {\n          const chunk = _step.value;\n          {\n            const message = options.eventStreamCodec.decode(chunk);\n            const type = yield _awaitAsyncGenerator(messageUnmarshaller(message));\n            if (type === undefined) continue;\n            yield type;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion && _iterator.return != null) {\n            yield _awaitAsyncGenerator(_iterator.return());\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    })\n  };\n}\nexport function getMessageUnmarshaller(deserializer, toUtf8) {\n  return async function (message) {\n    const {\n      value: messageType\n    } = message.headers[\":message-type\"];\n    if (messageType === \"error\") {\n      const unmodeledError = new Error(message.headers[\":error-message\"].value || \"UnknownError\");\n      unmodeledError.name = message.headers[\":error-code\"].value;\n      throw unmodeledError;\n    } else if (messageType === \"exception\") {\n      const code = message.headers[\":exception-type\"].value;\n      const exception = {\n        [code]: message\n      };\n      const deserializedException = await deserializer(exception);\n      if (deserializedException.$unknown) {\n        const error = new Error(toUtf8(message.body));\n        error.name = code;\n        throw error;\n      }\n      throw deserializedException[code];\n    } else if (messageType === \"event\") {\n      const event = {\n        [message.headers[\":event-type\"].value]: message\n      };\n      const deserialized = await deserializer(event);\n      if (deserialized.$unknown) return;\n      return deserialized;\n    } else {\n      throw Error(\"Unrecognizable event type: \".concat(message.headers[\":event-type\"].value));\n    }\n  };\n}","map":{"version":3,"names":["getUnmarshalledStream","source","options","messageUnmarshaller","getMessageUnmarshaller","deserializer","toUtf8","Symbol","asyncIterator","_wrapAsyncGenerator","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_asyncIterator","_step","_awaitAsyncGenerator","next","done","chunk","value","message","eventStreamCodec","decode","type","undefined","err","return","messageType","headers","unmodeledError","Error","name","code","exception","deserializedException","$unknown","error","body","event","deserialized","concat"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/@smithy/eventstream-serde-universal/dist-es/getUnmarshalledStream.js"],"sourcesContent":["export function getUnmarshalledStream(source, options) {\n    const messageUnmarshaller = getMessageUnmarshaller(options.deserializer, options.toUtf8);\n    return {\n        [Symbol.asyncIterator]: async function* () {\n            for await (const chunk of source) {\n                const message = options.eventStreamCodec.decode(chunk);\n                const type = await messageUnmarshaller(message);\n                if (type === undefined)\n                    continue;\n                yield type;\n            }\n        },\n    };\n}\nexport function getMessageUnmarshaller(deserializer, toUtf8) {\n    return async function (message) {\n        const { value: messageType } = message.headers[\":message-type\"];\n        if (messageType === \"error\") {\n            const unmodeledError = new Error(message.headers[\":error-message\"].value || \"UnknownError\");\n            unmodeledError.name = message.headers[\":error-code\"].value;\n            throw unmodeledError;\n        }\n        else if (messageType === \"exception\") {\n            const code = message.headers[\":exception-type\"].value;\n            const exception = { [code]: message };\n            const deserializedException = await deserializer(exception);\n            if (deserializedException.$unknown) {\n                const error = new Error(toUtf8(message.body));\n                error.name = code;\n                throw error;\n            }\n            throw deserializedException[code];\n        }\n        else if (messageType === \"event\") {\n            const event = {\n                [message.headers[\":event-type\"].value]: message,\n            };\n            const deserialized = await deserializer(event);\n            if (deserialized.$unknown)\n                return;\n            return deserialized;\n        }\n        else {\n            throw Error(`Unrecognizable event type: ${message.headers[\":event-type\"].value}`);\n        }\n    };\n}\n"],"mappings":";;;AAAA,OAAO,SAASA,qBAAqBA,CAACC,MAAM,EAAEC,OAAO,EAAE;EACnD,MAAMC,mBAAmB,GAAGC,sBAAsB,CAACF,OAAO,CAACG,YAAY,EAAEH,OAAO,CAACI,MAAM,CAAC;EACxF,OAAO;IACH,CAACC,MAAM,CAACC,aAAa,GAAAC,mBAAA,CAAG,aAAmB;MAAA,IAAAC,yBAAA;MAAA,IAAAC,iBAAA;MAAA,IAAAC,cAAA;MAAA;QACvC,SAAAC,SAAA,GAAAC,cAAA,CAA0Bb,MAAM,GAAAc,KAAA,EAAAL,yBAAA,KAAAK,KAAA,SAAAC,oBAAA,CAAAH,SAAA,CAAAI,IAAA,KAAAC,IAAA,EAAAR,yBAAA,UAAE;UAAA,MAAjBS,KAAK,GAAAJ,KAAA,CAAAK,KAAA;UAAA;YAClB,MAAMC,OAAO,GAAGnB,OAAO,CAACoB,gBAAgB,CAACC,MAAM,CAACJ,KAAK,CAAC;YACtD,MAAMK,IAAI,SAAAR,oBAAA,CAASb,mBAAmB,CAACkB,OAAO,CAAC;YAC/C,IAAIG,IAAI,KAAKC,SAAS,EAClB;YACJ,MAAMD,IAAI;UAAC;QACf;MAAC,SAAAE,GAAA;QAAAf,iBAAA;QAAAC,cAAA,GAAAc,GAAA;MAAA;QAAA;UAAA,IAAAhB,yBAAA,IAAAG,SAAA,CAAAc,MAAA;YAAA,MAAAX,oBAAA,CAAAH,SAAA,CAAAc,MAAA;UAAA;QAAA;UAAA,IAAAhB,iBAAA;YAAA,MAAAC,cAAA;UAAA;QAAA;MAAA;IACL,CAAC;EACL,CAAC;AACL;AACA,OAAO,SAASR,sBAAsBA,CAACC,YAAY,EAAEC,MAAM,EAAE;EACzD,OAAO,gBAAgBe,OAAO,EAAE;IAC5B,MAAM;MAAED,KAAK,EAAEQ;IAAY,CAAC,GAAGP,OAAO,CAACQ,OAAO,CAAC,eAAe,CAAC;IAC/D,IAAID,WAAW,KAAK,OAAO,EAAE;MACzB,MAAME,cAAc,GAAG,IAAIC,KAAK,CAACV,OAAO,CAACQ,OAAO,CAAC,gBAAgB,CAAC,CAACT,KAAK,IAAI,cAAc,CAAC;MAC3FU,cAAc,CAACE,IAAI,GAAGX,OAAO,CAACQ,OAAO,CAAC,aAAa,CAAC,CAACT,KAAK;MAC1D,MAAMU,cAAc;IACxB,CAAC,MACI,IAAIF,WAAW,KAAK,WAAW,EAAE;MAClC,MAAMK,IAAI,GAAGZ,OAAO,CAACQ,OAAO,CAAC,iBAAiB,CAAC,CAACT,KAAK;MACrD,MAAMc,SAAS,GAAG;QAAE,CAACD,IAAI,GAAGZ;MAAQ,CAAC;MACrC,MAAMc,qBAAqB,GAAG,MAAM9B,YAAY,CAAC6B,SAAS,CAAC;MAC3D,IAAIC,qBAAqB,CAACC,QAAQ,EAAE;QAChC,MAAMC,KAAK,GAAG,IAAIN,KAAK,CAACzB,MAAM,CAACe,OAAO,CAACiB,IAAI,CAAC,CAAC;QAC7CD,KAAK,CAACL,IAAI,GAAGC,IAAI;QACjB,MAAMI,KAAK;MACf;MACA,MAAMF,qBAAqB,CAACF,IAAI,CAAC;IACrC,CAAC,MACI,IAAIL,WAAW,KAAK,OAAO,EAAE;MAC9B,MAAMW,KAAK,GAAG;QACV,CAAClB,OAAO,CAACQ,OAAO,CAAC,aAAa,CAAC,CAACT,KAAK,GAAGC;MAC5C,CAAC;MACD,MAAMmB,YAAY,GAAG,MAAMnC,YAAY,CAACkC,KAAK,CAAC;MAC9C,IAAIC,YAAY,CAACJ,QAAQ,EACrB;MACJ,OAAOI,YAAY;IACvB,CAAC,MACI;MACD,MAAMT,KAAK,+BAAAU,MAAA,CAA+BpB,OAAO,CAACQ,OAAO,CAAC,aAAa,CAAC,CAACT,KAAK,CAAE,CAAC;IACrF;EACJ,CAAC;AACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _defineProperty from \"/Users/codinggents/Documents/lambdaforge/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { FromStringShapeDeserializer } from \"@smithy/core/protocols\";\nimport { NormalizedSchema } from \"@smithy/core/schema\";\nimport { getValueFromTextNode } from \"@smithy/smithy-client\";\nimport { toUtf8 } from \"@smithy/util-utf8\";\nimport { XMLParser } from \"fast-xml-parser\";\nimport { SerdeContextConfig } from \"../ConfigurableSerdeContext\";\nexport class XmlShapeDeserializer extends SerdeContextConfig {\n  constructor(settings) {\n    super();\n    _defineProperty(this, \"settings\", void 0);\n    _defineProperty(this, \"stringDeserializer\", void 0);\n    this.settings = settings;\n    this.stringDeserializer = new FromStringShapeDeserializer(settings);\n  }\n  setSerdeContext(serdeContext) {\n    this.serdeContext = serdeContext;\n    this.stringDeserializer.setSerdeContext(serdeContext);\n  }\n  read(schema, bytes, key) {\n    var _this$serdeContext$ut, _this$serdeContext;\n    const ns = NormalizedSchema.of(schema);\n    const memberSchemas = ns.getMemberSchemas();\n    const isEventPayload = ns.isStructSchema() && ns.isMemberSchema() && !!Object.values(memberSchemas).find(memberNs => {\n      return !!memberNs.getMemberTraits().eventPayload;\n    });\n    if (isEventPayload) {\n      const output = {};\n      const memberName = Object.keys(memberSchemas)[0];\n      const eventMemberSchema = memberSchemas[memberName];\n      if (eventMemberSchema.isBlobSchema()) {\n        output[memberName] = bytes;\n      } else {\n        output[memberName] = this.read(memberSchemas[memberName], bytes);\n      }\n      return output;\n    }\n    const xmlString = ((_this$serdeContext$ut = (_this$serdeContext = this.serdeContext) === null || _this$serdeContext === void 0 ? void 0 : _this$serdeContext.utf8Encoder) !== null && _this$serdeContext$ut !== void 0 ? _this$serdeContext$ut : toUtf8)(bytes);\n    const parsedObject = this.parseXml(xmlString);\n    return this.readSchema(schema, key ? parsedObject[key] : parsedObject);\n  }\n  readSchema(_schema, value) {\n    const ns = NormalizedSchema.of(_schema);\n    const traits = ns.getMergedTraits();\n    const schema = ns.getSchema();\n    if (ns.isListSchema() && !Array.isArray(value)) {\n      return this.readSchema(schema, [value]);\n    }\n    if (value == null) {\n      return value;\n    }\n    if (typeof value === \"object\") {\n      const sparse = !!traits.sparse;\n      const flat = !!traits.xmlFlattened;\n      if (ns.isListSchema()) {\n        var _listValue$getMergedT, _value$;\n        const listValue = ns.getValueSchema();\n        const buffer = [];\n        const sourceKey = (_listValue$getMergedT = listValue.getMergedTraits().xmlName) !== null && _listValue$getMergedT !== void 0 ? _listValue$getMergedT : \"member\";\n        const source = flat ? value : ((_value$ = value[0]) !== null && _value$ !== void 0 ? _value$ : value)[sourceKey];\n        const sourceArray = Array.isArray(source) ? source : [source];\n        for (const v of sourceArray) {\n          if (v != null || sparse) {\n            buffer.push(this.readSchema(listValue, v));\n          }\n        }\n        return buffer;\n      }\n      const buffer = {};\n      if (ns.isMapSchema()) {\n        var _keyNs$getMergedTrait, _memberNs$getMergedTr;\n        const keyNs = ns.getKeySchema();\n        const memberNs = ns.getValueSchema();\n        let entries;\n        if (flat) {\n          entries = Array.isArray(value) ? value : [value];\n        } else {\n          entries = Array.isArray(value.entry) ? value.entry : [value.entry];\n        }\n        const keyProperty = (_keyNs$getMergedTrait = keyNs.getMergedTraits().xmlName) !== null && _keyNs$getMergedTrait !== void 0 ? _keyNs$getMergedTrait : \"key\";\n        const valueProperty = (_memberNs$getMergedTr = memberNs.getMergedTraits().xmlName) !== null && _memberNs$getMergedTr !== void 0 ? _memberNs$getMergedTr : \"value\";\n        for (const entry of entries) {\n          const key = entry[keyProperty];\n          const value = entry[valueProperty];\n          if (value != null || sparse) {\n            buffer[key] = this.readSchema(memberNs, value);\n          }\n        }\n        return buffer;\n      }\n      if (ns.isStructSchema()) {\n        for (const [memberName, memberSchema] of ns.structIterator()) {\n          var _memberSchema$getMemb, _memberTraits$xmlName;\n          const memberTraits = memberSchema.getMergedTraits();\n          const xmlObjectKey = !memberTraits.httpPayload ? (_memberSchema$getMemb = memberSchema.getMemberTraits().xmlName) !== null && _memberSchema$getMemb !== void 0 ? _memberSchema$getMemb : memberName : (_memberTraits$xmlName = memberTraits.xmlName) !== null && _memberTraits$xmlName !== void 0 ? _memberTraits$xmlName : memberSchema.getName();\n          if (value[xmlObjectKey] != null) {\n            buffer[memberName] = this.readSchema(memberSchema, value[xmlObjectKey]);\n          }\n        }\n        return buffer;\n      }\n      if (ns.isDocumentSchema()) {\n        return value;\n      }\n      throw new Error(\"@aws-sdk/core/protocols - xml deserializer unhandled schema type for \".concat(ns.getName(true)));\n    } else {\n      if (ns.isListSchema()) {\n        return [];\n      } else if (ns.isMapSchema() || ns.isStructSchema()) {\n        return {};\n      }\n      return this.stringDeserializer.read(ns, value);\n    }\n  }\n  parseXml(xml) {\n    if (xml.length) {\n      const parser = new XMLParser({\n        attributeNamePrefix: \"\",\n        htmlEntities: true,\n        ignoreAttributes: false,\n        ignoreDeclaration: true,\n        parseTagValue: false,\n        trimValues: false,\n        tagValueProcessor: (_, val) => val.trim() === \"\" && val.includes(\"\\n\") ? \"\" : undefined\n      });\n      parser.addEntity(\"#xD\", \"\\r\");\n      parser.addEntity(\"#10\", \"\\n\");\n      let parsedObj;\n      try {\n        parsedObj = parser.parse(xml, true);\n      } catch (e) {\n        if (e && typeof e === \"object\") {\n          Object.defineProperty(e, \"$responseBodyText\", {\n            value: xml\n          });\n        }\n        throw e;\n      }\n      const textNodeName = \"#text\";\n      const key = Object.keys(parsedObj)[0];\n      const parsedObjToReturn = parsedObj[key];\n      if (parsedObjToReturn[textNodeName]) {\n        parsedObjToReturn[key] = parsedObjToReturn[textNodeName];\n        delete parsedObjToReturn[textNodeName];\n      }\n      return getValueFromTextNode(parsedObjToReturn);\n    }\n    return {};\n  }\n}","map":{"version":3,"names":["FromStringShapeDeserializer","NormalizedSchema","getValueFromTextNode","toUtf8","XMLParser","SerdeContextConfig","XmlShapeDeserializer","constructor","settings","_defineProperty","stringDeserializer","setSerdeContext","serdeContext","read","schema","bytes","key","_this$serdeContext$ut","_this$serdeContext","ns","of","memberSchemas","getMemberSchemas","isEventPayload","isStructSchema","isMemberSchema","Object","values","find","memberNs","getMemberTraits","eventPayload","output","memberName","keys","eventMemberSchema","isBlobSchema","xmlString","utf8Encoder","parsedObject","parseXml","readSchema","_schema","value","traits","getMergedTraits","getSchema","isListSchema","Array","isArray","sparse","flat","xmlFlattened","_listValue$getMergedT","_value$","listValue","getValueSchema","buffer","sourceKey","xmlName","source","sourceArray","v","push","isMapSchema","_keyNs$getMergedTrait","_memberNs$getMergedTr","keyNs","getKeySchema","entries","entry","keyProperty","valueProperty","memberSchema","structIterator","_memberSchema$getMemb","_memberTraits$xmlName","memberTraits","xmlObjectKey","httpPayload","getName","isDocumentSchema","Error","concat","xml","length","parser","attributeNamePrefix","htmlEntities","ignoreAttributes","ignoreDeclaration","parseTagValue","trimValues","tagValueProcessor","_","val","trim","includes","undefined","addEntity","parsedObj","parse","e","defineProperty","textNodeName","parsedObjToReturn"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/XmlShapeDeserializer.js"],"sourcesContent":["import { FromStringShapeDeserializer } from \"@smithy/core/protocols\";\nimport { NormalizedSchema } from \"@smithy/core/schema\";\nimport { getValueFromTextNode } from \"@smithy/smithy-client\";\nimport { toUtf8 } from \"@smithy/util-utf8\";\nimport { XMLParser } from \"fast-xml-parser\";\nimport { SerdeContextConfig } from \"../ConfigurableSerdeContext\";\nexport class XmlShapeDeserializer extends SerdeContextConfig {\n    settings;\n    stringDeserializer;\n    constructor(settings) {\n        super();\n        this.settings = settings;\n        this.stringDeserializer = new FromStringShapeDeserializer(settings);\n    }\n    setSerdeContext(serdeContext) {\n        this.serdeContext = serdeContext;\n        this.stringDeserializer.setSerdeContext(serdeContext);\n    }\n    read(schema, bytes, key) {\n        const ns = NormalizedSchema.of(schema);\n        const memberSchemas = ns.getMemberSchemas();\n        const isEventPayload = ns.isStructSchema() &&\n            ns.isMemberSchema() &&\n            !!Object.values(memberSchemas).find((memberNs) => {\n                return !!memberNs.getMemberTraits().eventPayload;\n            });\n        if (isEventPayload) {\n            const output = {};\n            const memberName = Object.keys(memberSchemas)[0];\n            const eventMemberSchema = memberSchemas[memberName];\n            if (eventMemberSchema.isBlobSchema()) {\n                output[memberName] = bytes;\n            }\n            else {\n                output[memberName] = this.read(memberSchemas[memberName], bytes);\n            }\n            return output;\n        }\n        const xmlString = (this.serdeContext?.utf8Encoder ?? toUtf8)(bytes);\n        const parsedObject = this.parseXml(xmlString);\n        return this.readSchema(schema, key ? parsedObject[key] : parsedObject);\n    }\n    readSchema(_schema, value) {\n        const ns = NormalizedSchema.of(_schema);\n        const traits = ns.getMergedTraits();\n        const schema = ns.getSchema();\n        if (ns.isListSchema() && !Array.isArray(value)) {\n            return this.readSchema(schema, [value]);\n        }\n        if (value == null) {\n            return value;\n        }\n        if (typeof value === \"object\") {\n            const sparse = !!traits.sparse;\n            const flat = !!traits.xmlFlattened;\n            if (ns.isListSchema()) {\n                const listValue = ns.getValueSchema();\n                const buffer = [];\n                const sourceKey = listValue.getMergedTraits().xmlName ?? \"member\";\n                const source = flat ? value : (value[0] ?? value)[sourceKey];\n                const sourceArray = Array.isArray(source) ? source : [source];\n                for (const v of sourceArray) {\n                    if (v != null || sparse) {\n                        buffer.push(this.readSchema(listValue, v));\n                    }\n                }\n                return buffer;\n            }\n            const buffer = {};\n            if (ns.isMapSchema()) {\n                const keyNs = ns.getKeySchema();\n                const memberNs = ns.getValueSchema();\n                let entries;\n                if (flat) {\n                    entries = Array.isArray(value) ? value : [value];\n                }\n                else {\n                    entries = Array.isArray(value.entry) ? value.entry : [value.entry];\n                }\n                const keyProperty = keyNs.getMergedTraits().xmlName ?? \"key\";\n                const valueProperty = memberNs.getMergedTraits().xmlName ?? \"value\";\n                for (const entry of entries) {\n                    const key = entry[keyProperty];\n                    const value = entry[valueProperty];\n                    if (value != null || sparse) {\n                        buffer[key] = this.readSchema(memberNs, value);\n                    }\n                }\n                return buffer;\n            }\n            if (ns.isStructSchema()) {\n                for (const [memberName, memberSchema] of ns.structIterator()) {\n                    const memberTraits = memberSchema.getMergedTraits();\n                    const xmlObjectKey = !memberTraits.httpPayload\n                        ? memberSchema.getMemberTraits().xmlName ?? memberName\n                        : memberTraits.xmlName ?? memberSchema.getName();\n                    if (value[xmlObjectKey] != null) {\n                        buffer[memberName] = this.readSchema(memberSchema, value[xmlObjectKey]);\n                    }\n                }\n                return buffer;\n            }\n            if (ns.isDocumentSchema()) {\n                return value;\n            }\n            throw new Error(`@aws-sdk/core/protocols - xml deserializer unhandled schema type for ${ns.getName(true)}`);\n        }\n        else {\n            if (ns.isListSchema()) {\n                return [];\n            }\n            else if (ns.isMapSchema() || ns.isStructSchema()) {\n                return {};\n            }\n            return this.stringDeserializer.read(ns, value);\n        }\n    }\n    parseXml(xml) {\n        if (xml.length) {\n            const parser = new XMLParser({\n                attributeNamePrefix: \"\",\n                htmlEntities: true,\n                ignoreAttributes: false,\n                ignoreDeclaration: true,\n                parseTagValue: false,\n                trimValues: false,\n                tagValueProcessor: (_, val) => (val.trim() === \"\" && val.includes(\"\\n\") ? \"\" : undefined),\n            });\n            parser.addEntity(\"#xD\", \"\\r\");\n            parser.addEntity(\"#10\", \"\\n\");\n            let parsedObj;\n            try {\n                parsedObj = parser.parse(xml, true);\n            }\n            catch (e) {\n                if (e && typeof e === \"object\") {\n                    Object.defineProperty(e, \"$responseBodyText\", {\n                        value: xml,\n                    });\n                }\n                throw e;\n            }\n            const textNodeName = \"#text\";\n            const key = Object.keys(parsedObj)[0];\n            const parsedObjToReturn = parsedObj[key];\n            if (parsedObjToReturn[textNodeName]) {\n                parsedObjToReturn[key] = parsedObjToReturn[textNodeName];\n                delete parsedObjToReturn[textNodeName];\n            }\n            return getValueFromTextNode(parsedObjToReturn);\n        }\n        return {};\n    }\n}\n"],"mappings":";AAAA,SAASA,2BAA2B,QAAQ,wBAAwB;AACpE,SAASC,gBAAgB,QAAQ,qBAAqB;AACtD,SAASC,oBAAoB,QAAQ,uBAAuB;AAC5D,SAASC,MAAM,QAAQ,mBAAmB;AAC1C,SAASC,SAAS,QAAQ,iBAAiB;AAC3C,SAASC,kBAAkB,QAAQ,6BAA6B;AAChE,OAAO,MAAMC,oBAAoB,SAASD,kBAAkB,CAAC;EAGzDE,WAAWA,CAACC,QAAQ,EAAE;IAClB,KAAK,CAAC,CAAC;IAACC,eAAA;IAAAA,eAAA;IACR,IAAI,CAACD,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACE,kBAAkB,GAAG,IAAIV,2BAA2B,CAACQ,QAAQ,CAAC;EACvE;EACAG,eAAeA,CAACC,YAAY,EAAE;IAC1B,IAAI,CAACA,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACF,kBAAkB,CAACC,eAAe,CAACC,YAAY,CAAC;EACzD;EACAC,IAAIA,CAACC,MAAM,EAAEC,KAAK,EAAEC,GAAG,EAAE;IAAA,IAAAC,qBAAA,EAAAC,kBAAA;IACrB,MAAMC,EAAE,GAAGlB,gBAAgB,CAACmB,EAAE,CAACN,MAAM,CAAC;IACtC,MAAMO,aAAa,GAAGF,EAAE,CAACG,gBAAgB,CAAC,CAAC;IAC3C,MAAMC,cAAc,GAAGJ,EAAE,CAACK,cAAc,CAAC,CAAC,IACtCL,EAAE,CAACM,cAAc,CAAC,CAAC,IACnB,CAAC,CAACC,MAAM,CAACC,MAAM,CAACN,aAAa,CAAC,CAACO,IAAI,CAAEC,QAAQ,IAAK;MAC9C,OAAO,CAAC,CAACA,QAAQ,CAACC,eAAe,CAAC,CAAC,CAACC,YAAY;IACpD,CAAC,CAAC;IACN,IAAIR,cAAc,EAAE;MAChB,MAAMS,MAAM,GAAG,CAAC,CAAC;MACjB,MAAMC,UAAU,GAAGP,MAAM,CAACQ,IAAI,CAACb,aAAa,CAAC,CAAC,CAAC,CAAC;MAChD,MAAMc,iBAAiB,GAAGd,aAAa,CAACY,UAAU,CAAC;MACnD,IAAIE,iBAAiB,CAACC,YAAY,CAAC,CAAC,EAAE;QAClCJ,MAAM,CAACC,UAAU,CAAC,GAAGlB,KAAK;MAC9B,CAAC,MACI;QACDiB,MAAM,CAACC,UAAU,CAAC,GAAG,IAAI,CAACpB,IAAI,CAACQ,aAAa,CAACY,UAAU,CAAC,EAAElB,KAAK,CAAC;MACpE;MACA,OAAOiB,MAAM;IACjB;IACA,MAAMK,SAAS,GAAG,EAAApB,qBAAA,IAAAC,kBAAA,GAAC,IAAI,CAACN,YAAY,cAAAM,kBAAA,uBAAjBA,kBAAA,CAAmBoB,WAAW,cAAArB,qBAAA,cAAAA,qBAAA,GAAId,MAAM,EAAEY,KAAK,CAAC;IACnE,MAAMwB,YAAY,GAAG,IAAI,CAACC,QAAQ,CAACH,SAAS,CAAC;IAC7C,OAAO,IAAI,CAACI,UAAU,CAAC3B,MAAM,EAAEE,GAAG,GAAGuB,YAAY,CAACvB,GAAG,CAAC,GAAGuB,YAAY,CAAC;EAC1E;EACAE,UAAUA,CAACC,OAAO,EAAEC,KAAK,EAAE;IACvB,MAAMxB,EAAE,GAAGlB,gBAAgB,CAACmB,EAAE,CAACsB,OAAO,CAAC;IACvC,MAAME,MAAM,GAAGzB,EAAE,CAAC0B,eAAe,CAAC,CAAC;IACnC,MAAM/B,MAAM,GAAGK,EAAE,CAAC2B,SAAS,CAAC,CAAC;IAC7B,IAAI3B,EAAE,CAAC4B,YAAY,CAAC,CAAC,IAAI,CAACC,KAAK,CAACC,OAAO,CAACN,KAAK,CAAC,EAAE;MAC5C,OAAO,IAAI,CAACF,UAAU,CAAC3B,MAAM,EAAE,CAAC6B,KAAK,CAAC,CAAC;IAC3C;IACA,IAAIA,KAAK,IAAI,IAAI,EAAE;MACf,OAAOA,KAAK;IAChB;IACA,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MAC3B,MAAMO,MAAM,GAAG,CAAC,CAACN,MAAM,CAACM,MAAM;MAC9B,MAAMC,IAAI,GAAG,CAAC,CAACP,MAAM,CAACQ,YAAY;MAClC,IAAIjC,EAAE,CAAC4B,YAAY,CAAC,CAAC,EAAE;QAAA,IAAAM,qBAAA,EAAAC,OAAA;QACnB,MAAMC,SAAS,GAAGpC,EAAE,CAACqC,cAAc,CAAC,CAAC;QACrC,MAAMC,MAAM,GAAG,EAAE;QACjB,MAAMC,SAAS,IAAAL,qBAAA,GAAGE,SAAS,CAACV,eAAe,CAAC,CAAC,CAACc,OAAO,cAAAN,qBAAA,cAAAA,qBAAA,GAAI,QAAQ;QACjE,MAAMO,MAAM,GAAGT,IAAI,GAAGR,KAAK,GAAG,EAAAW,OAAA,GAACX,KAAK,CAAC,CAAC,CAAC,cAAAW,OAAA,cAAAA,OAAA,GAAIX,KAAK,EAAEe,SAAS,CAAC;QAC5D,MAAMG,WAAW,GAAGb,KAAK,CAACC,OAAO,CAACW,MAAM,CAAC,GAAGA,MAAM,GAAG,CAACA,MAAM,CAAC;QAC7D,KAAK,MAAME,CAAC,IAAID,WAAW,EAAE;UACzB,IAAIC,CAAC,IAAI,IAAI,IAAIZ,MAAM,EAAE;YACrBO,MAAM,CAACM,IAAI,CAAC,IAAI,CAACtB,UAAU,CAACc,SAAS,EAAEO,CAAC,CAAC,CAAC;UAC9C;QACJ;QACA,OAAOL,MAAM;MACjB;MACA,MAAMA,MAAM,GAAG,CAAC,CAAC;MACjB,IAAItC,EAAE,CAAC6C,WAAW,CAAC,CAAC,EAAE;QAAA,IAAAC,qBAAA,EAAAC,qBAAA;QAClB,MAAMC,KAAK,GAAGhD,EAAE,CAACiD,YAAY,CAAC,CAAC;QAC/B,MAAMvC,QAAQ,GAAGV,EAAE,CAACqC,cAAc,CAAC,CAAC;QACpC,IAAIa,OAAO;QACX,IAAIlB,IAAI,EAAE;UACNkB,OAAO,GAAGrB,KAAK,CAACC,OAAO,CAACN,KAAK,CAAC,GAAGA,KAAK,GAAG,CAACA,KAAK,CAAC;QACpD,CAAC,MACI;UACD0B,OAAO,GAAGrB,KAAK,CAACC,OAAO,CAACN,KAAK,CAAC2B,KAAK,CAAC,GAAG3B,KAAK,CAAC2B,KAAK,GAAG,CAAC3B,KAAK,CAAC2B,KAAK,CAAC;QACtE;QACA,MAAMC,WAAW,IAAAN,qBAAA,GAAGE,KAAK,CAACtB,eAAe,CAAC,CAAC,CAACc,OAAO,cAAAM,qBAAA,cAAAA,qBAAA,GAAI,KAAK;QAC5D,MAAMO,aAAa,IAAAN,qBAAA,GAAGrC,QAAQ,CAACgB,eAAe,CAAC,CAAC,CAACc,OAAO,cAAAO,qBAAA,cAAAA,qBAAA,GAAI,OAAO;QACnE,KAAK,MAAMI,KAAK,IAAID,OAAO,EAAE;UACzB,MAAMrD,GAAG,GAAGsD,KAAK,CAACC,WAAW,CAAC;UAC9B,MAAM5B,KAAK,GAAG2B,KAAK,CAACE,aAAa,CAAC;UAClC,IAAI7B,KAAK,IAAI,IAAI,IAAIO,MAAM,EAAE;YACzBO,MAAM,CAACzC,GAAG,CAAC,GAAG,IAAI,CAACyB,UAAU,CAACZ,QAAQ,EAAEc,KAAK,CAAC;UAClD;QACJ;QACA,OAAOc,MAAM;MACjB;MACA,IAAItC,EAAE,CAACK,cAAc,CAAC,CAAC,EAAE;QACrB,KAAK,MAAM,CAACS,UAAU,EAAEwC,YAAY,CAAC,IAAItD,EAAE,CAACuD,cAAc,CAAC,CAAC,EAAE;UAAA,IAAAC,qBAAA,EAAAC,qBAAA;UAC1D,MAAMC,YAAY,GAAGJ,YAAY,CAAC5B,eAAe,CAAC,CAAC;UACnD,MAAMiC,YAAY,GAAG,CAACD,YAAY,CAACE,WAAW,IAAAJ,qBAAA,GACxCF,YAAY,CAAC3C,eAAe,CAAC,CAAC,CAAC6B,OAAO,cAAAgB,qBAAA,cAAAA,qBAAA,GAAI1C,UAAU,IAAA2C,qBAAA,GACpDC,YAAY,CAAClB,OAAO,cAAAiB,qBAAA,cAAAA,qBAAA,GAAIH,YAAY,CAACO,OAAO,CAAC,CAAC;UACpD,IAAIrC,KAAK,CAACmC,YAAY,CAAC,IAAI,IAAI,EAAE;YAC7BrB,MAAM,CAACxB,UAAU,CAAC,GAAG,IAAI,CAACQ,UAAU,CAACgC,YAAY,EAAE9B,KAAK,CAACmC,YAAY,CAAC,CAAC;UAC3E;QACJ;QACA,OAAOrB,MAAM;MACjB;MACA,IAAItC,EAAE,CAAC8D,gBAAgB,CAAC,CAAC,EAAE;QACvB,OAAOtC,KAAK;MAChB;MACA,MAAM,IAAIuC,KAAK,yEAAAC,MAAA,CAAyEhE,EAAE,CAAC6D,OAAO,CAAC,IAAI,CAAC,CAAE,CAAC;IAC/G,CAAC,MACI;MACD,IAAI7D,EAAE,CAAC4B,YAAY,CAAC,CAAC,EAAE;QACnB,OAAO,EAAE;MACb,CAAC,MACI,IAAI5B,EAAE,CAAC6C,WAAW,CAAC,CAAC,IAAI7C,EAAE,CAACK,cAAc,CAAC,CAAC,EAAE;QAC9C,OAAO,CAAC,CAAC;MACb;MACA,OAAO,IAAI,CAACd,kBAAkB,CAACG,IAAI,CAACM,EAAE,EAAEwB,KAAK,CAAC;IAClD;EACJ;EACAH,QAAQA,CAAC4C,GAAG,EAAE;IACV,IAAIA,GAAG,CAACC,MAAM,EAAE;MACZ,MAAMC,MAAM,GAAG,IAAIlF,SAAS,CAAC;QACzBmF,mBAAmB,EAAE,EAAE;QACvBC,YAAY,EAAE,IAAI;QAClBC,gBAAgB,EAAE,KAAK;QACvBC,iBAAiB,EAAE,IAAI;QACvBC,aAAa,EAAE,KAAK;QACpBC,UAAU,EAAE,KAAK;QACjBC,iBAAiB,EAAEA,CAACC,CAAC,EAAEC,GAAG,KAAMA,GAAG,CAACC,IAAI,CAAC,CAAC,KAAK,EAAE,IAAID,GAAG,CAACE,QAAQ,CAAC,IAAI,CAAC,GAAG,EAAE,GAAGC;MACnF,CAAC,CAAC;MACFZ,MAAM,CAACa,SAAS,CAAC,KAAK,EAAE,IAAI,CAAC;MAC7Bb,MAAM,CAACa,SAAS,CAAC,KAAK,EAAE,IAAI,CAAC;MAC7B,IAAIC,SAAS;MACb,IAAI;QACAA,SAAS,GAAGd,MAAM,CAACe,KAAK,CAACjB,GAAG,EAAE,IAAI,CAAC;MACvC,CAAC,CACD,OAAOkB,CAAC,EAAE;QACN,IAAIA,CAAC,IAAI,OAAOA,CAAC,KAAK,QAAQ,EAAE;UAC5B5E,MAAM,CAAC6E,cAAc,CAACD,CAAC,EAAE,mBAAmB,EAAE;YAC1C3D,KAAK,EAAEyC;UACX,CAAC,CAAC;QACN;QACA,MAAMkB,CAAC;MACX;MACA,MAAME,YAAY,GAAG,OAAO;MAC5B,MAAMxF,GAAG,GAAGU,MAAM,CAACQ,IAAI,CAACkE,SAAS,CAAC,CAAC,CAAC,CAAC;MACrC,MAAMK,iBAAiB,GAAGL,SAAS,CAACpF,GAAG,CAAC;MACxC,IAAIyF,iBAAiB,CAACD,YAAY,CAAC,EAAE;QACjCC,iBAAiB,CAACzF,GAAG,CAAC,GAAGyF,iBAAiB,CAACD,YAAY,CAAC;QACxD,OAAOC,iBAAiB,CAACD,YAAY,CAAC;MAC1C;MACA,OAAOtG,oBAAoB,CAACuG,iBAAiB,CAAC;IAClD;IACA,OAAO,CAAC,CAAC;EACb;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
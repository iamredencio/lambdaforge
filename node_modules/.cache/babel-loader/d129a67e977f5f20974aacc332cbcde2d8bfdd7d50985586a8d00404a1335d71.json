{"ast":null,"code":"export const parseBoolean = value => {\n  switch (value) {\n    case \"true\":\n      return true;\n    case \"false\":\n      return false;\n    default:\n      throw new Error(\"Unable to parse boolean value \\\"\".concat(value, \"\\\"\"));\n  }\n};\nexport const expectBoolean = value => {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n  if (typeof value === \"number\") {\n    if (value === 0 || value === 1) {\n      logger.warn(stackTraceWarning(\"Expected boolean, got \".concat(typeof value, \": \").concat(value)));\n    }\n    if (value === 0) {\n      return false;\n    }\n    if (value === 1) {\n      return true;\n    }\n  }\n  if (typeof value === \"string\") {\n    const lower = value.toLowerCase();\n    if (lower === \"false\" || lower === \"true\") {\n      logger.warn(stackTraceWarning(\"Expected boolean, got \".concat(typeof value, \": \").concat(value)));\n    }\n    if (lower === \"false\") {\n      return false;\n    }\n    if (lower === \"true\") {\n      return true;\n    }\n  }\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  throw new TypeError(\"Expected boolean, got \".concat(typeof value, \": \").concat(value));\n};\nexport const expectNumber = value => {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n  if (typeof value === \"string\") {\n    const parsed = parseFloat(value);\n    if (!Number.isNaN(parsed)) {\n      if (String(parsed) !== String(value)) {\n        logger.warn(stackTraceWarning(\"Expected number but observed string: \".concat(value)));\n      }\n      return parsed;\n    }\n  }\n  if (typeof value === \"number\") {\n    return value;\n  }\n  throw new TypeError(\"Expected number, got \".concat(typeof value, \": \").concat(value));\n};\nconst MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));\nexport const expectFloat32 = value => {\n  const expected = expectNumber(value);\n  if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {\n    if (Math.abs(expected) > MAX_FLOAT) {\n      throw new TypeError(\"Expected 32-bit float, got \".concat(value));\n    }\n  }\n  return expected;\n};\nexport const expectLong = value => {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n  if (Number.isInteger(value) && !Number.isNaN(value)) {\n    return value;\n  }\n  throw new TypeError(\"Expected integer, got \".concat(typeof value, \": \").concat(value));\n};\nexport const expectInt = expectLong;\nexport const expectInt32 = value => expectSizedInt(value, 32);\nexport const expectShort = value => expectSizedInt(value, 16);\nexport const expectByte = value => expectSizedInt(value, 8);\nconst expectSizedInt = (value, size) => {\n  const expected = expectLong(value);\n  if (expected !== undefined && castInt(expected, size) !== expected) {\n    throw new TypeError(\"Expected \".concat(size, \"-bit integer, got \").concat(value));\n  }\n  return expected;\n};\nconst castInt = (value, size) => {\n  switch (size) {\n    case 32:\n      return Int32Array.of(value)[0];\n    case 16:\n      return Int16Array.of(value)[0];\n    case 8:\n      return Int8Array.of(value)[0];\n  }\n};\nexport const expectNonNull = (value, location) => {\n  if (value === null || value === undefined) {\n    if (location) {\n      throw new TypeError(\"Expected a non-null value for \".concat(location));\n    }\n    throw new TypeError(\"Expected a non-null value\");\n  }\n  return value;\n};\nexport const expectObject = value => {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n  if (typeof value === \"object\" && !Array.isArray(value)) {\n    return value;\n  }\n  const receivedType = Array.isArray(value) ? \"array\" : typeof value;\n  throw new TypeError(\"Expected object, got \".concat(receivedType, \": \").concat(value));\n};\nexport const expectString = value => {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n  if (typeof value === \"string\") {\n    return value;\n  }\n  if ([\"boolean\", \"number\", \"bigint\"].includes(typeof value)) {\n    logger.warn(stackTraceWarning(\"Expected string, got \".concat(typeof value, \": \").concat(value)));\n    return String(value);\n  }\n  throw new TypeError(\"Expected string, got \".concat(typeof value, \": \").concat(value));\n};\nexport const expectUnion = value => {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n  const asObject = expectObject(value);\n  const setKeys = Object.entries(asObject).filter(_ref => {\n    let [, v] = _ref;\n    return v != null;\n  }).map(_ref2 => {\n    let [k] = _ref2;\n    return k;\n  });\n  if (setKeys.length === 0) {\n    throw new TypeError(\"Unions must have exactly one non-null member. None were found.\");\n  }\n  if (setKeys.length > 1) {\n    throw new TypeError(\"Unions must have exactly one non-null member. Keys \".concat(setKeys, \" were not null.\"));\n  }\n  return asObject;\n};\nexport const strictParseDouble = value => {\n  if (typeof value == \"string\") {\n    return expectNumber(parseNumber(value));\n  }\n  return expectNumber(value);\n};\nexport const strictParseFloat = strictParseDouble;\nexport const strictParseFloat32 = value => {\n  if (typeof value == \"string\") {\n    return expectFloat32(parseNumber(value));\n  }\n  return expectFloat32(value);\n};\nconst NUMBER_REGEX = /(-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)|(-?Infinity)|(NaN)/g;\nconst parseNumber = value => {\n  const matches = value.match(NUMBER_REGEX);\n  if (matches === null || matches[0].length !== value.length) {\n    throw new TypeError(\"Expected real number, got implicit NaN\");\n  }\n  return parseFloat(value);\n};\nexport const limitedParseDouble = value => {\n  if (typeof value == \"string\") {\n    return parseFloatString(value);\n  }\n  return expectNumber(value);\n};\nexport const handleFloat = limitedParseDouble;\nexport const limitedParseFloat = limitedParseDouble;\nexport const limitedParseFloat32 = value => {\n  if (typeof value == \"string\") {\n    return parseFloatString(value);\n  }\n  return expectFloat32(value);\n};\nconst parseFloatString = value => {\n  switch (value) {\n    case \"NaN\":\n      return NaN;\n    case \"Infinity\":\n      return Infinity;\n    case \"-Infinity\":\n      return -Infinity;\n    default:\n      throw new Error(\"Unable to parse float value: \".concat(value));\n  }\n};\nexport const strictParseLong = value => {\n  if (typeof value === \"string\") {\n    return expectLong(parseNumber(value));\n  }\n  return expectLong(value);\n};\nexport const strictParseInt = strictParseLong;\nexport const strictParseInt32 = value => {\n  if (typeof value === \"string\") {\n    return expectInt32(parseNumber(value));\n  }\n  return expectInt32(value);\n};\nexport const strictParseShort = value => {\n  if (typeof value === \"string\") {\n    return expectShort(parseNumber(value));\n  }\n  return expectShort(value);\n};\nexport const strictParseByte = value => {\n  if (typeof value === \"string\") {\n    return expectByte(parseNumber(value));\n  }\n  return expectByte(value);\n};\nconst stackTraceWarning = message => {\n  return String(new TypeError(message).stack || message).split(\"\\n\").slice(0, 5).filter(s => !s.includes(\"stackTraceWarning\")).join(\"\\n\");\n};\nexport const logger = {\n  warn: console.warn\n};","map":{"version":3,"names":["parseBoolean","value","Error","concat","expectBoolean","undefined","logger","warn","stackTraceWarning","lower","toLowerCase","TypeError","expectNumber","parsed","parseFloat","Number","isNaN","String","MAX_FLOAT","Math","ceil","expectFloat32","expected","Infinity","abs","expectLong","isInteger","expectInt","expectInt32","expectSizedInt","expectShort","expectByte","size","castInt","Int32Array","of","Int16Array","Int8Array","expectNonNull","location","expectObject","Array","isArray","receivedType","expectString","includes","expectUnion","asObject","setKeys","Object","entries","filter","_ref","v","map","_ref2","k","length","strictParseDouble","parseNumber","strictParseFloat","strictParseFloat32","NUMBER_REGEX","matches","match","limitedParseDouble","parseFloatString","handleFloat","limitedParseFloat","limitedParseFloat32","NaN","strictParseLong","strictParseInt","strictParseInt32","strictParseShort","strictParseByte","message","stack","split","slice","s","join","console"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/@smithy/core/dist-es/submodules/serde/parse-utils.js"],"sourcesContent":["export const parseBoolean = (value) => {\n    switch (value) {\n        case \"true\":\n            return true;\n        case \"false\":\n            return false;\n        default:\n            throw new Error(`Unable to parse boolean value \"${value}\"`);\n    }\n};\nexport const expectBoolean = (value) => {\n    if (value === null || value === undefined) {\n        return undefined;\n    }\n    if (typeof value === \"number\") {\n        if (value === 0 || value === 1) {\n            logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));\n        }\n        if (value === 0) {\n            return false;\n        }\n        if (value === 1) {\n            return true;\n        }\n    }\n    if (typeof value === \"string\") {\n        const lower = value.toLowerCase();\n        if (lower === \"false\" || lower === \"true\") {\n            logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));\n        }\n        if (lower === \"false\") {\n            return false;\n        }\n        if (lower === \"true\") {\n            return true;\n        }\n    }\n    if (typeof value === \"boolean\") {\n        return value;\n    }\n    throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);\n};\nexport const expectNumber = (value) => {\n    if (value === null || value === undefined) {\n        return undefined;\n    }\n    if (typeof value === \"string\") {\n        const parsed = parseFloat(value);\n        if (!Number.isNaN(parsed)) {\n            if (String(parsed) !== String(value)) {\n                logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));\n            }\n            return parsed;\n        }\n    }\n    if (typeof value === \"number\") {\n        return value;\n    }\n    throw new TypeError(`Expected number, got ${typeof value}: ${value}`);\n};\nconst MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));\nexport const expectFloat32 = (value) => {\n    const expected = expectNumber(value);\n    if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {\n        if (Math.abs(expected) > MAX_FLOAT) {\n            throw new TypeError(`Expected 32-bit float, got ${value}`);\n        }\n    }\n    return expected;\n};\nexport const expectLong = (value) => {\n    if (value === null || value === undefined) {\n        return undefined;\n    }\n    if (Number.isInteger(value) && !Number.isNaN(value)) {\n        return value;\n    }\n    throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);\n};\nexport const expectInt = expectLong;\nexport const expectInt32 = (value) => expectSizedInt(value, 32);\nexport const expectShort = (value) => expectSizedInt(value, 16);\nexport const expectByte = (value) => expectSizedInt(value, 8);\nconst expectSizedInt = (value, size) => {\n    const expected = expectLong(value);\n    if (expected !== undefined && castInt(expected, size) !== expected) {\n        throw new TypeError(`Expected ${size}-bit integer, got ${value}`);\n    }\n    return expected;\n};\nconst castInt = (value, size) => {\n    switch (size) {\n        case 32:\n            return Int32Array.of(value)[0];\n        case 16:\n            return Int16Array.of(value)[0];\n        case 8:\n            return Int8Array.of(value)[0];\n    }\n};\nexport const expectNonNull = (value, location) => {\n    if (value === null || value === undefined) {\n        if (location) {\n            throw new TypeError(`Expected a non-null value for ${location}`);\n        }\n        throw new TypeError(\"Expected a non-null value\");\n    }\n    return value;\n};\nexport const expectObject = (value) => {\n    if (value === null || value === undefined) {\n        return undefined;\n    }\n    if (typeof value === \"object\" && !Array.isArray(value)) {\n        return value;\n    }\n    const receivedType = Array.isArray(value) ? \"array\" : typeof value;\n    throw new TypeError(`Expected object, got ${receivedType}: ${value}`);\n};\nexport const expectString = (value) => {\n    if (value === null || value === undefined) {\n        return undefined;\n    }\n    if (typeof value === \"string\") {\n        return value;\n    }\n    if ([\"boolean\", \"number\", \"bigint\"].includes(typeof value)) {\n        logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));\n        return String(value);\n    }\n    throw new TypeError(`Expected string, got ${typeof value}: ${value}`);\n};\nexport const expectUnion = (value) => {\n    if (value === null || value === undefined) {\n        return undefined;\n    }\n    const asObject = expectObject(value);\n    const setKeys = Object.entries(asObject)\n        .filter(([, v]) => v != null)\n        .map(([k]) => k);\n    if (setKeys.length === 0) {\n        throw new TypeError(`Unions must have exactly one non-null member. None were found.`);\n    }\n    if (setKeys.length > 1) {\n        throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);\n    }\n    return asObject;\n};\nexport const strictParseDouble = (value) => {\n    if (typeof value == \"string\") {\n        return expectNumber(parseNumber(value));\n    }\n    return expectNumber(value);\n};\nexport const strictParseFloat = strictParseDouble;\nexport const strictParseFloat32 = (value) => {\n    if (typeof value == \"string\") {\n        return expectFloat32(parseNumber(value));\n    }\n    return expectFloat32(value);\n};\nconst NUMBER_REGEX = /(-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)|(-?Infinity)|(NaN)/g;\nconst parseNumber = (value) => {\n    const matches = value.match(NUMBER_REGEX);\n    if (matches === null || matches[0].length !== value.length) {\n        throw new TypeError(`Expected real number, got implicit NaN`);\n    }\n    return parseFloat(value);\n};\nexport const limitedParseDouble = (value) => {\n    if (typeof value == \"string\") {\n        return parseFloatString(value);\n    }\n    return expectNumber(value);\n};\nexport const handleFloat = limitedParseDouble;\nexport const limitedParseFloat = limitedParseDouble;\nexport const limitedParseFloat32 = (value) => {\n    if (typeof value == \"string\") {\n        return parseFloatString(value);\n    }\n    return expectFloat32(value);\n};\nconst parseFloatString = (value) => {\n    switch (value) {\n        case \"NaN\":\n            return NaN;\n        case \"Infinity\":\n            return Infinity;\n        case \"-Infinity\":\n            return -Infinity;\n        default:\n            throw new Error(`Unable to parse float value: ${value}`);\n    }\n};\nexport const strictParseLong = (value) => {\n    if (typeof value === \"string\") {\n        return expectLong(parseNumber(value));\n    }\n    return expectLong(value);\n};\nexport const strictParseInt = strictParseLong;\nexport const strictParseInt32 = (value) => {\n    if (typeof value === \"string\") {\n        return expectInt32(parseNumber(value));\n    }\n    return expectInt32(value);\n};\nexport const strictParseShort = (value) => {\n    if (typeof value === \"string\") {\n        return expectShort(parseNumber(value));\n    }\n    return expectShort(value);\n};\nexport const strictParseByte = (value) => {\n    if (typeof value === \"string\") {\n        return expectByte(parseNumber(value));\n    }\n    return expectByte(value);\n};\nconst stackTraceWarning = (message) => {\n    return String(new TypeError(message).stack || message)\n        .split(\"\\n\")\n        .slice(0, 5)\n        .filter((s) => !s.includes(\"stackTraceWarning\"))\n        .join(\"\\n\");\n};\nexport const logger = {\n    warn: console.warn,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
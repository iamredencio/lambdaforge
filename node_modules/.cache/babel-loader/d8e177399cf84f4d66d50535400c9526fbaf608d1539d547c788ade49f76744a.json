{"ast":null,"code":"import { toHex } from \"@smithy/util-hex-encoding\";\nimport { normalizeProvider } from \"@smithy/util-middleware\";\nimport { escapeUri } from \"@smithy/util-uri-escape\";\nimport { toUint8Array } from \"@smithy/util-utf8\";\nimport { getCanonicalQuery } from \"./getCanonicalQuery\";\nimport { iso8601 } from \"./utilDate\";\nexport class SignatureV4Base {\n  constructor(_ref) {\n    let {\n      applyChecksum,\n      credentials,\n      region,\n      service,\n      sha256,\n      uriEscapePath = true\n    } = _ref;\n    this.service = service;\n    this.sha256 = sha256;\n    this.uriEscapePath = uriEscapePath;\n    this.applyChecksum = typeof applyChecksum === \"boolean\" ? applyChecksum : true;\n    this.regionProvider = normalizeProvider(region);\n    this.credentialProvider = normalizeProvider(credentials);\n  }\n  createCanonicalRequest(request, canonicalHeaders, payloadHash) {\n    const sortedHeaders = Object.keys(canonicalHeaders).sort();\n    return \"\".concat(request.method, \"\\n\").concat(this.getCanonicalPath(request), \"\\n\").concat(getCanonicalQuery(request), \"\\n\").concat(sortedHeaders.map(name => \"\".concat(name, \":\").concat(canonicalHeaders[name])).join(\"\\n\"), \"\\n\\n\").concat(sortedHeaders.join(\";\"), \"\\n\").concat(payloadHash);\n  }\n  async createStringToSign(longDate, credentialScope, canonicalRequest, algorithmIdentifier) {\n    const hash = new this.sha256();\n    hash.update(toUint8Array(canonicalRequest));\n    const hashedRequest = await hash.digest();\n    return \"\".concat(algorithmIdentifier, \"\\n\").concat(longDate, \"\\n\").concat(credentialScope, \"\\n\").concat(toHex(hashedRequest));\n  }\n  getCanonicalPath(_ref2) {\n    let {\n      path\n    } = _ref2;\n    if (this.uriEscapePath) {\n      const normalizedPathSegments = [];\n      for (const pathSegment of path.split(\"/\")) {\n        if ((pathSegment === null || pathSegment === void 0 ? void 0 : pathSegment.length) === 0) continue;\n        if (pathSegment === \".\") continue;\n        if (pathSegment === \"..\") {\n          normalizedPathSegments.pop();\n        } else {\n          normalizedPathSegments.push(pathSegment);\n        }\n      }\n      const normalizedPath = \"\".concat(path !== null && path !== void 0 && path.startsWith(\"/\") ? \"/\" : \"\").concat(normalizedPathSegments.join(\"/\")).concat(normalizedPathSegments.length > 0 && path !== null && path !== void 0 && path.endsWith(\"/\") ? \"/\" : \"\");\n      const doubleEncoded = escapeUri(normalizedPath);\n      return doubleEncoded.replace(/%2F/g, \"/\");\n    }\n    return path;\n  }\n  validateResolvedCredentials(credentials) {\n    if (typeof credentials !== \"object\" || typeof credentials.accessKeyId !== \"string\" || typeof credentials.secretAccessKey !== \"string\") {\n      throw new Error(\"Resolved credential object is not valid\");\n    }\n  }\n  formatDate(now) {\n    const longDate = iso8601(now).replace(/[\\-:]/g, \"\");\n    return {\n      longDate,\n      shortDate: longDate.slice(0, 8)\n    };\n  }\n  getCanonicalHeaderList(headers) {\n    return Object.keys(headers).sort().join(\";\");\n  }\n}","map":{"version":3,"names":["toHex","normalizeProvider","escapeUri","toUint8Array","getCanonicalQuery","iso8601","SignatureV4Base","constructor","_ref","applyChecksum","credentials","region","service","sha256","uriEscapePath","regionProvider","credentialProvider","createCanonicalRequest","request","canonicalHeaders","payloadHash","sortedHeaders","Object","keys","sort","concat","method","getCanonicalPath","map","name","join","createStringToSign","longDate","credentialScope","canonicalRequest","algorithmIdentifier","hash","update","hashedRequest","digest","_ref2","path","normalizedPathSegments","pathSegment","split","length","pop","push","normalizedPath","startsWith","endsWith","doubleEncoded","replace","validateResolvedCredentials","accessKeyId","secretAccessKey","Error","formatDate","now","shortDate","slice","getCanonicalHeaderList","headers"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/@smithy/signature-v4/dist-es/SignatureV4Base.js"],"sourcesContent":["import { toHex } from \"@smithy/util-hex-encoding\";\nimport { normalizeProvider } from \"@smithy/util-middleware\";\nimport { escapeUri } from \"@smithy/util-uri-escape\";\nimport { toUint8Array } from \"@smithy/util-utf8\";\nimport { getCanonicalQuery } from \"./getCanonicalQuery\";\nimport { iso8601 } from \"./utilDate\";\nexport class SignatureV4Base {\n    constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true, }) {\n        this.service = service;\n        this.sha256 = sha256;\n        this.uriEscapePath = uriEscapePath;\n        this.applyChecksum = typeof applyChecksum === \"boolean\" ? applyChecksum : true;\n        this.regionProvider = normalizeProvider(region);\n        this.credentialProvider = normalizeProvider(credentials);\n    }\n    createCanonicalRequest(request, canonicalHeaders, payloadHash) {\n        const sortedHeaders = Object.keys(canonicalHeaders).sort();\n        return `${request.method}\n${this.getCanonicalPath(request)}\n${getCanonicalQuery(request)}\n${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join(\"\\n\")}\n\n${sortedHeaders.join(\";\")}\n${payloadHash}`;\n    }\n    async createStringToSign(longDate, credentialScope, canonicalRequest, algorithmIdentifier) {\n        const hash = new this.sha256();\n        hash.update(toUint8Array(canonicalRequest));\n        const hashedRequest = await hash.digest();\n        return `${algorithmIdentifier}\n${longDate}\n${credentialScope}\n${toHex(hashedRequest)}`;\n    }\n    getCanonicalPath({ path }) {\n        if (this.uriEscapePath) {\n            const normalizedPathSegments = [];\n            for (const pathSegment of path.split(\"/\")) {\n                if (pathSegment?.length === 0)\n                    continue;\n                if (pathSegment === \".\")\n                    continue;\n                if (pathSegment === \"..\") {\n                    normalizedPathSegments.pop();\n                }\n                else {\n                    normalizedPathSegments.push(pathSegment);\n                }\n            }\n            const normalizedPath = `${path?.startsWith(\"/\") ? \"/\" : \"\"}${normalizedPathSegments.join(\"/\")}${normalizedPathSegments.length > 0 && path?.endsWith(\"/\") ? \"/\" : \"\"}`;\n            const doubleEncoded = escapeUri(normalizedPath);\n            return doubleEncoded.replace(/%2F/g, \"/\");\n        }\n        return path;\n    }\n    validateResolvedCredentials(credentials) {\n        if (typeof credentials !== \"object\" ||\n            typeof credentials.accessKeyId !== \"string\" ||\n            typeof credentials.secretAccessKey !== \"string\") {\n            throw new Error(\"Resolved credential object is not valid\");\n        }\n    }\n    formatDate(now) {\n        const longDate = iso8601(now).replace(/[\\-:]/g, \"\");\n        return {\n            longDate,\n            shortDate: longDate.slice(0, 8),\n        };\n    }\n    getCanonicalHeaderList(headers) {\n        return Object.keys(headers).sort().join(\";\");\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
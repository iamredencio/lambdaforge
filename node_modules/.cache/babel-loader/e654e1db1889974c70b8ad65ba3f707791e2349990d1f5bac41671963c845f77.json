{"ast":null,"code":"import { NormalizedSchema, SCHEMA } from \"@smithy/core/schema\";\nimport { splitEvery, splitHeader } from \"@smithy/core/serde\";\nimport { HttpRequest, HttpResponse } from \"@smithy/protocol-http\";\nimport { sdkStreamMixin } from \"@smithy/util-stream\";\nimport { collectBody } from \"./collect-stream-body\";\nexport class HttpProtocol {\n  constructor(options) {\n    this.options = options;\n  }\n  getRequestType() {\n    return HttpRequest;\n  }\n  getResponseType() {\n    return HttpResponse;\n  }\n  setSerdeContext(serdeContext) {\n    this.serdeContext = serdeContext;\n    this.serializer.setSerdeContext(serdeContext);\n    this.deserializer.setSerdeContext(serdeContext);\n    if (this.getPayloadCodec()) {\n      this.getPayloadCodec().setSerdeContext(serdeContext);\n    }\n  }\n  updateServiceEndpoint(request, endpoint) {\n    if (\"url\" in endpoint) {\n      request.protocol = endpoint.url.protocol;\n      request.hostname = endpoint.url.hostname;\n      request.port = endpoint.url.port ? Number(endpoint.url.port) : undefined;\n      request.path = endpoint.url.pathname;\n      request.fragment = endpoint.url.hash || void 0;\n      request.username = endpoint.url.username || void 0;\n      request.password = endpoint.url.password || void 0;\n      for (const [k, v] of endpoint.url.searchParams.entries()) {\n        if (!request.query) {\n          request.query = {};\n        }\n        request.query[k] = v;\n      }\n      return request;\n    } else {\n      request.protocol = endpoint.protocol;\n      request.hostname = endpoint.hostname;\n      request.port = endpoint.port ? Number(endpoint.port) : undefined;\n      request.path = endpoint.path;\n      request.query = {\n        ...endpoint.query\n      };\n      return request;\n    }\n  }\n  setHostPrefix(request, operationSchema, input) {\n    const operationNs = NormalizedSchema.of(operationSchema);\n    const inputNs = NormalizedSchema.of(operationSchema.input);\n    if (operationNs.getMergedTraits().endpoint) {\n      let hostPrefix = operationNs.getMergedTraits().endpoint?.[0];\n      if (typeof hostPrefix === \"string\") {\n        const hostLabelInputs = [...inputNs.structIterator()].filter(([, member]) => member.getMergedTraits().hostLabel);\n        for (const [name] of hostLabelInputs) {\n          const replacement = input[name];\n          if (typeof replacement !== \"string\") {\n            throw new Error(`@smithy/core/schema - ${name} in input must be a string as hostLabel.`);\n          }\n          hostPrefix = hostPrefix.replace(`{${name}}`, replacement);\n        }\n        request.hostname = hostPrefix + request.hostname;\n      }\n    }\n  }\n  deserializeMetadata(output) {\n    return {\n      httpStatusCode: output.statusCode,\n      requestId: output.headers[\"x-amzn-requestid\"] ?? output.headers[\"x-amzn-request-id\"] ?? output.headers[\"x-amz-request-id\"],\n      extendedRequestId: output.headers[\"x-amz-id-2\"],\n      cfId: output.headers[\"x-amz-cf-id\"]\n    };\n  }\n  async deserializeHttpMessage(schema, context, response, arg4, arg5) {\n    let dataObject;\n    if (arg4 instanceof Set) {\n      dataObject = arg5;\n    } else {\n      dataObject = arg4;\n    }\n    const deserializer = this.deserializer;\n    const ns = NormalizedSchema.of(schema);\n    const nonHttpBindingMembers = [];\n    for (const [memberName, memberSchema] of ns.structIterator()) {\n      const memberTraits = memberSchema.getMemberTraits();\n      if (memberTraits.httpPayload) {\n        const isStreaming = memberSchema.isStreaming();\n        if (isStreaming) {\n          const isEventStream = memberSchema.isStructSchema();\n          if (isEventStream) {\n            const context = this.serdeContext;\n            if (!context.eventStreamMarshaller) {\n              throw new Error(\"@smithy/core - HttpProtocol: eventStreamMarshaller missing in serdeContext.\");\n            }\n            const memberSchemas = memberSchema.getMemberSchemas();\n            dataObject[memberName] = context.eventStreamMarshaller.deserialize(response.body, async event => {\n              const unionMember = Object.keys(event).find(key => {\n                return key !== \"__type\";\n              }) ?? \"\";\n              if (unionMember in memberSchemas) {\n                const eventStreamSchema = memberSchemas[unionMember];\n                return {\n                  [unionMember]: await deserializer.read(eventStreamSchema, event[unionMember].body)\n                };\n              } else {\n                return {\n                  $unknown: event\n                };\n              }\n            });\n          } else {\n            dataObject[memberName] = sdkStreamMixin(response.body);\n          }\n        } else if (response.body) {\n          const bytes = await collectBody(response.body, context);\n          if (bytes.byteLength > 0) {\n            dataObject[memberName] = await deserializer.read(memberSchema, bytes);\n          }\n        }\n      } else if (memberTraits.httpHeader) {\n        const key = String(memberTraits.httpHeader).toLowerCase();\n        const value = response.headers[key];\n        if (null != value) {\n          if (memberSchema.isListSchema()) {\n            const headerListValueSchema = memberSchema.getValueSchema();\n            let sections;\n            if (headerListValueSchema.isTimestampSchema() && headerListValueSchema.getSchema() === SCHEMA.TIMESTAMP_DEFAULT) {\n              sections = splitEvery(value, \",\", 2);\n            } else {\n              sections = splitHeader(value);\n            }\n            const list = [];\n            for (const section of sections) {\n              list.push(await deserializer.read([headerListValueSchema, {\n                httpHeader: key\n              }], section.trim()));\n            }\n            dataObject[memberName] = list;\n          } else {\n            dataObject[memberName] = await deserializer.read(memberSchema, value);\n          }\n        }\n      } else if (memberTraits.httpPrefixHeaders !== undefined) {\n        dataObject[memberName] = {};\n        for (const [header, value] of Object.entries(response.headers)) {\n          if (header.startsWith(memberTraits.httpPrefixHeaders)) {\n            dataObject[memberName][header.slice(memberTraits.httpPrefixHeaders.length)] = await deserializer.read([memberSchema.getValueSchema(), {\n              httpHeader: header\n            }], value);\n          }\n        }\n      } else if (memberTraits.httpResponseCode) {\n        dataObject[memberName] = response.statusCode;\n      } else {\n        nonHttpBindingMembers.push(memberName);\n      }\n    }\n    return nonHttpBindingMembers;\n  }\n}","map":{"version":3,"names":["NormalizedSchema","SCHEMA","splitEvery","splitHeader","HttpRequest","HttpResponse","sdkStreamMixin","collectBody","HttpProtocol","constructor","options","getRequestType","getResponseType","setSerdeContext","serdeContext","serializer","deserializer","getPayloadCodec","updateServiceEndpoint","request","endpoint","protocol","url","hostname","port","Number","undefined","path","pathname","fragment","hash","username","password","k","v","searchParams","entries","query","setHostPrefix","operationSchema","input","operationNs","of","inputNs","getMergedTraits","hostPrefix","hostLabelInputs","structIterator","filter","member","hostLabel","name","replacement","Error","replace","deserializeMetadata","output","httpStatusCode","statusCode","requestId","headers","extendedRequestId","cfId","deserializeHttpMessage","schema","context","response","arg4","arg5","dataObject","Set","ns","nonHttpBindingMembers","memberName","memberSchema","memberTraits","getMemberTraits","httpPayload","isStreaming","isEventStream","isStructSchema","eventStreamMarshaller","memberSchemas","getMemberSchemas","deserialize","body","event","unionMember","Object","keys","find","key","eventStreamSchema","read","$unknown","bytes","byteLength","httpHeader","String","toLowerCase","value","isListSchema","headerListValueSchema","getValueSchema","sections","isTimestampSchema","getSchema","TIMESTAMP_DEFAULT","list","section","push","trim","httpPrefixHeaders","header","startsWith","slice","length","httpResponseCode"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/@smithy/core/dist-es/submodules/protocols/HttpProtocol.js"],"sourcesContent":["import { NormalizedSchema, SCHEMA } from \"@smithy/core/schema\";\nimport { splitEvery, splitHeader } from \"@smithy/core/serde\";\nimport { HttpRequest, HttpResponse } from \"@smithy/protocol-http\";\nimport { sdkStreamMixin } from \"@smithy/util-stream\";\nimport { collectBody } from \"./collect-stream-body\";\nexport class HttpProtocol {\n    constructor(options) {\n        this.options = options;\n    }\n    getRequestType() {\n        return HttpRequest;\n    }\n    getResponseType() {\n        return HttpResponse;\n    }\n    setSerdeContext(serdeContext) {\n        this.serdeContext = serdeContext;\n        this.serializer.setSerdeContext(serdeContext);\n        this.deserializer.setSerdeContext(serdeContext);\n        if (this.getPayloadCodec()) {\n            this.getPayloadCodec().setSerdeContext(serdeContext);\n        }\n    }\n    updateServiceEndpoint(request, endpoint) {\n        if (\"url\" in endpoint) {\n            request.protocol = endpoint.url.protocol;\n            request.hostname = endpoint.url.hostname;\n            request.port = endpoint.url.port ? Number(endpoint.url.port) : undefined;\n            request.path = endpoint.url.pathname;\n            request.fragment = endpoint.url.hash || void 0;\n            request.username = endpoint.url.username || void 0;\n            request.password = endpoint.url.password || void 0;\n            for (const [k, v] of endpoint.url.searchParams.entries()) {\n                if (!request.query) {\n                    request.query = {};\n                }\n                request.query[k] = v;\n            }\n            return request;\n        }\n        else {\n            request.protocol = endpoint.protocol;\n            request.hostname = endpoint.hostname;\n            request.port = endpoint.port ? Number(endpoint.port) : undefined;\n            request.path = endpoint.path;\n            request.query = {\n                ...endpoint.query,\n            };\n            return request;\n        }\n    }\n    setHostPrefix(request, operationSchema, input) {\n        const operationNs = NormalizedSchema.of(operationSchema);\n        const inputNs = NormalizedSchema.of(operationSchema.input);\n        if (operationNs.getMergedTraits().endpoint) {\n            let hostPrefix = operationNs.getMergedTraits().endpoint?.[0];\n            if (typeof hostPrefix === \"string\") {\n                const hostLabelInputs = [...inputNs.structIterator()].filter(([, member]) => member.getMergedTraits().hostLabel);\n                for (const [name] of hostLabelInputs) {\n                    const replacement = input[name];\n                    if (typeof replacement !== \"string\") {\n                        throw new Error(`@smithy/core/schema - ${name} in input must be a string as hostLabel.`);\n                    }\n                    hostPrefix = hostPrefix.replace(`{${name}}`, replacement);\n                }\n                request.hostname = hostPrefix + request.hostname;\n            }\n        }\n    }\n    deserializeMetadata(output) {\n        return {\n            httpStatusCode: output.statusCode,\n            requestId: output.headers[\"x-amzn-requestid\"] ?? output.headers[\"x-amzn-request-id\"] ?? output.headers[\"x-amz-request-id\"],\n            extendedRequestId: output.headers[\"x-amz-id-2\"],\n            cfId: output.headers[\"x-amz-cf-id\"],\n        };\n    }\n    async deserializeHttpMessage(schema, context, response, arg4, arg5) {\n        let dataObject;\n        if (arg4 instanceof Set) {\n            dataObject = arg5;\n        }\n        else {\n            dataObject = arg4;\n        }\n        const deserializer = this.deserializer;\n        const ns = NormalizedSchema.of(schema);\n        const nonHttpBindingMembers = [];\n        for (const [memberName, memberSchema] of ns.structIterator()) {\n            const memberTraits = memberSchema.getMemberTraits();\n            if (memberTraits.httpPayload) {\n                const isStreaming = memberSchema.isStreaming();\n                if (isStreaming) {\n                    const isEventStream = memberSchema.isStructSchema();\n                    if (isEventStream) {\n                        const context = this.serdeContext;\n                        if (!context.eventStreamMarshaller) {\n                            throw new Error(\"@smithy/core - HttpProtocol: eventStreamMarshaller missing in serdeContext.\");\n                        }\n                        const memberSchemas = memberSchema.getMemberSchemas();\n                        dataObject[memberName] = context.eventStreamMarshaller.deserialize(response.body, async (event) => {\n                            const unionMember = Object.keys(event).find((key) => {\n                                return key !== \"__type\";\n                            }) ?? \"\";\n                            if (unionMember in memberSchemas) {\n                                const eventStreamSchema = memberSchemas[unionMember];\n                                return {\n                                    [unionMember]: await deserializer.read(eventStreamSchema, event[unionMember].body),\n                                };\n                            }\n                            else {\n                                return {\n                                    $unknown: event,\n                                };\n                            }\n                        });\n                    }\n                    else {\n                        dataObject[memberName] = sdkStreamMixin(response.body);\n                    }\n                }\n                else if (response.body) {\n                    const bytes = await collectBody(response.body, context);\n                    if (bytes.byteLength > 0) {\n                        dataObject[memberName] = await deserializer.read(memberSchema, bytes);\n                    }\n                }\n            }\n            else if (memberTraits.httpHeader) {\n                const key = String(memberTraits.httpHeader).toLowerCase();\n                const value = response.headers[key];\n                if (null != value) {\n                    if (memberSchema.isListSchema()) {\n                        const headerListValueSchema = memberSchema.getValueSchema();\n                        let sections;\n                        if (headerListValueSchema.isTimestampSchema() &&\n                            headerListValueSchema.getSchema() === SCHEMA.TIMESTAMP_DEFAULT) {\n                            sections = splitEvery(value, \",\", 2);\n                        }\n                        else {\n                            sections = splitHeader(value);\n                        }\n                        const list = [];\n                        for (const section of sections) {\n                            list.push(await deserializer.read([headerListValueSchema, { httpHeader: key }], section.trim()));\n                        }\n                        dataObject[memberName] = list;\n                    }\n                    else {\n                        dataObject[memberName] = await deserializer.read(memberSchema, value);\n                    }\n                }\n            }\n            else if (memberTraits.httpPrefixHeaders !== undefined) {\n                dataObject[memberName] = {};\n                for (const [header, value] of Object.entries(response.headers)) {\n                    if (header.startsWith(memberTraits.httpPrefixHeaders)) {\n                        dataObject[memberName][header.slice(memberTraits.httpPrefixHeaders.length)] = await deserializer.read([memberSchema.getValueSchema(), { httpHeader: header }], value);\n                    }\n                }\n            }\n            else if (memberTraits.httpResponseCode) {\n                dataObject[memberName] = response.statusCode;\n            }\n            else {\n                nonHttpBindingMembers.push(memberName);\n            }\n        }\n        return nonHttpBindingMembers;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
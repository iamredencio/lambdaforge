{"ast":null,"code":"const EOL = \"\\n\";\n\n/**\n * \n * @param {array} jArray \n * @param {any} options \n * @returns \n */\nfunction toXml(jArray, options) {\n  let indentation = \"\";\n  if (options.format && options.indentBy.length > 0) {\n    indentation = EOL;\n  }\n  return arrToStr(jArray, options, \"\", indentation);\n}\nfunction arrToStr(arr, options, jPath, indentation) {\n  let xmlStr = \"\";\n  let isPreviousElementTag = false;\n  for (let i = 0; i < arr.length; i++) {\n    const tagObj = arr[i];\n    const tagName = propName(tagObj);\n    if (tagName === undefined) continue;\n    let newJPath = \"\";\n    if (jPath.length === 0) newJPath = tagName;else newJPath = \"\".concat(jPath, \".\").concat(tagName);\n    if (tagName === options.textNodeName) {\n      let tagText = tagObj[tagName];\n      if (!isStopNode(newJPath, options)) {\n        tagText = options.tagValueProcessor(tagName, tagText);\n        tagText = replaceEntitiesValue(tagText, options);\n      }\n      if (isPreviousElementTag) {\n        xmlStr += indentation;\n      }\n      xmlStr += tagText;\n      isPreviousElementTag = false;\n      continue;\n    } else if (tagName === options.cdataPropName) {\n      if (isPreviousElementTag) {\n        xmlStr += indentation;\n      }\n      xmlStr += \"<![CDATA[\".concat(tagObj[tagName][0][options.textNodeName], \"]]>\");\n      isPreviousElementTag = false;\n      continue;\n    } else if (tagName === options.commentPropName) {\n      xmlStr += indentation + \"<!--\".concat(tagObj[tagName][0][options.textNodeName], \"-->\");\n      isPreviousElementTag = true;\n      continue;\n    } else if (tagName[0] === \"?\") {\n      const attStr = attr_to_str(tagObj[\":@\"], options);\n      const tempInd = tagName === \"?xml\" ? \"\" : indentation;\n      let piTextNodeName = tagObj[tagName][0][options.textNodeName];\n      piTextNodeName = piTextNodeName.length !== 0 ? \" \" + piTextNodeName : \"\"; //remove extra spacing\n      xmlStr += tempInd + \"<\".concat(tagName).concat(piTextNodeName).concat(attStr, \"?>\");\n      isPreviousElementTag = true;\n      continue;\n    }\n    let newIdentation = indentation;\n    if (newIdentation !== \"\") {\n      newIdentation += options.indentBy;\n    }\n    const attStr = attr_to_str(tagObj[\":@\"], options);\n    const tagStart = indentation + \"<\".concat(tagName).concat(attStr);\n    const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);\n    if (options.unpairedTags.indexOf(tagName) !== -1) {\n      if (options.suppressUnpairedNode) xmlStr += tagStart + \">\";else xmlStr += tagStart + \"/>\";\n    } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {\n      xmlStr += tagStart + \"/>\";\n    } else if (tagValue && tagValue.endsWith(\">\")) {\n      xmlStr += tagStart + \">\".concat(tagValue).concat(indentation, \"</\").concat(tagName, \">\");\n    } else {\n      xmlStr += tagStart + \">\";\n      if (tagValue && indentation !== \"\" && (tagValue.includes(\"/>\") || tagValue.includes(\"</\"))) {\n        xmlStr += indentation + options.indentBy + tagValue + indentation;\n      } else {\n        xmlStr += tagValue;\n      }\n      xmlStr += \"</\".concat(tagName, \">\");\n    }\n    isPreviousElementTag = true;\n  }\n  return xmlStr;\n}\nfunction propName(obj) {\n  const keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (!obj.hasOwnProperty(key)) continue;\n    if (key !== \":@\") return key;\n  }\n}\nfunction attr_to_str(attrMap, options) {\n  let attrStr = \"\";\n  if (attrMap && !options.ignoreAttributes) {\n    for (let attr in attrMap) {\n      if (!attrMap.hasOwnProperty(attr)) continue;\n      let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n      attrVal = replaceEntitiesValue(attrVal, options);\n      if (attrVal === true && options.suppressBooleanAttributes) {\n        attrStr += \" \".concat(attr.substr(options.attributeNamePrefix.length));\n      } else {\n        attrStr += \" \".concat(attr.substr(options.attributeNamePrefix.length), \"=\\\"\").concat(attrVal, \"\\\"\");\n      }\n    }\n  }\n  return attrStr;\n}\nfunction isStopNode(jPath, options) {\n  jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);\n  let tagName = jPath.substr(jPath.lastIndexOf(\".\") + 1);\n  for (let index in options.stopNodes) {\n    if (options.stopNodes[index] === jPath || options.stopNodes[index] === \"*.\" + tagName) return true;\n  }\n  return false;\n}\nfunction replaceEntitiesValue(textValue, options) {\n  if (textValue && textValue.length > 0 && options.processEntities) {\n    for (let i = 0; i < options.entities.length; i++) {\n      const entity = options.entities[i];\n      textValue = textValue.replace(entity.regex, entity.val);\n    }\n  }\n  return textValue;\n}\nmodule.exports = toXml;","map":{"version":3,"names":["EOL","toXml","jArray","options","indentation","format","indentBy","length","arrToStr","arr","jPath","xmlStr","isPreviousElementTag","i","tagObj","tagName","propName","undefined","newJPath","concat","textNodeName","tagText","isStopNode","tagValueProcessor","replaceEntitiesValue","cdataPropName","commentPropName","attStr","attr_to_str","tempInd","piTextNodeName","newIdentation","tagStart","tagValue","unpairedTags","indexOf","suppressUnpairedNode","suppressEmptyNode","endsWith","includes","obj","keys","Object","key","hasOwnProperty","attrMap","attrStr","ignoreAttributes","attr","attrVal","attributeValueProcessor","suppressBooleanAttributes","substr","attributeNamePrefix","lastIndexOf","index","stopNodes","textValue","processEntities","entities","entity","replace","regex","val","module","exports"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"],"sourcesContent":["const EOL = \"\\n\";\n\n/**\n * \n * @param {array} jArray \n * @param {any} options \n * @returns \n */\nfunction toXml(jArray, options) {\n    let indentation = \"\";\n    if (options.format && options.indentBy.length > 0) {\n        indentation = EOL;\n    }\n    return arrToStr(jArray, options, \"\", indentation);\n}\n\nfunction arrToStr(arr, options, jPath, indentation) {\n    let xmlStr = \"\";\n    let isPreviousElementTag = false;\n\n    for (let i = 0; i < arr.length; i++) {\n        const tagObj = arr[i];\n        const tagName = propName(tagObj);\n        if(tagName === undefined) continue;\n\n        let newJPath = \"\";\n        if (jPath.length === 0) newJPath = tagName\n        else newJPath = `${jPath}.${tagName}`;\n\n        if (tagName === options.textNodeName) {\n            let tagText = tagObj[tagName];\n            if (!isStopNode(newJPath, options)) {\n                tagText = options.tagValueProcessor(tagName, tagText);\n                tagText = replaceEntitiesValue(tagText, options);\n            }\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += tagText;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.cdataPropName) {\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.commentPropName) {\n            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\n            isPreviousElementTag = true;\n            continue;\n        } else if (tagName[0] === \"?\") {\n            const attStr = attr_to_str(tagObj[\":@\"], options);\n            const tempInd = tagName === \"?xml\" ? \"\" : indentation;\n            let piTextNodeName = tagObj[tagName][0][options.textNodeName];\n            piTextNodeName = piTextNodeName.length !== 0 ? \" \" + piTextNodeName : \"\"; //remove extra spacing\n            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;\n            isPreviousElementTag = true;\n            continue;\n        }\n        let newIdentation = indentation;\n        if (newIdentation !== \"\") {\n            newIdentation += options.indentBy;\n        }\n        const attStr = attr_to_str(tagObj[\":@\"], options);\n        const tagStart = indentation + `<${tagName}${attStr}`;\n        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);\n        if (options.unpairedTags.indexOf(tagName) !== -1) {\n            if (options.suppressUnpairedNode) xmlStr += tagStart + \">\";\n            else xmlStr += tagStart + \"/>\";\n        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {\n            xmlStr += tagStart + \"/>\";\n        } else if (tagValue && tagValue.endsWith(\">\")) {\n            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;\n        } else {\n            xmlStr += tagStart + \">\";\n            if (tagValue && indentation !== \"\" && (tagValue.includes(\"/>\") || tagValue.includes(\"</\"))) {\n                xmlStr += indentation + options.indentBy + tagValue + indentation;\n            } else {\n                xmlStr += tagValue;\n            }\n            xmlStr += `</${tagName}>`;\n        }\n        isPreviousElementTag = true;\n    }\n\n    return xmlStr;\n}\n\nfunction propName(obj) {\n    const keys = Object.keys(obj);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if(!obj.hasOwnProperty(key)) continue;\n        if (key !== \":@\") return key;\n    }\n}\n\nfunction attr_to_str(attrMap, options) {\n    let attrStr = \"\";\n    if (attrMap && !options.ignoreAttributes) {\n        for (let attr in attrMap) {\n            if(!attrMap.hasOwnProperty(attr)) continue;\n            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n            attrVal = replaceEntitiesValue(attrVal, options);\n            if (attrVal === true && options.suppressBooleanAttributes) {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;\n            } else {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}=\"${attrVal}\"`;\n            }\n        }\n    }\n    return attrStr;\n}\n\nfunction isStopNode(jPath, options) {\n    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);\n    let tagName = jPath.substr(jPath.lastIndexOf(\".\") + 1);\n    for (let index in options.stopNodes) {\n        if (options.stopNodes[index] === jPath || options.stopNodes[index] === \"*.\" + tagName) return true;\n    }\n    return false;\n}\n\nfunction replaceEntitiesValue(textValue, options) {\n    if (textValue && textValue.length > 0 && options.processEntities) {\n        for (let i = 0; i < options.entities.length; i++) {\n            const entity = options.entities[i];\n            textValue = textValue.replace(entity.regex, entity.val);\n        }\n    }\n    return textValue;\n}\nmodule.exports = toXml;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"import { toBase64 } from \"@smithy/util-base64\";\nimport { isReadableStream } from \"../stream-type-check\";\nimport { ChecksumStream } from \"./ChecksumStream.browser\";\nexport const createChecksumStream = _ref => {\n  let {\n    expectedChecksum,\n    checksum,\n    source,\n    checksumSourceLocation,\n    base64Encoder\n  } = _ref;\n  if (!isReadableStream(source)) {\n    var _source$constructor$n, _source$constructor;\n    throw new Error(\"@smithy/util-stream: unsupported source type \".concat((_source$constructor$n = source === null || source === void 0 || (_source$constructor = source.constructor) === null || _source$constructor === void 0 ? void 0 : _source$constructor.name) !== null && _source$constructor$n !== void 0 ? _source$constructor$n : source, \" in ChecksumStream.\"));\n  }\n  const encoder = base64Encoder !== null && base64Encoder !== void 0 ? base64Encoder : toBase64;\n  if (typeof TransformStream !== \"function\") {\n    throw new Error(\"@smithy/util-stream: unable to instantiate ChecksumStream because API unavailable: ReadableStream/TransformStream.\");\n  }\n  const transform = new TransformStream({\n    start() {},\n    async transform(chunk, controller) {\n      checksum.update(chunk);\n      controller.enqueue(chunk);\n    },\n    async flush(controller) {\n      const digest = await checksum.digest();\n      const received = encoder(digest);\n      if (expectedChecksum !== received) {\n        const error = new Error(\"Checksum mismatch: expected \\\"\".concat(expectedChecksum, \"\\\" but received \\\"\").concat(received, \"\\\"\") + \" in response header \\\"\".concat(checksumSourceLocation, \"\\\".\"));\n        controller.error(error);\n      } else {\n        controller.terminate();\n      }\n    }\n  });\n  source.pipeThrough(transform);\n  const readable = transform.readable;\n  Object.setPrototypeOf(readable, ChecksumStream.prototype);\n  return readable;\n};","map":{"version":3,"names":["toBase64","isReadableStream","ChecksumStream","createChecksumStream","_ref","expectedChecksum","checksum","source","checksumSourceLocation","base64Encoder","_source$constructor$n","_source$constructor","Error","concat","constructor","name","encoder","TransformStream","transform","start","chunk","controller","update","enqueue","flush","digest","received","error","terminate","pipeThrough","readable","Object","setPrototypeOf","prototype"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/@smithy/util-stream/dist-es/checksum/createChecksumStream.browser.js"],"sourcesContent":["import { toBase64 } from \"@smithy/util-base64\";\nimport { isReadableStream } from \"../stream-type-check\";\nimport { ChecksumStream } from \"./ChecksumStream.browser\";\nexport const createChecksumStream = ({ expectedChecksum, checksum, source, checksumSourceLocation, base64Encoder, }) => {\n    if (!isReadableStream(source)) {\n        throw new Error(`@smithy/util-stream: unsupported source type ${source?.constructor?.name ?? source} in ChecksumStream.`);\n    }\n    const encoder = base64Encoder ?? toBase64;\n    if (typeof TransformStream !== \"function\") {\n        throw new Error(\"@smithy/util-stream: unable to instantiate ChecksumStream because API unavailable: ReadableStream/TransformStream.\");\n    }\n    const transform = new TransformStream({\n        start() { },\n        async transform(chunk, controller) {\n            checksum.update(chunk);\n            controller.enqueue(chunk);\n        },\n        async flush(controller) {\n            const digest = await checksum.digest();\n            const received = encoder(digest);\n            if (expectedChecksum !== received) {\n                const error = new Error(`Checksum mismatch: expected \"${expectedChecksum}\" but received \"${received}\"` +\n                    ` in response header \"${checksumSourceLocation}\".`);\n                controller.error(error);\n            }\n            else {\n                controller.terminate();\n            }\n        },\n    });\n    source.pipeThrough(transform);\n    const readable = transform.readable;\n    Object.setPrototypeOf(readable, ChecksumStream.prototype);\n    return readable;\n};\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,qBAAqB;AAC9C,SAASC,gBAAgB,QAAQ,sBAAsB;AACvD,SAASC,cAAc,QAAQ,0BAA0B;AACzD,OAAO,MAAMC,oBAAoB,GAAGC,IAAA,IAAoF;EAAA,IAAnF;IAAEC,gBAAgB;IAAEC,QAAQ;IAAEC,MAAM;IAAEC,sBAAsB;IAAEC;EAAe,CAAC,GAAAL,IAAA;EAC/G,IAAI,CAACH,gBAAgB,CAACM,MAAM,CAAC,EAAE;IAAA,IAAAG,qBAAA,EAAAC,mBAAA;IAC3B,MAAM,IAAIC,KAAK,iDAAAC,MAAA,EAAAH,qBAAA,GAAiDH,MAAM,aAANA,MAAM,gBAAAI,mBAAA,GAANJ,MAAM,CAAEO,WAAW,cAAAH,mBAAA,uBAAnBA,mBAAA,CAAqBI,IAAI,cAAAL,qBAAA,cAAAA,qBAAA,GAAIH,MAAM,wBAAqB,CAAC;EAC7H;EACA,MAAMS,OAAO,GAAGP,aAAa,aAAbA,aAAa,cAAbA,aAAa,GAAIT,QAAQ;EACzC,IAAI,OAAOiB,eAAe,KAAK,UAAU,EAAE;IACvC,MAAM,IAAIL,KAAK,CAAC,oHAAoH,CAAC;EACzI;EACA,MAAMM,SAAS,GAAG,IAAID,eAAe,CAAC;IAClCE,KAAKA,CAAA,EAAG,CAAE,CAAC;IACX,MAAMD,SAASA,CAACE,KAAK,EAAEC,UAAU,EAAE;MAC/Bf,QAAQ,CAACgB,MAAM,CAACF,KAAK,CAAC;MACtBC,UAAU,CAACE,OAAO,CAACH,KAAK,CAAC;IAC7B,CAAC;IACD,MAAMI,KAAKA,CAACH,UAAU,EAAE;MACpB,MAAMI,MAAM,GAAG,MAAMnB,QAAQ,CAACmB,MAAM,CAAC,CAAC;MACtC,MAAMC,QAAQ,GAAGV,OAAO,CAACS,MAAM,CAAC;MAChC,IAAIpB,gBAAgB,KAAKqB,QAAQ,EAAE;QAC/B,MAAMC,KAAK,GAAG,IAAIf,KAAK,CAAC,iCAAAC,MAAA,CAAgCR,gBAAgB,wBAAAQ,MAAA,CAAmBa,QAAQ,mCAAAb,MAAA,CACvEL,sBAAsB,QAAI,CAAC;QACvDa,UAAU,CAACM,KAAK,CAACA,KAAK,CAAC;MAC3B,CAAC,MACI;QACDN,UAAU,CAACO,SAAS,CAAC,CAAC;MAC1B;IACJ;EACJ,CAAC,CAAC;EACFrB,MAAM,CAACsB,WAAW,CAACX,SAAS,CAAC;EAC7B,MAAMY,QAAQ,GAAGZ,SAAS,CAACY,QAAQ;EACnCC,MAAM,CAACC,cAAc,CAACF,QAAQ,EAAE5B,cAAc,CAAC+B,SAAS,CAAC;EACzD,OAAOH,QAAQ;AACnB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
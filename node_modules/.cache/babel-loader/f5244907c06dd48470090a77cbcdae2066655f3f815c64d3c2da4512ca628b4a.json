{"ast":null,"code":"import { HttpRequest, HttpResponse } from \"@smithy/protocol-http\";\nimport { isServerError, isThrottlingError, isTransientError } from \"@smithy/service-error-classification\";\nimport { NoOpLogger } from \"@smithy/smithy-client\";\nimport { INVOCATION_ID_HEADER, REQUEST_HEADER } from \"@smithy/util-retry\";\nimport { v4 } from \"uuid\";\nimport { isStreamingPayload } from \"./isStreamingPayload/isStreamingPayload\";\nimport { asSdkError } from \"./util\";\nexport const retryMiddleware = options => (next, context) => async args => {\n  let retryStrategy = await options.retryStrategy();\n  const maxAttempts = await options.maxAttempts();\n  if (isRetryStrategyV2(retryStrategy)) {\n    retryStrategy = retryStrategy;\n    let retryToken = await retryStrategy.acquireInitialRetryToken(context[\"partition_id\"]);\n    let lastError = new Error();\n    let attempts = 0;\n    let totalRetryDelay = 0;\n    const {\n      request\n    } = args;\n    const isRequest = HttpRequest.isInstance(request);\n    if (isRequest) {\n      request.headers[INVOCATION_ID_HEADER] = v4();\n    }\n    while (true) {\n      try {\n        if (isRequest) {\n          request.headers[REQUEST_HEADER] = \"attempt=\".concat(attempts + 1, \"; max=\").concat(maxAttempts);\n        }\n        const {\n          response,\n          output\n        } = await next(args);\n        retryStrategy.recordSuccess(retryToken);\n        output.$metadata.attempts = attempts + 1;\n        output.$metadata.totalRetryDelay = totalRetryDelay;\n        return {\n          response,\n          output\n        };\n      } catch (e) {\n        const retryErrorInfo = getRetryErrorInfo(e);\n        lastError = asSdkError(e);\n        if (isRequest && isStreamingPayload(request)) {\n          var _ref;\n          (_ref = context.logger instanceof NoOpLogger ? console : context.logger) === null || _ref === void 0 || _ref.warn(\"An error was encountered in a non-retryable streaming request.\");\n          throw lastError;\n        }\n        try {\n          retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);\n        } catch (refreshError) {\n          if (!lastError.$metadata) {\n            lastError.$metadata = {};\n          }\n          lastError.$metadata.attempts = attempts + 1;\n          lastError.$metadata.totalRetryDelay = totalRetryDelay;\n          throw lastError;\n        }\n        attempts = retryToken.getRetryCount();\n        const delay = retryToken.getRetryDelay();\n        totalRetryDelay += delay;\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n  } else {\n    var _retryStrategy;\n    retryStrategy = retryStrategy;\n    if ((_retryStrategy = retryStrategy) !== null && _retryStrategy !== void 0 && _retryStrategy.mode) context.userAgent = [...(context.userAgent || []), [\"cfg/retry-mode\", retryStrategy.mode]];\n    return retryStrategy.retry(next, args);\n  }\n};\nconst isRetryStrategyV2 = retryStrategy => typeof retryStrategy.acquireInitialRetryToken !== \"undefined\" && typeof retryStrategy.refreshRetryTokenForRetry !== \"undefined\" && typeof retryStrategy.recordSuccess !== \"undefined\";\nconst getRetryErrorInfo = error => {\n  const errorInfo = {\n    error,\n    errorType: getRetryErrorType(error)\n  };\n  const retryAfterHint = getRetryAfterHint(error.$response);\n  if (retryAfterHint) {\n    errorInfo.retryAfterHint = retryAfterHint;\n  }\n  return errorInfo;\n};\nconst getRetryErrorType = error => {\n  if (isThrottlingError(error)) return \"THROTTLING\";\n  if (isTransientError(error)) return \"TRANSIENT\";\n  if (isServerError(error)) return \"SERVER_ERROR\";\n  return \"CLIENT_ERROR\";\n};\nexport const retryMiddlewareOptions = {\n  name: \"retryMiddleware\",\n  tags: [\"RETRY\"],\n  step: \"finalizeRequest\",\n  priority: \"high\",\n  override: true\n};\nexport const getRetryPlugin = options => ({\n  applyToStack: clientStack => {\n    clientStack.add(retryMiddleware(options), retryMiddlewareOptions);\n  }\n});\nexport const getRetryAfterHint = response => {\n  if (!HttpResponse.isInstance(response)) return;\n  const retryAfterHeaderName = Object.keys(response.headers).find(key => key.toLowerCase() === \"retry-after\");\n  if (!retryAfterHeaderName) return;\n  const retryAfter = response.headers[retryAfterHeaderName];\n  const retryAfterSeconds = Number(retryAfter);\n  if (!Number.isNaN(retryAfterSeconds)) return new Date(retryAfterSeconds * 1000);\n  const retryAfterDate = new Date(retryAfter);\n  return retryAfterDate;\n};","map":{"version":3,"names":["HttpRequest","HttpResponse","isServerError","isThrottlingError","isTransientError","NoOpLogger","INVOCATION_ID_HEADER","REQUEST_HEADER","v4","isStreamingPayload","asSdkError","retryMiddleware","options","next","context","args","retryStrategy","maxAttempts","isRetryStrategyV2","retryToken","acquireInitialRetryToken","lastError","Error","attempts","totalRetryDelay","request","isRequest","isInstance","headers","concat","response","output","recordSuccess","$metadata","e","retryErrorInfo","getRetryErrorInfo","_ref","logger","console","warn","refreshRetryTokenForRetry","refreshError","getRetryCount","delay","getRetryDelay","Promise","resolve","setTimeout","_retryStrategy","mode","userAgent","retry","error","errorInfo","errorType","getRetryErrorType","retryAfterHint","getRetryAfterHint","$response","retryMiddlewareOptions","name","tags","step","priority","override","getRetryPlugin","applyToStack","clientStack","add","retryAfterHeaderName","Object","keys","find","key","toLowerCase","retryAfter","retryAfterSeconds","Number","isNaN","Date","retryAfterDate"],"sources":["/Users/codinggents/Documents/lambdaforge/node_modules/@smithy/middleware-retry/dist-es/retryMiddleware.js"],"sourcesContent":["import { HttpRequest, HttpResponse } from \"@smithy/protocol-http\";\nimport { isServerError, isThrottlingError, isTransientError } from \"@smithy/service-error-classification\";\nimport { NoOpLogger } from \"@smithy/smithy-client\";\nimport { INVOCATION_ID_HEADER, REQUEST_HEADER } from \"@smithy/util-retry\";\nimport { v4 } from \"uuid\";\nimport { isStreamingPayload } from \"./isStreamingPayload/isStreamingPayload\";\nimport { asSdkError } from \"./util\";\nexport const retryMiddleware = (options) => (next, context) => async (args) => {\n    let retryStrategy = await options.retryStrategy();\n    const maxAttempts = await options.maxAttempts();\n    if (isRetryStrategyV2(retryStrategy)) {\n        retryStrategy = retryStrategy;\n        let retryToken = await retryStrategy.acquireInitialRetryToken(context[\"partition_id\"]);\n        let lastError = new Error();\n        let attempts = 0;\n        let totalRetryDelay = 0;\n        const { request } = args;\n        const isRequest = HttpRequest.isInstance(request);\n        if (isRequest) {\n            request.headers[INVOCATION_ID_HEADER] = v4();\n        }\n        while (true) {\n            try {\n                if (isRequest) {\n                    request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;\n                }\n                const { response, output } = await next(args);\n                retryStrategy.recordSuccess(retryToken);\n                output.$metadata.attempts = attempts + 1;\n                output.$metadata.totalRetryDelay = totalRetryDelay;\n                return { response, output };\n            }\n            catch (e) {\n                const retryErrorInfo = getRetryErrorInfo(e);\n                lastError = asSdkError(e);\n                if (isRequest && isStreamingPayload(request)) {\n                    (context.logger instanceof NoOpLogger ? console : context.logger)?.warn(\"An error was encountered in a non-retryable streaming request.\");\n                    throw lastError;\n                }\n                try {\n                    retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);\n                }\n                catch (refreshError) {\n                    if (!lastError.$metadata) {\n                        lastError.$metadata = {};\n                    }\n                    lastError.$metadata.attempts = attempts + 1;\n                    lastError.$metadata.totalRetryDelay = totalRetryDelay;\n                    throw lastError;\n                }\n                attempts = retryToken.getRetryCount();\n                const delay = retryToken.getRetryDelay();\n                totalRetryDelay += delay;\n                await new Promise((resolve) => setTimeout(resolve, delay));\n            }\n        }\n    }\n    else {\n        retryStrategy = retryStrategy;\n        if (retryStrategy?.mode)\n            context.userAgent = [...(context.userAgent || []), [\"cfg/retry-mode\", retryStrategy.mode]];\n        return retryStrategy.retry(next, args);\n    }\n};\nconst isRetryStrategyV2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== \"undefined\" &&\n    typeof retryStrategy.refreshRetryTokenForRetry !== \"undefined\" &&\n    typeof retryStrategy.recordSuccess !== \"undefined\";\nconst getRetryErrorInfo = (error) => {\n    const errorInfo = {\n        error,\n        errorType: getRetryErrorType(error),\n    };\n    const retryAfterHint = getRetryAfterHint(error.$response);\n    if (retryAfterHint) {\n        errorInfo.retryAfterHint = retryAfterHint;\n    }\n    return errorInfo;\n};\nconst getRetryErrorType = (error) => {\n    if (isThrottlingError(error))\n        return \"THROTTLING\";\n    if (isTransientError(error))\n        return \"TRANSIENT\";\n    if (isServerError(error))\n        return \"SERVER_ERROR\";\n    return \"CLIENT_ERROR\";\n};\nexport const retryMiddlewareOptions = {\n    name: \"retryMiddleware\",\n    tags: [\"RETRY\"],\n    step: \"finalizeRequest\",\n    priority: \"high\",\n    override: true,\n};\nexport const getRetryPlugin = (options) => ({\n    applyToStack: (clientStack) => {\n        clientStack.add(retryMiddleware(options), retryMiddlewareOptions);\n    },\n});\nexport const getRetryAfterHint = (response) => {\n    if (!HttpResponse.isInstance(response))\n        return;\n    const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === \"retry-after\");\n    if (!retryAfterHeaderName)\n        return;\n    const retryAfter = response.headers[retryAfterHeaderName];\n    const retryAfterSeconds = Number(retryAfter);\n    if (!Number.isNaN(retryAfterSeconds))\n        return new Date(retryAfterSeconds * 1000);\n    const retryAfterDate = new Date(retryAfter);\n    return retryAfterDate;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}